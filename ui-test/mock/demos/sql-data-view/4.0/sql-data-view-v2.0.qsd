# -*- mode: qore; indent-tabs-mode: nil -*-
# service: sql-data-view
# class-name: SqlDataView
# serviceversion: 2.0
# servicedesc: SQL Data View Browser; uses the sql-data-view.max-rows system property to determine the maximum number of rows to return (default 100)
# serviceauthor: Qore Technologies, s.r.o.
# remote: 1
# autostart: true
# define-group: EBS: EBS utility services
# groups: EBS
# resource: index.qhtml
# resource: bundle.js
# resource: css/*
# resource: js/*
## resource: static/*
## resource: templates/*
# ENDSERVICE

%new-style
%require-types
%strict-args
%enable-all-warnings

%requires SqlUtil
%requires OracleSqlUtil

const FeaturesMap = {
    SqlUtil::DB_FUNCTIONS     : {"name": "Functions",         "order": 4,},
    SqlUtil::DB_MVIEWS        : {"name": "MaterializedViews", "order": 1,},
    SqlUtil::DB_PACKAGES      : {"name": "Packages",          "order": 3,},
    SqlUtil::DB_PROCEDURES    : {"name": "Procedures",        "order": 4,},
    SqlUtil::DB_SEQUENCES     : {"name": "Sequences",         "order": 2,},
    SqlUtil::DB_TABLES        : {"name": "Tables",            "order": 0,},
    SqlUtil::DB_TYPES         : {"name": "Types",             "order": 5,},
    SqlUtil::DB_VIEWS         : {"name": "Views",             "order": 1,},
    SqlUtil::DB_SYNONYMS      : {"name": "Synonyms",          "order": 6,},
};

const DefaultMaxRows = 100;
const AbsoluteMaxRows = 1000;

int sub sort_features(string v1, string v2) {
    return sort_any(FeaturesMap{v1}.order, FeaturesMap{v2}.order);
}

int sub sort_objects(hash<auto> v1, hash<auto> v2) {
    return sort_any(v1.name, v2.name);
}

int sub sort_any(auto v1, auto v2) {
    if (v1 == v2) return 0;
    else if (v1 > v2) return 1;
    else return -1;
}

class DbRestHandler inherits AbstractServiceRestHandler {
    private {
        hash<auto> m_dsCache;
    }

    constructor() : AbstractServiceRestHandler("db") {
    }

    private SqlUtil::Database getDatabase(string datasource) {
        if (!exists m_dsCache{datasource}) {
            DatasourcePool ds = get_datasource_pool(datasource);
            m_dsCache{datasource} = new SqlUtil::Database(ds, ( "native_case" : True ));
        }
        return m_dsCache{datasource};
    }

    string name() {
        return 'DbRestHandler';
    }

    hash<auto> get(hash<auto> cx, *hash<auto> ah) {
        #log(LL_INFO, "CX: %y; AH: %y", cx, ah);
        return RestHandler::makeResponse(200, get_method_list(self));
    }

    hash<auto> getDatasources(hash<auto> cx, *hash<auto> ah) {
        #log(LL_INFO, "CX: %y; AH: %y", cx, ah);
        list<hash<auto>> ret = map (
            "name": $1.name,
            "type": $1.url_hash.type,
        ), call_rest_api("GET", "remote/datasources"), !$1.locked;
        ret = sort(ret, "sort_objects");
        return RestHandler::makeResponse(200, ret);
    }

    hash<auto> getFeatures(hash<auto> cx, *hash<auto> ah) {
        #log(LL_INFO, "AH: %y", ah);
        string datasource = ah.datasource;
        SqlUtil::Database db = getDatabase(datasource);
        list ret;
        ListIterator it(db.features());
        while (it.next()) {
            push ret, it.getValue();
        }

        ret = sort(ret, "sort_features");
        ret = map FeaturesMap{$1}, ret;

        return RestHandler::makeResponse(200, ret);
    }

    private hash<auto> privGetObjects(hash<auto> ah, string objectType) {
        #log(LL_INFO, "AH: %y", $ah);
        string datasource = ah.datasource;
        string method = sprintf("%sIterator", objectType);

        SqlUtil::Database db = getDatabase(datasource);

        ListIterator li = call_object_method(db, method);
        list ret = list();

        while (li.next()) {
            push ret, ('name': li.getValue(), 'type' : objectType, );
        }

        ret = sort(ret, "sort_objects");

        return RestHandler::makeResponse(200, ret);
    }

    hash<auto> getTables(hash<auto> cx, *hash<auto> ah) {
        return privGetObjects(ah, "table");
    }

    hash<auto> getViews(hash<auto> cx, *hash<auto> ah) {
        return privGetObjects(ah, "view");
    }

    hash<auto> getSequences(hash<auto> cx, *hash<auto> ah) {
        return privGetObjects(ah, "sequence");
    }

    hash<auto> getFunctions(hash<auto> cx, *hash<auto> ah) {
        return privGetObjects(ah, "function");
    }

    hash<auto> getProcedures(hash<auto> cx, *hash<auto> ah) {
        return privGetObjects(ah, "procedure");
    }

    hash<auto> getPackages(hash<auto> cx, *hash<auto> ah) {
        return privGetObjects(ah, "package");
    }

    hash<auto> getTypes(hash<auto> cx, *hash<auto> ah) {
        return privGetObjects(ah, "type");
    }

    hash<auto> getMaterializedViews(hash<auto> cx, *hash<auto> ah) {
        return privGetObjects(ah, "materializedView");
    }

    hash<auto> getSynonyms(hash<auto> cx, *hash<auto> ah) {
        return privGetObjects(ah, "synonym");
    }

    private hash<auto> column2hash(SqlUtil::AbstractColumn c) {
        return {
            "coment"   : c.comment,
            "default"  : c.def_val,
            "name"     : c.name,
            "type"     : c.native_type,
            "nullable" : c.nullable,
            "size"     : c.size,
        };
    }

    hash<auto> getTableStructure(hash<auto> cx, *hash<auto> ah) {
        #log(LL_INFO, "CX: %y; AH: %y", cx, ah);

        string datasource = ah.datasource;
        string name = ah.name;

        SqlUtil::Database db = getDatabase(datasource);
        SqlUtil::AbstractTable tab = db.getTable(name);

        HashIterator itColumns = tab.describe().iterator();
        list columns;
        while (itColumns.next()) {
            push columns, column2hash(itColumns.getValue());
        }

        list<auto> pks;
        if (!tab.getPrimaryKey().empty()) {
            HashIterator it = tab.getPrimaryKey().iterator();
            while (it.next()) {
                push pks, column2hash(it.getValue());
            }
        }

        list<hash<auto>> ixs;
        if (!tab.getIndexes().empty()) {
            HashIterator it = tab.getIndexes().iterator();
            while (it.next()) {
                hash<auto> ix = {
                    "name": it.getValue().name,
                    "unique": exists it.getValue().unique ? it.getValue().unique : False,
                    "columns": (),
                };

                HashIterator cit = it.getValue().columns.iterator();
                while (cit.next()) {
                    # TODO/FIXME: implement proper support for function based indexes in SqlUtil
                    # cit.getValue() is SqlUtil::AbstractColumn in normal index but is plain hash<auto> (<EMPTY HASH>) for function ix
                    if (cit.getValue().typeCode() == NT_HASH) {
                        push ix.columns, 'n/a';
                    } else {
                        push ix.columns, column2hash(cit.getValue());
                    }
                }
                push ixs, ix;
            }
        }

        list<hash<auto>> trgs;
        if (!tab.getTriggers().empty()) {
            HashIterator it = tab.getTriggers().iterator();
            while (it.next()) {
                hash<auto> trg;
                trg.name = it.getValue().name;
                trg.src = it.getValue().src;
                push trgs, trg;
            }
        }

        hash<auto> ret = {
            "name"      : tab.getName(),
            "sqlname"   : tab.getSqlName(),
            "columns"   : columns,
            "pk"        : pks,
            "indexes"   : ixs,
            "triggers"  : trgs,
        };

        return RestHandler::makeResponse(200, ret);
    }

    hash<auto> getTableData(hash<auto> cx, *hash<auto> ah) {
        log(LL_INFO, "CX: %y; AH: %y", cx, ah);

        string datasource = ah.datasource;
        string name = ah.name;

        SqlUtil::Database db = getDatabase(datasource);
        SqlUtil::AbstractTable tab = db.getTable(name);

        *hash<auto> sqlWhere;

        if (!exists ah."where") {
            sqlWhere.limit = ServiceApi::getConfigItemValue("max-rows");
            log(LL_INFO, "performing select with max-rows = %d", sqlWhere.limit);
            if (sqlWhere.limit > AbsoluteMaxRows) {
                log(LL_INFO, "WARNING! config item \"max-rows\" value %d exceeds the hardcoded maximum %d; using %d "
                    "instead", sqlWhere.limit, AbsoluteMaxRows, AbsoluteMaxRows);
                sqlWhere.limit = AbsoluteMaxRows;
            }
        } else {
            list rawWhere = parse_json(ah.where);
            ListIterator it(rawWhere);
            hash<auto> whereData;
            while (it.next()) {
                # where : "[{\"name\":\"pk_function_type-name-operator\",\"value\":\"=\"},
                #           {\"name\":\"pk_function_type-name-value\",\"value\":\"asdasd\"}]
                hash<auto> obj = it.getValue();
                list l = obj.name.split("-");
                string column = l[0];
                string op = l[1];
                whereData{column}{op} = obj.value;
            }

            log(LL_INFO, "%N", whereData);

            HashIterator wit(whereData);
            while (wit.next()) {
                if (wit.getValue().isnull == "on") {
                    sqlWhere.where{wit.getKey()} = NULL;
                    continue;
                }
                if (wit.getValue().value == "") {
                    continue;
                }
                switch (wit.getValue().operator) {
                    case "=":
                        sqlWhere.where{wit.getKey()} = wit.getValue().value;
                        break;
                    case "!=":
                        sqlWhere.where{wit.getKey()} = op_ne(wit.getValue().value);
                        break;
                    case ">":
                        sqlWhere.where{wit.getKey()} = op_gt(wit.getValue().value);
                        break;
                    case "<":
                        sqlWhere.where{wit.getKey()} = op_lt(wit.getValue().value);
                        break;
                    default:
                        # TODO/FIXME
                        #sqlWhere.where{wit.getKey()} = wit.getValue().value;
                }
            }
            if (sqlWhere.limit > AbsoluteMaxRows) {
                log(LL_INFO, "WARNING! select criteria \"max-rows\" value %d exceeds the hardcoded maximum %d; using "
                    "%d instead", sqlWhere.limit, AbsoluteMaxRows, AbsoluteMaxRows);
                sqlWhere.limit = AbsoluteMaxRows;
            }
        }

        log(LL_INFO, "select criteria: %N", sqlWhere);

        list<auto> ret = tab.selectRows(sqlWhere);
        return RestHandler::makeResponse(200, ret);
    }

    private hash<auto> privGetObjAttrs(object obj, list omit=()) {
        ObjectIterator it(obj);
        hash<auto> ret;
        while (it.next()) {
            if (omit.contains(it.getKey()))
                continue;
            ret{it.getKey()} = it.getValue();
        }
        return ret;
    }

    hash<auto> getSequenceStructure(hash<auto> cx, *hash<auto> ah) {
        #log(LL_INFO, "CX: %y; AH: %y", cx, ah);

        string datasource = ah.datasource;
        string name = ah.name;

        SqlUtil::Database db = getDatabase(datasource);
        SqlUtil::AbstractSequence obj = db.getSequence(name);

        hash<auto> ret = privGetObjAttrs(obj);
        return RestHandler::makeResponse(200, ret);
    }

    hash<auto> getFunctionStructure(hash<auto> cx, *hash<auto> ah) {
        #log(LL_INFO, "CX: %y; AH: %y", cx, ah);

        string datasource = ah.datasource;
        string name = ah.name;

        SqlUtil::Database db = getDatabase(datasource);
        SqlUtil::AbstractFunction obj = db.getFunction(name);

        hash<auto> ret = privGetObjAttrs(obj);
        return RestHandler::makeResponse(200, ret);
    }

    hash<auto> getPackageStructure(hash<auto> cx, *hash<auto> ah) {
        #log(LL_INFO, "CX: %y; AH: %y", cx, ah);

        string datasource = ah.datasource;
        string name = ah.name;

        SqlUtil::Database db = getDatabase(datasource);
        if (!db.supportsPackages())
            throw "NOT-SUPPORTED-OBJECT", sprintf("DB '%s' does not support packages", datasource);

        OracleSqlUtil::OraclePackage obj = db.getPackage(name);

        hash<auto> ret = privGetObjAttrs(obj);

        ret.src_body = "TODO/FIXME: $obj.src_body is private";

        return RestHandler::makeResponse(200, ret);
    }

    hash<auto> getTypeStructure(hash<auto> cx, *hash<auto> ah) {
        #log(LL_INFO, "CX: %y; AH: %y", cx, ah);

        string datasource = ah.datasource;
        string name = ah.name;

        SqlUtil::Database db = getDatabase(datasource);
        if (!db.supportsTypes())
            throw "NOT-SUPPORTED-OBJECT", sprintf("DB '%s' does not support types", datasource);

        SqlUtil::AbstractFunction obj = db.getType(name);

        hash<auto> ret = privGetObjAttrs(obj);
        return RestHandler::makeResponse(200, ret);
    }

    hash<auto> getProcedureStructure(hash<auto> cx, *hash<auto> ah) {
        #log(LL_INFO, "CX: %y; AH: %y", cx, ah);

        string datasource = ah.datasource;
        string name = ah.name;

        SqlUtil::Database db = getDatabase(datasource);
        *SqlUtil::AbstractFunction obj = db.getProcedure(name);

        hash<auto> ret = privGetObjAttrs(obj);
        return RestHandler::makeResponse(200, ret);
    }

    hash<auto> getViewStructure(hash<auto> cx, *hash<auto> ah) {
        #log(LL_INFO, "CX: %y; AH: %y", cx, ah);

        string datasource = ah.datasource;
        string name = ah.name;

        SqlUtil::Database db = getDatabase(datasource);
        *SqlUtil::AbstractView obj = db.getView(name);

        hash<auto> ret = privGetObjAttrs(obj);
        return RestHandler::makeResponse(200, ret);
    }

    hash<auto> getMaterializedViewStructure(hash<auto> cx, *hash<auto> ah) {
        #log(LL_INFO, "CX: %y; AH: %y", cx, ah);

        string datasource = ah.datasource;
        string name = ah.name;

        SqlUtil::Database db = getDatabase(datasource);
        *OracleSqlUtil::OracleMaterializedView obj = db.getMaterializedView(name);

        hash<auto> ret = privGetObjAttrs(obj);
        return RestHandler::makeResponse(200, ret);
    }

    hash<auto> getSynonymStructure(hash<auto> cx, *hash<auto> ah) {
        #log(LL_INFO, "CX: %y; AH: %y", cx, ah);

        string datasource = ah.datasource;
        string name = ah.name;

        SqlUtil::Database db = getDatabase(datasource);
        *hash<auto> ret = db.getDatasource().selectRow("select * from user_synonyms where synonym_name = %v", name.upr());
        if (!ret) {
            ret = {"error": "no info found"};
        }

        return RestHandler::makeResponse(200, ret);
    }

    hash<auto> getSql(hash<auto> cx, *hash<auto> ah) {
        log(LL_INFO, "CX: %y; AH: %y", cx, ah);

        # AH: hash: (datasource : "isepl", sql-statement : "asdads", commit : "on", explain : "on")
        string datasource = ah.datasource;
        string sql = parse_base64_string_to_string(ah."sql-statement");
        bool commit = ah.commit == "on";
        bool explain = ah.explain == "on";

        log(LL_INFO, "SQL: %y", sql);

        DatasourcePool ds = get_datasource_pool(datasource);
        # an ugly hack. Just because of nature of JS/UI we need to return format
        # of selectRows(), not of select() which us used by defualt by exec.
        # So just start the explicit transaction to commit/rollback later.
        # All statements are handled with selectRows().
        ds.beginTransaction();
        on_exit ds.rollback();

        if (explain) {
            # explain is only supported on Oracle for now
            if (ds.getDriverName() != "oracle") {
                return RestHandler::makeResponse(200, "explain plan not supported on datasource %y with driver %y; "
                    "explain plan is only supported on oracle DBs", datasource, ds.getDriverName());
            }
            sql = "explain plan for " + sql;
        }

        auto ret;
        try {
            # get max rows parameter
            int max_rows = ServiceApi::getConfigItemValue("max-rows");
            log(LL_INFO, "performing select with max-rows = %d", max_rows);
            if (max_rows > AbsoluteMaxRows) {
                log(LL_INFO, "WARNING! config item \"max-rows\" value %d exceeds the hardcoded maximum %d; using %d instead", max_rows,
                    AbsoluteMaxRows, AbsoluteMaxRows);
                max_rows = AbsoluteMaxRows;
            }

            SQLStatement stmt(ds);
            stmt.prepare(sql);

            if (sql =~ /^select/i) {
                log(LL_INFO, "executing select statement");
                ret = stmt.fetchRows(max_rows);
                if (ret.lsize() == max_rows) {
                    log(LL_INFO, "rows selected: %d (max %d); more data potentially available", ret.lsize(), max_rows);
                } else {
                    log(LL_INFO, "rows selected: %d (max %d)", ret.lsize(), max_rows);
                }
            } else {
                log(LL_INFO, "executing non-select SQL statement");
                stmt.exec();
                ret = {"affected-rows": stmt.affectedRows()};
                log(LL_INFO, "rows affected: %d", ret."affected-rows");
            }
        } catch (hash<ExceptionInfo> ex) {
            return RestHandler::makeResponse(200, {"err": ex.err, "desc": ex.desc, "arg": ex.arg});
        }

        if (explain) {
            ret = ds.selectRows("select * from table(dbms_xplan.display)");
        }

        if (commit) {
            ds.commit();
        }

        return RestHandler::makeResponse(200, ret);
    }
} # class DbRestHandler

class SqlExtensionHandler inherits QorusExtensionHandler {
    constructor() : QorusExtensionHandler("SQL", "SQL Data View", "Allows database and table browsing") {
        setDefaultResource("index.qhtml");
    }
}

class SqlDataView inherits QorusService {
    # name: init
    # desc: initializes the service and registers the handlers
    init() {
        uiExtensionRegister(new SqlExtensionHandler());
        DbRestHandler r();
        bindHttp(r);
    }

    # name: ping
    # desc: just show if the service is alive
    string ping() {
        return "OK";
    }

    private *hash<string, hash<ConfigItemInfo>> getConfigItemsImpl() {
        return {
            "max-rows": <ConfigItemInfo>{
                "type": "int",
                "default_value": DefaultMaxRows,
                "desc": "the maximum number of rows to return in a select query; values greater than 1000 are ignored",
                "mandatory": True,
            },
        };
    }
}
