#!/usr/bin/env qore

%new-style
%strict-args
%require-types
%enable-all-warnings

%module-cmd(jni) add-classpath $OMQ_DIR/user/jar/rabbitmq/amqp-client-5.2.0.jar
%module-cmd(jni) add-classpath $OMQ_DIR/user/jar/slf4j-simple-1.7.25.jar
%module-cmd(jni) add-classpath $OMQ_DIR/user/jar/slf4j-api-1.7.25.jar

%module-cmd(jni) import com.rabbitmq.client.ConnectionFactory
%module-cmd(jni) import com.rabbitmq.client.Connection
%module-cmd(jni) import com.rabbitmq.client.RecoverableChannel
%module-cmd(jni) import com.rabbitmq.client.DefaultConsumer
%module-cmd(jni) import com.rabbitmq.client.impl.AMQBasicProperties
%module-cmd(jni) import com.rabbitmq.client.Envelope

%exec-class RabbitMqTest

class RabbitMqTest {
    public {
        const QUEUE_NAME = "hello";

        Counter cnt(1);
    }

    constructor() {
        ConnectionFactory factory();
        background listener(factory);
        Connection connection = factory.newConnection();
        on_exit connection.close();
        RecoverableChannel channel = connection.createChannel();
        on_exit channel.close();
        channel.queueDeclare(QUEUE_NAME, False, False, False);
        string message = "Hello World!";
        channel.basicPublish("", QUEUE_NAME, NOTHING, getBytes(message));
        printf(" [x] Sent %y\n", message);
    }

    listener(ConnectionFactory factory) {
        Connection connection = factory.newConnection();
        on_exit connection.close();
        RecoverableChannel channel = connection.createChannel();
        on_exit channel.close();
        channel.queueDeclare(QUEUE_NAME, False, False, False);
        string tag = channel.basicConsume(QUEUE_NAME, True, cast<DefaultConsumer>(implement_interface(new QoreInvocationHandler(\processMsg()), load_class("com/rabbitmq/client/Consumer"))));
        on_exit channel.basicCancel(tag);
        # wait for message to be received
        cnt.waitForZero();
        printf("TID %d: exiting listener thread\n", gettid());
    }

    processMsg(Method method, *list<auto> args) {
        printf("called method: %y (%y) args: %y\n", method.toString(),method.getName(), args);
        if (method.getName() != "handleDelivery") {
            return;
        }

        handleDelivery(args[0], args[1], args[2], args[3]);
    }

    # Java arrays are serialized as Qore lists but without subtype information, so we can't use list<int> for byte[]
    handleDelivery(string ctag, Envelope env, BasicProperties props, *list<auto> body) {
        on_exit {
            # signal listener thread that it can exit
            if (cnt.getCount()) {
                cnt.dec();
            }
        }

        # deserialize body from Java byte[], Qore list<int>
        binary b;
        # byte order does not matter when deserializing single bytes
        map b += $1.encodeMsb(1), body;
        string msg = binary_to_string(b);

        # log msg info
        printf("got message: ctag: %y env: %y props: %y body: %y msg: %y\n", ctag, env.toString(), props.toString(), body, msg);
    }

    # serialize a string to a list of bytes
    static list<auto> getBytes(string msg) {
        binary b = binary(msg);
        return map b[$#], xrange(b.size() - 1);
    }
}