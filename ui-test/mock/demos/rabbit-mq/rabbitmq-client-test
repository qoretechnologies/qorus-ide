#!/usr/bin/env qore

%new-style
%strict-args
%require-types
%enable-all-warnings

%requires QorusClientCore

%module-cmd(jni) add-classpath $OMQ_DIR/user/jar/rabbitmq/amqp-client-5.2.0.jar
%module-cmd(jni) add-classpath $OMQ_DIR/user/jar/rabbitmq/rabbitmq-client-bundle-1.3.0.jar
%module-cmd(jni) add-classpath $OMQ_DIR/user/jar/slf4j-simple-1.7.25.jar
%module-cmd(jni) add-classpath $OMQ_DIR/user/jar/slf4j-api-1.7.25.jar

%module-cmd(jni) import com.rabbitmq.client.ConnectionFactory
%module-cmd(jni) import com.rabbitmq.client.Connection
%module-cmd(jni) import com.rabbitmq.client.RecoverableChannel
%module-cmd(jni) import com.rabbitmq.client.DefaultConsumer

%requires jni

%requires Util

const QUEUE_NAME = "hello";

%exec-class RabbitMqClientTest

class RabbitMqClientTest {
    constructor() {
        our Counter cnt(1);
        background listener();

        Connection connection = getConnection();
        on_exit connection.close();
        RecoverableChannel channel = connection.createChannel();
        on_exit channel.close();
        channel.queueDeclare(QUEUE_NAME, False, False, False);
        string message = "Hello World!";

        string msgid = get_random_string();
        object props = create_object("AMQP$BasicProperties__Builder").
                                    messageId(msgid).
                                    build();
        channel.basicPublish("", QUEUE_NAME, props, getBytes(message));
        printf(" [x] Sent %y\n", message);
    }

    listener() {
        Connection connection = getConnection();
        on_exit connection.close();
        RecoverableChannel channel = connection.createChannel();
        on_exit channel.close();
        channel.queueDeclare(QUEUE_NAME, False, False, False);
        string tag = channel.basicConsume(QUEUE_NAME, True, implement_interface(new QoreInvocationHandler(\processMsg()), load_class("com/rabbitmq/client/Consumer")));
        on_exit channel.basicCancel(tag);
        # wait for message to be received
        cnt.waitForZero();
        printf("TID %d: exiting listener thread\n", gettid());
    }

    processMsg(Method method, *list<auto> args) {
        printf("called method: %y (%y) args: %y\n", method.toString(), method.getName(), args);
        if (method.getName() != "handleDelivery") {
            return;
        }

        handleDelivery(args[0], args[1], args[2], args[3]);
    }

    # Java arrays are serialized as Qore lists but without subtype information, so we can't use list<int> for byte[]
    # "env" here is an Envelope object, but from the classloader in the
    handleDelivery(string ctag, object env, object props, *list<auto> body) {
        on_exit {
            # signal listener thread that it can exit
            cnt.dec();
        }

        # deserialize body from Java byte[], Qore list<int>
        binary b;
        # byte order does not matter when deserializing single bytes
        map b += $1.encodeMsb(1), body;
        string msg = binary_to_string(b);

        # log msg info
        printf("got message: ctag: %y env: %y props: %y body: %y msg: %y\n", ctag, env.toString(), props.toString(), body, msg);
    }

    # returns a connection object using the connection info from the user connection object
    static Connection getConnection() {
        # all objects must be created in this Program object with the classloader used by this Program
        ConnectionFactory factory();
        object conn = get_user_connection("mq");
        conn.setFactory(factory);
        *string name = conn.connectionName();
        return name ? factory.newConnection(name) : factory.newConnection();
    }

    # serialize a string to a list of bytes
    static list<auto> getBytes(string msg) {
        binary b = binary(msg);
        return map b[$#], xrange(b.size() - 1);
    }
}
