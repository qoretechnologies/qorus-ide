# -*- mode: qore; indent-tabs-mode: nil -*-
# @file RabbitMQConnection.qm Rabbit MQ Connection Module

%requires qore >= 0.9.4
%requires Util

module RabbitMQConnection {
    version = "1.0";
    desc = "Rabbit MQ Connection Module";
    author = "Qore Technologies, s.r.o.";
    url = "http://qoretechnologies.com";
}

%requires QorusClientCore >= 3.1.1
%requires ConnectionProvider

%new-style
%require-types
%strict-args
%enable-all-warnings

%module-cmd(jni) add-classpath $OMQ_DIR/user/jar/rabbitmq/amqp-client-5.2.0.jar
%module-cmd(jni) add-classpath $OMQ_DIR/user/jar/rabbitmq/rabbitmq-client-bundle-1.3.0.jar
%module-cmd(jni) add-classpath $OMQ_DIR/user/jar/slf4j-simple-1.7.25.jar
%module-cmd(jni) add-classpath $OMQ_DIR/user/jar/slf4j-api-1.7.25.jar

%module-cmd(jni) import com.rabbitmq.client.ConnectionFactory
%module-cmd(jni) import com.rabbitmq.client.Connection
%module-cmd(jni) import com.rabbitmq.client.Channel
%module-cmd(jni) import com.rabbitmq.client.impl.recovery.AutorecoveringChannel
%module-cmd(jni) import com.rabbitmq.client.DefaultConsumer
%module-cmd(jni) import com.rabbitmq.client.Envelope
%module-cmd(jni) import com.rabbitmq.client.AMQP

public namespace RabbitMQConnection {
    #! this is the public function that returns a ConnectionScheme object to Qorus for the connection
    public AbstractIterator sub get_schemes() {
        softlist<auto> l = (
            new ConnectionScheme("rabbitmq", "RabbitMQConnection"),
        );

        return l.iterator();
    }

    public softlist sub required_resources() {
        return ("omqservice");
    }

    public sub set_resources(hash h) {
        # RabbitMQPrivate::omqservice = h.omqservice;
        # RabbitMQPrivate::set_socket_monitor = h.set_socket_monitor;
    }
}

public namespace RabbitMQPrivate {
    our object omqservice;
    our code set_socket_monitor;

    public class QoreRabbitMQConnectionFactory {
        constructor(hash<auto> h, *hash<auto> rtopts) {
            self.h = h + rtopts;
        }

        setFactory(object factory) {
            factory.setUri(h.real_url);
            # process options
            if (exists h.channel_rpc_timeout) {
                factory.setChannelRpcTimeout(h.channel_rpc_timeout);
            }
            if (exists h.connection_timeout) {
                factory.setConnectionTimeout(h.connection_timeout);
            }
            if (exists h.handshake_timeout) {
                factory.setHandshakeTimeout(h.handshake_timeout);
            }
            if (exists h.shutdown_timeout) {
                factory.setShutdownTimeout(h.shutdown_timeout);
            }
            if (exists h.heartbeat_timeout) {
                factory.setRequestedHeartbeat(h.heartbeat_timeout);
            }
            if (exists h.ssl) {
                if (h.ssl.typeCode() != NT_STRING) {
                    bool use_ssl = h.ssl.toBool();
                    if (use_ssl) {
                        factory.useSslProtocol();
                    }
                } else {
                    factory.useSslProtocol(h.ssl.toString());
                }
            }
            if (exists h.automatic_recovery) {
                factory.setAutomaticRecoveryEnabled(parse_boolean(h.automatic_recovery));
            }
            if (exists h.topology_recovery) {
                factory.setTopologyRecoveryEnabled(parse_boolean(h.topology_recovery));
            }
        }

        *string connectionName() {
            return h.connection_name;
        }

        # this method should normally not be used outside this module as the Connection object returned will be created with the connection module's classloader
        object getConnection(object factory) {
            setFactory(factory);
            return exists h.connection_name ? factory.newConnection(h.connection_name) : factory.newConnection();
        }

        private:internal {
            hash<auto> h;
        }
    }

    # this class does not need to be exported because only objects / instantiations will be exported
    #! RabbitMQ connection class
    /** RabbitMQ connections use the scheme \c "rabbitmq://" and support the following options:
        - \c "automatic_recovery": enables the automatic recovery of RabbitMQ connections
        - \c "channel_rpc_timeout": the the continuation timeout for RPC calls in channels in milliseconds; 0 means no timeout
        - \c "connection_name": a string label for the connection
        - \c "connection_timeout": the TCP connection timeout in milliseconds; 0 means no timeout
        - \c "handshake_timeout": the \c AMQP0-9-1 protocol handshake timeout in milliseconds
        - \c "heartbeat_timeout": the initially requested heartbeat timeout in seconds, zero for none; if this value is not less than apprioimately 1/2 the timeout value, it is ignored
        - \c "shutdown_timeout": Set the shutdown timeout as the amount of time in milliseconds that Consumer implementations have to
          continue working through deliveries (and other Consumer callbacks) after the connection has closed but before the
          ConsumerWorkService is torn down. If consumers exceed this timeout then any remaining queued deliveries (and other
          Consumer callbacks, including the Consumer's handleShutdownSignal() invocation) will be lost.
        - \c "ssl": a string enables the given TLS/SSL algorithm, @ref True or @ref False enables/disables ssl generally for the connection
        - \c "topology_recovery": enables the automatic recovery of RabbitMQ channels
    */
    public class RabbitMQConnection inherits AbstractConnection {
        public {
            #! the actual URL to use when making a connection
            string real_url;

            #! real options used when creating an object
            hash real_opts;

            #! rabbit MQ connection timeout
            const Options = {
                "automatic_recovery": True,
                "channel_rpc_timeout": True,
                "connection_name": True,
                "connection_timeout": True,
                "handshake_timeout": True,
                "heartbeat_timeout": True,
                "shutdown_timeout": True,
                "ssl": True,
                "topology_recovery": True,
            };

            #! RabbitMQConnection default options
            const DefaultOptions = {
                "automatic_recovery": True,
                "channel_rpc_timeout": 10m,
                "connection_timeout": 10m,
                "handshake_timeout": 10s,
                "shutdown_timeout": 10s,
                "topology_recovery": True,
            };
        }

        #! creates the AbstractConnection object
        /** @param name the name of the connection
            @param description connection description
            @param url connection URL (potentially with password info)
            @param attributes various attributes
            @param options connection options
         */
        constructor(string name, string description, string url, hash<auto> attributes = {}, hash<auto> options = {}) : AbstractConnection(name, description, url, attributes, options) {
            # sets an HTTP-based URL for the URL argument
            string scheme = (url =~ x/^([^:]+)/)[0];
            string targ = "amqp";
            real_url = regex_subst(url, "^" + scheme, targ);
        }

        #! returns \c "rabbitmq"
        string getType() {
            return "rabbitmq";
        }

        #! returns a @ref QoreRabbitMQConnectionFactory object
        /** @par Example:
            @code{.py}
# set up the class path
%module-cmd(jni) add-classpath $OMQ_DIR/user/jar/rabbitmq/amqp-client-5.2.0.jar
%module-cmd(jni) add-classpath $OMQ_DIR/user/jar/rabbitmq/rabbitmq-client-bundle-1.3.0.jar
%module-cmd(jni) add-classpath $OMQ_DIR/user/jar/slf4j-simple-1.7.25.jar
%module-cmd(jni) add-classpath $OMQ_DIR/user/jar/slf4j-api-1.7.25.jar

# import required classes / interfaces
%module-cmd(jni) import com.rabbitmq.client.ConnectionFactory
%module-cmd(jni) import com.rabbitmq.client.Connection
%module-cmd(jni) import com.rabbitmq.client.RecoverableChannel
%module-cmd(jni) import com.rabbitmq.client.DefaultConsumer

sub example() {
    # we have to create the ConnectionFactory object in the interface because the connection module
    # uses another class loader
    Connection conn = get_user_connection("mq").getConnection(new ConnectionFactory());

    # get a communication channel
    RecoverableChannel channel = conn.createChannel();
    on_exit channel.close();
    # ... use the channel
}
            @endcode

            @param connect this option is ignored; connections are always connected
            @param rtopts an optional hash allowing for all connection options to be overridden at runtime:
            - \c "automatic_recovery": enables the automatic recovery of RabbitMQ connections
            - \c "channel_rpc_timeout": the the continuation timeout for RPC calls in channels in milliseconds; 0 means no timeout
            - \c "connection_name": a string label for the connection
            - \c "connection_timeout": the TCP connection timeout in milliseconds; 0 means no timeout
            - \c "handshake_timeout": the \c AMQP0-9-1 protocol handshake timeout in milliseconds
            - \c "heartbeat_timeout": the initially requested heartbeat timeout in seconds, zero for none; if this value is not less than apprioimately 1/2 the timeout value, it is ignored
            - \c "shutdown_timeout": Set the shutdown timeout as the amount of time in milliseconds that Consumer implementations have to
            continue working through deliveries (and other Consumer callbacks) after the connection has closed but before the
            ConsumerWorkService is torn down. If consumers exceed this timeout then any remaining queued deliveries (and other
            Consumer callbacks, including the Consumer's handleShutdownSignal() invocation) will be lost.
            - \c "ssl": a string enables the given TLS/SSL algorithm, @ref True or @ref False enables/disables ssl generally for the connection
            - \c "topology_recovery": enables the automatic recovery of RabbitMQ channels

            @return an @ref QoreRabbitMQConnectionFactory object that can be used to configure a RabbitMQ \c ConnectionFactory object
            and RabbitMQ \c Connection objects
        */
        private QoreRabbitMQConnectionFactory getImpl(bool connect = True, *hash<auto> rtopts) {
            return new QoreRabbitMQConnectionFactory(hash(self) + rtopts);
        }

        #! gets options
        hash<auto> getOptions() {
            return Options;
        }

        #! returns default options
        /** @return default options as follows:
            - \c "automatic_recovery": @ref True
            - \c "channel_rpc_timeout": (@ref relative_dates "relative date/time value") 10 minutes
            - \c "connection_timeout": (@ref relative_dates "relative date/time value") 10 minutes
            - \c "handshake_timeout": (@ref relative_dates "relative date/time value") 10 seconds
            - \c "shutdown_timeout": (@ref relative_dates "relative date/time value") 10 seconds
            - \c "topology_recovery": @ref True
        */
        *hash<auto> getDefaultOptions() {
            return DefaultOptions;
        }

        #! returns runtime options
        /** @return a hash with the following keys reflecting support for overriding all connectionm options at runtime:
            - \c "automatic_recovery": enables the automatic recovery of RabbitMQ connections
            - \c "channel_rpc_timeout": the the continuation timeout for RPC calls in channels in milliseconds; 0 means no timeout
            - \c "connection_name": a string label for the connection
            - \c "connection_timeout": the TCP connection timeout in milliseconds; 0 means no timeout
            - \c "handshake_timeout": the \c AMQP0-9-1 protocol handshake timeout in milliseconds
            - \c "heartbeat_timeout": the initially requested heartbeat timeout in seconds, zero for none; if this value is not less than apprioimately 1/2 the timeout value, it is ignored
            - \c "shutdown_timeout": Set the shutdown timeout as the amount of time in milliseconds that Consumer implementations have to
            continue working through deliveries (and other Consumer callbacks) after the connection has closed but before the
            ConsumerWorkService is torn down. If consumers exceed this timeout then any remaining queued deliveries (and other
            Consumer callbacks, including the Consumer's handleShutdownSignal() invocation) will be lost.
            - \c "ssl": a string enables the given TLS/SSL algorithm, @ref True or @ref False enables/disables ssl generally for the connection
            - \c "topology_recovery": enables the automatic recovery of RabbitMQ channels
        */
        *hash<auto> getRuntimeOptions() {
            return Options;
        }

        #! performs the ping by executing get(); returns a @ref PingInfo hash
        private hash<PingInfo> pingIntern(hash<auto> rv) {
            date start = now_us();
            Connection conn = get().getConnection(new ConnectionFactory());
            on_exit conn.close();

            return cast<hash<PingInfo>>(rv + {
                "ok": True,
                "time": now_us() - start,
                "info": "OK",
            });
        }
    }
}
