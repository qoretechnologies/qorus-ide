{
  "class": [
    {
      "request_id": "6eIjSdPN44VMXNm",
      "tab_token": "none",
      "data": {
        "iface_kind": "class",
        "class": {
          "id": 117,
          "type": "class",
          "desc": "logs a message according to the config",
          "lang": "qore",
          "source": "%new-style\n%require-types\n%strict-args\n%enable-all-warnings\n\nclass LogMessageTest {\n    public {\n        const LogMessageLevelItem = \"test-log-message-level\";\n\n        const LogMessageLevelString = \"test-log-message-string\";\n\n        const LogMessageLevelArgs = \"test-log-message-args\";\n    }\n\n    #! Connector for executing the log action\n    /** @param input available in the \\a input key of local context data when looking up config item values\n\n        @return a hash with a \\a msg key holding the log message\n    */\n    hash<auto> logMessage(auto input) {\n        return logMessageIntern({\"input\": input});\n    }\n\n    #! Internal method for executing the log action\n    /** @param local_data local context data when looking up config item values\n\n        @return a hash with a \\a msg key holding the log message\n    */\n    private hash<auto> logMessageIntern(hash<auto> local_data) {\n        int lvl = LoggerLevel::getLevel(UserApi::getConfigItemValue(LogMessageLevelItem, local_data)).getValue();\n        string str = UserApi::getConfigItemValue(LogMessageLevelString, local_data);\n        auto args = UserApi::getConfigItemValue(LogMessageLevelArgs, local_data);\n        string msg = vsprintf(str, args);\n        UserApi::logWithLevelArgs(lvl, \"%s\", msg);\n        return {\"msg\": msg};\n    }\n}\n",
          "name": "LogMessageTest",
          "display_name": "Log Message Test",
          "short_desc": "logs a message according to the config",
          "version": "1.0",
          "author": ["Qore Technologies, s.r.o."],
          "class-connectors": [
            {
              "name": "logMessage",
              "type": "input-output",
              "method": "logMessage"
            }
          ],
          "config-items": [
            {
              "name": "test-log-message-level",
              "description": "The log level for the log message",
              "config_group": "Log Message Config",
              "type": "string",
              "default_value": "INFO",
              "allowed_values": [
                "ALL",
                "TRACE",
                "DEBUG",
                "INFO",
                "WARN",
                "ERROR",
                "FATAL"
              ],
              "strictly_local": true,
              "default_value_true_type": "string"
            },
            {
              "name": "test-log-message-string",
              "description": "The actual message to be logged",
              "config_group": "Log Message Config",
              "type": "string",
              "strictly_local": true
            },
            {
              "name": "test-log-message-args",
              "description": "Any argument(s) for the log message",
              "config_group": "Log Message Config",
              "type": "*string",
              "strictly_local": true
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got class 117"
    },
    {
      "request_id": "9EtXdidIFqtufTS",
      "tab_token": "none",
      "data": {
        "iface_kind": "class",
        "class": {
          "id": 134,
          "type": "class",
          "desc": "Java noop test step class",
          "lang": "java",
          "source": "package com.qoretechnologies.qorus.test.regression.java1;\n\nimport com.qoretechnologies.qorus.workflow.QorusNormalStep;\n\npublic class JavaNoopTestStep1 extends QorusNormalStep {\n    public void primary() throws Throwable {\n    }\n}\n",
          "name": "JavaNoopTestStep1",
          "display_name": "Java Noop Test Step1",
          "short_desc": "Java noop test step class",
          "version": "1.0",
          "author": ["Qore Technologies, s.r.o."]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got class 134"
    },
    {
      "request_id": "X2n4TvaPWoKyTH3",
      "tab_token": "none",
      "data": {
        "iface_kind": "class",
        "class": {
          "id": 97,
          "type": "class",
          "desc": "FSM retry test",
          "lang": "qore",
          "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass FsmRetryTest {\n    string retry() {\n        UserApi::logInfo(\"returning RETRY\");\n        return OMQ::StatRetry;\n    }\n}\n",
          "name": "FsmRetryTest",
          "display_name": "Fsm Retry Test",
          "short_desc": "FSM retry test",
          "version": "1.0",
          "author": ["Qore Technologies, s.r.o."],
          "class-connectors": [
            {
              "name": "retry",
              "method": "retry",
              "output-provider": {
                "can_manage_fields": false,
                "name": "qoretechnologies",
                "path": "/building-blocks/generic/string",
                "type": "type"
              },
              "type": "output"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got class 97"
    },
    {
      "request_id": "Zm6TlSXsyHRJrld",
      "tab_token": "none",
      "data": {
        "iface_kind": "class",
        "class": {
          "id": 438,
          "type": "class",
          "desc": "Sets Busylight settings according to the input and configuration",
          "lang": "qore",
          "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass HaltianToBusylight {\n    hash<auto> process(*hash<auto> input) {\n        string key = UserApi::getConfigItemValue(\"key\");\n        auto value = input.last_measurement{key};\n        if (!exists value) {\n            throw \"VALUE-ERROR\", sprintf(\"Could not find any measurement value in input:last_measurement.%s: %y\",\n                key, input);\n        }\n        list<auto> l = UserApi::getConfigItemValue(\"thresholds\");\n        UserApi::logInfo(\"got measurement: %y\", value);\n        foreach auto e in (l) {\n            auto start = e.start;\n            if (!exists start) {\n                UserApi::logError(\"Threshold entry %d/%d has no 'start' value: %y\", $# + 1, l.size(), e);\n                continue;\n            }\n            auto end = e.end;\n            if (!exists end) {\n                UserApi::logError(\"Threshold entry %d/%d has no 'end' value: %y\", $# + 1, l.size(), e);\n                continue;\n            }\n            if (value >= start && value < end) {\n                UserApi::logInfo(\"Value %y range [%d, %d]: MATCH: %y\", value, start, end, e);\n                return {\n                    \"red\": e.red ?? 0,\n                    \"green\": e.green ?? 0,\n                    \"blue\": e.blue ?? 0,\n                    \"on\": e.on ?? 255,\n                    \"off\": e.off ?? 0,\n                };\n            } else {\n                UserApi::logInfo(\"Value %y range [%y, %y]: NO MATCH\", value, start, end);\n            }\n        }\n        UserApi::logInfo(\"No match in %d threshold entr%s; returning default: turn off the Busylight\", l.size(),\n            l.size() == 1 ? \"y\" : \"ies\");\n        return {\n            \"red\": 0,\n            \"green\": 0,\n            \"blue\": 0,\n            \"on\": 0,\n            \"off\": 255,\n        };\n    }\n}\n",
          "name": "HaltianToBusylight",
          "display_name": "Haltian To Busylight",
          "short_desc": "Sets Busylight settings according to the input and configuration",
          "version": "1.0",
          "author": ["Qore Technologies, s.r.o."],
          "class-connectors": [
            {
              "name": "process",
              "type": "input-output",
              "method": "process",
              "input-provider": {
                "type": "type",
                "name": "qore",
                "can_manage_fields": true,
                "descriptions": ["Qore data type \"hash<auto>\""],
                "path": "/hash"
              },
              "output-provider": {
                "type": "type",
                "name": "haltian",
                "descriptions": ["Qore data type \"hash<auto>\""],
                "path": "/sensor/busylight-output"
              }
            }
          ],
          "config-items": [
            {
              "name": "thresholds",
              "description": "A list of thresholds and sensor ranges to be matched in order; the first entry that matches will be used.\n\nEach entry in the list must be a hash with the following keys:\n- `start`: the start of the range, the value must be >= to this value to match\n- `end`: the end of the range, the value must be < this value to match\n- [`red`]: the red value for the Busylight; must be between 0-255 inclusive\n- [`green`]: the green value for the Busylight; must be between 0-255 inclusive\n- [`blue`]: the blue value for the Busylight; must be between 0-255 inclusive\n- [`on`]: the on value for the Busylight; must be between 0-255 inclusive; if omitted will be assumed as `255`\n- [`off`]: the off value for the Busylight; must be between 0-255 inclusive' if omitted will be assumed as `0`\n\nExample entry:\n```\n- start: 15\n  end: 17\n  blue: 255\n- start: 17\n  end: 25\n  green: 255\n- start: 25\n  end: 35\n  red: 255\n- start: 35\n  end: 200\n  red: 255\n  on: 50\n  off: 50\n```\n\nThis would set the light to blue if the sensor value is between `15` and `17`, green if it's between `17` and `25`, red if it's between `25` and `35`, and flashing red if `35` or more.",
              "config_group": "Main",
              "type": "list",
              "strictly_local": true
            },
            {
              "name": "key",
              "description": "The name of the value key to check",
              "config_group": "Main",
              "type": "string",
              "default_value": "value",
              "strictly_local": true,
              "default_value_true_type": "string"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got class 438"
    },
    {
      "request_id": "MD9dknKFxlhFHL1",
      "tab_token": "none",
      "data": {
        "iface_kind": "class",
        "class": {
          "id": 519,
          "type": "class",
          "desc": "Convert Gingco bookings to EmpathicBuilding measurements",
          "lang": "qore",
          "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\n#! Converts Gingco bookings to EmpathicBuildiung measurements\nclass GingcoBookingsToEmpathicBuilding {\n    public {\n        const DefaultReportSubject = \"Gingco Buchung\";\n    }\n\n    #! Converts Gingco API bookings to EmpathicBuildiung measurements\n    static list<auto> convertApi(*list<auto> bookings) {\n        *date adjust;\n        if (*int add_hours = UserApi::getConfigItemValue(\"gingco-time-adjust\")) {\n            adjust = hours(add_hours);\n        }\n        hash<auto> rinfo;\n        foreach hash<auto> info in (bookings) {\n            date start = date(info.Datum + \" \" + info.Beginn, \"DD.MM.YYYY HH:mm\") + adjust;\n            if (!rinfo{info.object_id}) {\n                rinfo{info.object_id} = {\n                    \"type\": \"reservation\",\n                    \"time\": start,\n                    \"vendor_id\": info.object_id,\n                    \"name\": info.object_name,\n                    \"events\": (),\n                };\n            }\n            rinfo{info.object_id}.events += {\n                \"start\": info.begin + adjust,\n                \"end\": info.end + adjust,\n                \"subject\": info.topic,\n            };\n        }\n\n        #logDebug(\"RINFO: %N\", rinfo);\n        UserApi::logInfo(\"Gingco to EmpathicBuilding: %d booking%s processed (adjusted: %y)\", bookings.size(),\n            bookings.size() == 1 ? \"\" : \"s\", adjust);\n        return rinfo.values();\n    }\n\n    #! Converts Gingco report bookings to EmpathicBuildiung measurements\n    static list<auto> convertReport(*list<auto> bookings) {\n        *date adjust;\n        if (*int add_hours = UserApi::getConfigItemValue(\"gingco-time-adjust\")) {\n            adjust = hours(add_hours);\n        }\n        hash<auto> rinfo;\n        foreach hash<auto> info in (bookings) {\n            date start = date(info.Datum + \" \" + info.Beginn, \"DD.MM.YYYY HH:mm\") + adjust;\n            date end = date(info.Datum + \" \" + info.Ende, \"DD.MM.YYYY HH:mm\") + adjust;\n\n            if (!rinfo{info.\"Gebuchtes Objekt\"}) {\n                rinfo{info.\"Gebuchtes Objekt\"} = {\n                    \"type\": \"reservation\",\n                    \"time\": start,\n                    \"vendor_id\": info.Reservation_ID,\n                    \"name\": info.\"Gebuchtes Objekt\",\n                    \"events\": (),\n                };\n            }\n            rinfo{info.\"Gebuchtes Objekt\"}.events += {\n                \"start\": start,\n                \"end\": end,\n                \"subject\": DefaultReportSubject,\n                \"booking_ref\": UUID::get(),\n            };\n        }\n\n        UserApi::logInfo(\"Gingco to EmpathicBuilding: %d booking%s processed (adjusted: %y)\", bookings.size(),\n            bookings.size() == 1 ? \"\" : \"s\", adjust);\n\n        #UserApi::logDebug(\"RINFO: %N\", rinfo);\n\n        return rinfo.values();\n    }\n}\n",
          "name": "GingcoBookingsToEmpathicBuilding",
          "display_name": "Gingco Bookings To Empathic Building",
          "short_desc": "Convert Gingco bookings to EmpathicBuilding measurements",
          "version": "1.0",
          "author": ["Qore Technologies, s.r.o."],
          "class-connectors": [
            {
              "name": "convertApi",
              "type": "input",
              "method": "convertApi"
            },
            {
              "name": "convertReport",
              "type": "input",
              "method": "convertReport"
            }
          ],
          "config-items": [
            {
              "name": "gingco-time-adjust",
              "description": "The number of hours to add or subtract from the time before posting in Empathic Building",
              "config_group": "Main",
              "type": "*int",
              "strictly_local": true
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got class 519"
    },
    {
      "request_id": "Y4QRHoR6X74lpE0",
      "tab_token": "none",
      "data": {
        "iface_kind": "class",
        "class": {
          "id": 98,
          "type": "class",
          "desc": "Simple action class connector",
          "lang": "qore",
          "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass Issue3485Action {\n    auto action1(auto _data) {\n        UserApi::logInfo(\"Issue3485Action action1 was called: %y\", _data);\n        hash res = {\"d\": _data, \"action1\": True};\n        return res;\n    }\n\n    auto errorAction(auto _data) {\n        throw \"ERROR-ACTION\", \"action error\";\n    }\n}\n",
          "name": "Issue3485Action",
          "display_name": "Issue3485 Action",
          "short_desc": "Simple action class connector",
          "version": "1.0",
          "author": ["Qore Technologies, s.r.o."],
          "class-connectors": [
            {
              "name": "action1",
              "method": "action1",
              "type": "input-output"
            },
            {
              "name": "errorAction",
              "method": "errorAction",
              "type": "input"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got class 98"
    },
    {
      "request_id": "PQlc0rXijG5U1TA",
      "tab_token": "none",
      "data": {
        "iface_kind": "class",
        "class": {
          "id": 154,
          "type": "class",
          "desc": "Qore test step class",
          "lang": "qore",
          "source": "%new-style\n%require-types\n%strict-args\n%enable-all-warnings\n\nclass QoreDevModulesTestStep4 inherits TestNormalArrayStep, QoreTest {\n    softlist<auto> array() {\n        return (\"val1\", \"val2\");\n    }\n\n    primaryImpl(auto array_arg) {\n    }\n}\n",
          "name": "QoreDevModulesTestStep4",
          "display_name": "Qore Dev Modules Test Step4",
          "short_desc": "Qore test step class",
          "version": "1.0",
          "author": ["Qore Technologies, s.r.o."]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got class 154"
    },
    {
      "request_id": "f0ejaDD4VCjYAMU",
      "tab_token": "none",
      "data": {
        "iface_kind": "class",
        "class": {
          "id": 139,
          "type": "class",
          "desc": "Java test step class",
          "lang": "java",
          "source": "package com.qoretechnologies.qorus.test.regression.java1;\n\nimport com.qoretechnologies.qorus.OMQ;\nimport com.qoretechnologies.qorus.UserApi;\nimport com.qoretechnologies.qorus.workflow.WorkflowApi;\nimport com.qoretechnologies.qorus.workflow.QorusSubworkflowArrayStep;\n\nimport java.util.HashMap;\n\npublic class JavaSimpleTestStep5 extends QorusSubworkflowArrayStep {\n    public Object[] array() throws Throwable {\n        String[] myList = {\n            \"value-1\",\n        };\n\n        return myList;\n    }\n\n    public void primary(Object array_arg) throws Throwable {\n        logInfo(\"skipping subworkflow: array value: %y\", array_arg);\n        skipSubworkflow();\n    }\n}\n",
          "name": "JavaSimpleTestStep5",
          "display_name": "Java Simple Test Step5",
          "short_desc": "Java test step class",
          "version": "1.0",
          "author": ["Qore Technologies, s.r.o."]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got class 139"
    },
    {
      "request_id": "Ax9EdZ0LAyVsOlC",
      "tab_token": "none",
      "data": {
        "iface_kind": "class",
        "class": {
          "id": 105,
          "type": "class",
          "desc": "issue 3485 processor test",
          "lang": "qore",
          "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass Issue3485Processor4 inherits AbstractDataProcessor {\n    private {\n        list<hash<auto>> state;\n    }\n\n    private submitImpl(code enqueue, auto _data) {\n        if (_data.typeCode() != NT_HASH) {\n            throw \"DATA-ERROR\", sprintf(\"got type %y; expecting \\\"hash\\\"\", _data.type());\n        }\n        state += map $1, _data.contextIterator();\n\n        enqueue(_data);\n    }\n\n    private flushImpl(code enqueue) {\n        # write all state dat to job\n        JobApi::logInfo(\"saving state data to job: %N\", state);\n        JobApi::saveInfo(state);\n    }\n\n    private bool supportsBulkApiImpl() {\n        return True;\n    }\n}\n",
          "name": "Issue3485Processor4",
          "display_name": "Issue3485 Processor4",
          "short_desc": "issue 3485 processor test",
          "version": "1.0",
          "processor": {
            "processor-input-type": {
              "type": "type",
              "name": "qore",
              "can_manage_fields": true,
              "path": "/hash"
            },
            "processor-output-type": {
              "type": "type",
              "name": "qore",
              "can_manage_fields": true,
              "path": "/hash"
            }
          },
          "author": ["Qore Technologies, s.r.o."]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got class 105"
    },
    {
      "request_id": "sv8tNnCLavXpFb7",
      "tab_token": "none",
      "data": {
        "iface_kind": "class",
        "class": {
          "id": 153,
          "type": "class",
          "desc": "Qore test step class",
          "lang": "qore",
          "source": "%new-style\n%require-types\n%strict-args\n%enable-all-warnings\n\nclass QoreDevModulesTestStep3 inherits TestAsyncStep, QoreTest {\n    primaryImpl() {\n        assertTrue(True);\n        skipAsyncStep();\n    }\n}\n",
          "name": "QoreDevModulesTestStep3",
          "display_name": "Qore Dev Modules Test Step3",
          "short_desc": "Qore test step class",
          "version": "1.0",
          "author": ["Qore Technologies, s.r.o."]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got class 153"
    }
  ],
  "connection": [
    {
      "request_id": "M2e7aNyZqtHXpgM",
      "tab_token": "none",
      "data": {
        "iface_kind": "connection",
        "connection": {
          "id": 2,
          "type": "connection",
          "name": "qorus-api",
          "display_name": "Qorus Api",
          "short_desc": "qorus-api datasource",
          "desc": "qorus-api datasource",
          "url": "db://pgsql:qorusapi/qorusapi@qorusapi%hq:31432"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got connection 2"
    },
    {
      "request_id": "lXvqfeePXdDWJAx",
      "tab_token": "none",
      "data": {
        "iface_kind": "connection",
        "connection": {
          "id": 6,
          "type": "connection",
          "name": "omquser",
          "display_name": "Omquser",
          "short_desc": "omquser",
          "desc": "omquser",
          "url": "db://pgsql:omquser@omquser"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got connection 6"
    },
    {
      "request_id": "0e4prj08sl4fTmr",
      "tab_token": "none",
      "data": {
        "iface_kind": "connection",
        "connection": {
          "id": 0,
          "type": "connection",
          "name": "omq",
          "display_name": "Omq",
          "short_desc": "Qorus system database",
          "desc": "Qorus system database",
          "url": "db://pgsql:omq/omq@omq{min=3,max=40}",
          "options": {
            "min": {
              "type": "integer",
              "value": 3
            },
            "max": {
              "type": "integer",
              "value": 40
            }
          }
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got connection 0"
    },
    {
      "request_id": "YmsokoYPfKn76y3",
      "tab_token": "none",
      "data": {
        "iface_kind": "connection",
        "connection": {
          "id": 1141,
          "type": "connection",
          "name": "test-connection-ac1ff7e6-ad7c-49a1-8a45-c2ddbbc68b10",
          "display_name": "Test Connection Ac1ff7e6 Ad7c 49a1 8a45 C2ddbbc68b10",
          "short_desc": "q0Vk6P2XM7C04H3",
          "desc": "q0Vk6P2XM7C04H3",
          "url": "db://error:name/pass@db"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got connection 1141"
    },
    {
      "request_id": "dkdg8IVerCQKQz6",
      "tab_token": "none",
      "data": {
        "iface_kind": "connection",
        "connection": {
          "id": 1,
          "type": "connection",
          "name": "rest-billing-demo",
          "display_name": "Rest Billing Demo",
          "short_desc": "REST billing demo connection",
          "desc": "REST billing demo connection",
          "url": "rests://192.168.16.11:8011/billing-demo",
          "options": {
            "connect_timeout": {
              "type": "integer",
              "value": 45000
            },
            "error_passthru": {
              "type": "bool",
              "value": false
            },
            "http_version": {
              "type": "string",
              "value": "1.1"
            },
            "redirect_passthru": {
              "type": "bool",
              "value": false
            },
            "ssl_verify_cert": {
              "type": "bool",
              "value": false
            },
            "timeout": {
              "type": "integer",
              "value": 45000
            },
            "data": {
              "type": "string",
              "value": "auto"
            },
            "oauth2_auto_refresh": {
              "type": "bool",
              "value": true
            },
            "oauth2_pkce": {
              "type": "bool",
              "value": false
            },
            "oauth2_redirect_url": {
              "type": "string",
              "value": "auto"
            },
            "token_type": {
              "type": "string",
              "value": "Bearer"
            },
            "swagger": {
              "type": "string",
              "value": "resource://telco-billing-rest-api:billing-demo-1.0.yaml"
            }
          }
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got connection 1"
    },
    {
      "request_id": "7yNjnclqCRULRuF",
      "tab_token": "none",
      "data": {
        "iface_kind": "connection",
        "connection": {
          "id": 1034,
          "type": "connection",
          "name": "fs-regression-win",
          "display_name": "Fs Regression Win",
          "short_desc": "temp filesystem in windows",
          "desc": "temp filesystem in windows",
          "url": "file:///C:/temp",
          "options": {
            "readonly": {
              "type": "bool",
              "value": false
            }
          }
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got connection 1034"
    },
    {
      "request_id": "y5IjVrhMMms5aEl",
      "tab_token": "none",
      "data": {
        "iface_kind": "connection",
        "connection": {
          "id": 562,
          "type": "connection",
          "name": "gingco-dev",
          "display_name": "Gincgo Dev",
          "short_desc": "no description available",
          "desc": "no description available",
          "url": "gingco://preview-share-cloud.gingco.net/haltian/www/webservice/v2/index.php",
          "options": {
            "connect_timeout": {
              "type": "integer",
              "value": 45000
            },
            "error_passthru": {
              "type": "bool",
              "value": false
            },
            "http_version": {
              "type": "string",
              "value": "1.1"
            },
            "redirect_passthru": {
              "type": "bool",
              "value": false
            },
            "ssl_verify_cert": {
              "type": "bool",
              "value": false
            },
            "timeout": {
              "type": "integer",
              "value": 45000
            },
            "data": {
              "type": "string",
              "value": "json"
            },
            "oauth2_auto_refresh": {
              "type": "bool",
              "value": true
            },
            "oauth2_pkce": {
              "type": "bool",
              "value": false
            },
            "oauth2_redirect_url": {
              "type": "string",
              "value": "auto"
            },
            "token_type": {
              "type": "string",
              "value": "Bearer"
            },
            "username": {
              "type": "string",
              "value": "d.nichols"
            },
            "password": {
              "type": "string",
              "value": "8fhf69hz6"
            },
            "client_name": {
              "type": "string",
              "value": "haltian"
            },
            "client_password": {
              "type": "string",
              "value": "bp7er8eb9XW"
            }
          }
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got connection 562"
    },
    {
      "request_id": "hEDubumLDpnda7z",
      "tab_token": "none",
      "data": {
        "iface_kind": "connection",
        "connection": {
          "id": 981,
          "type": "connection",
          "name": "busylight-matthias",
          "display_name": "Busylight-Matthias",
          "short_desc": "Matthias' Busylight",
          "desc": "Connection to MQTT Kuando Busylight server",
          "url": "blssl://eu1.cloud.thethings.network",
          "options": {
            "clean_session": {
              "type": "bool",
              "value": true
            },
            "client_id": {
              "type": "string",
              "value": "QoreMqttClient"
            },
            "connect_timeout": {
              "type": "integer",
              "value": 30
            },
            "encoding": {
              "type": "string",
              "value": "UTF-8"
            },
            "keep_alive_interval": {
              "type": "integer",
              "value": 60
            },
            "max_in_flight": {
              "type": "integer",
              "value": 10
            },
            "message_format": {
              "type": "string",
              "value": "json"
            },
            "disable_automatic_pings": {
              "type": "bool",
              "value": true
            },
            "username": {
              "type": "string",
              "value": "1st-gdc-app@ttn"
            },
            "password": {
              "type": "string",
              "value": "NNSXS.L2F7BKG2744MM4B66VPZPTL2XLVJTPMNSSSNJRI.SNGQABBHGCWGDOOM7RW57DMGSSP72TIGH7IQA4ATDYGOSWOPOCQA"
            }
          }
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got connection 981"
    },
    {
      "request_id": "5cdcxPPItHQ9yTN",
      "tab_token": "none",
      "data": {
        "iface_kind": "connection",
        "connection": {
          "id": 667,
          "type": "connection",
          "name": "file-1",
          "display_name": "Gingco Report Folder",
          "short_desc": "Folder where Gingco report files will be stored for processing",
          "desc": "Connection to CSV Files server",
          "url": "file://$OMQ_DIR/user/gingco",
          "options": {
            "readonly": {
              "type": "bool",
              "value": false
            }
          }
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got connection 667"
    },
    {
      "request_id": "ALXcqh9cOodxFpx",
      "tab_token": "none",
      "data": {
        "iface_kind": "connection",
        "connection": {
          "id": 5,
          "type": "connection",
          "name": "fs-regression",
          "display_name": "Fs Regression",
          "short_desc": "shared filesystem in mseplftp directory",
          "desc": "shared filesystem in mseplftp directory",
          "url": "file:///tmp",
          "options": {
            "readonly": {
              "type": "bool",
              "value": false
            }
          }
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got connection 5"
    }
  ],
  "event": [
    {
      "request_id": "8S9rOKPAG0U9nzl",
      "tab_token": "none",
      "data": {
        "iface_kind": "event",
        "event": {
          "id": 6,
          "type": "event",
          "desc": "test event type for the REGRESSION-TEST workflow",
          "name": "regression-test",
          "display_name": "Regression Test",
          "short_desc": "test event type for the REGRESSION-TEST workflow"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got event 6"
    },
    {
      "request_id": "Z5qPzaKQZUV44Ws",
      "tab_token": "none",
      "data": {
        "iface_kind": "event",
        "event": {
          "id": 2,
          "type": "event",
          "desc": "Class workflow test event type",
          "name": "qore-class-event-test",
          "display_name": "Qore Class Event Test",
          "short_desc": "Class workflow test event type"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got event 2"
    },
    {
      "request_id": "YJnyHIxO8yOTUZr",
      "tab_token": "none",
      "data": {
        "iface_kind": "event",
        "event": {
          "id": 0,
          "type": "event",
          "desc": "default system event type",
          "name": "OMQ-SYSTEM-DEFAULT-EVENT-TYPE",
          "display_name": "OMQ SYSTEM DEFAULT EVENT TYPE",
          "short_desc": "default system event type"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got event 0"
    },
    {
      "request_id": "lZETepjK69R5kfW",
      "tab_token": "none",
      "data": {
        "iface_kind": "event",
        "event": {
          "id": 8,
          "type": "event",
          "desc": "Class workflow test event type",
          "name": "issue3102event",
          "display_name": "Issue3102event",
          "short_desc": "Class workflow test event type"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got event 8"
    },
    {
      "request_id": "BEKlDkggVNngr9L",
      "tab_token": "none",
      "data": {
        "iface_kind": "event",
        "event": {
          "id": 1,
          "type": "event",
          "desc": "issue #3490 test event",
          "name": "issue-3490",
          "display_name": "Issue 3490",
          "short_desc": "issue #3490 test event"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got event 1"
    },
    {
      "request_id": "JMGl1AvMtnxClNI",
      "tab_token": "none",
      "data": {
        "iface_kind": "event",
        "event": {
          "id": 3,
          "type": "event",
          "desc": "Java test event type",
          "name": "java-event-test",
          "display_name": "Java Event Test",
          "short_desc": "Java test event type"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got event 3"
    },
    {
      "request_id": "68Los8qSBKfDyjW",
      "tab_token": "none",
      "data": {
        "iface_kind": "event",
        "event": {
          "id": 4,
          "type": "event",
          "desc": "issue 2495 test event type",
          "name": "issue-2495",
          "display_name": "Issue 2495",
          "short_desc": "issue 2495 test event type"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got event 4"
    },
    {
      "request_id": "mFjHOgZUSeUq748",
      "tab_token": "none",
      "data": {
        "iface_kind": "event",
        "event": {
          "id": 7,
          "type": "event",
          "desc": "test event type for the EVENT-TEST workflow",
          "name": "event-test",
          "display_name": "Event Test",
          "short_desc": "test event type for the EVENT-TEST workflow"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got event 7"
    },
    {
      "request_id": "NjhEDKWixTr6G0J",
      "tab_token": "none",
      "data": {
        "iface_kind": "event",
        "event": {
          "id": 5,
          "type": "event",
          "desc": "test event type for the FEEDBACK-DETACH-CHILD workflow",
          "name": "feedback-detach-child",
          "display_name": "Feedback Detach Child",
          "short_desc": "test event type for the FEEDBACK-DETACH-CHILD workflow"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got event 5"
    }
  ],
  "errors": [
    {
      "request_id": "36uZKw000GhIYHu",
      "tab_token": "none",
      "data": {
        "iface_kind": "errors",
        "errors": {
          "id": 54,
          "type": "errors",
          "desc": "test",
          "name": "es-cvdOsRYxNLHXmCI",
          "display_name": "Es Cvd OsR YxNLH XmCI",
          "short_desc": "test",
          "errors_errors": [
            {
              "name": "TEST-ERROR-1",
              "desc": "err",
              "severity": "MAJOR",
              "status": "ERROR",
              "business": false,
              "level": "AUTO"
            },
            {
              "name": "TEST-ERROR-2",
              "desc": "err",
              "severity": "MAJOR",
              "status": "ERROR",
              "business": false,
              "level": "AUTO"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got errors 54"
    },
    {
      "request_id": "3BF690i8HC67zan",
      "tab_token": "none",
      "data": {
        "iface_kind": "errors",
        "errors": {
          "id": 55,
          "type": "errors",
          "desc": "test",
          "name": "es-Ig5xKfDU9t1dmcp",
          "display_name": "Es Ig5x KfDU9t1dmcp",
          "short_desc": "test",
          "errors_errors": [
            {
              "name": "TEST-ERROR-1",
              "desc": "err",
              "severity": "MAJOR",
              "status": "ERROR",
              "business": false,
              "level": "AUTO"
            },
            {
              "name": "TEST-ERROR-2",
              "desc": "err",
              "severity": "MAJOR",
              "status": "ERROR",
              "business": false,
              "level": "AUTO"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got errors 55"
    },
    {
      "request_id": "kZRTXaU9HqOLkR9",
      "tab_token": "none",
      "data": {
        "iface_kind": "errors",
        "errors": {
          "id": 56,
          "type": "errors",
          "desc": "test",
          "name": "es-bGtRzvWqf3Q3IQ6",
          "display_name": "Es B Gt Rzv Wqf3Q3IQ6",
          "short_desc": "test",
          "errors_errors": [
            {
              "name": "TEST-ERROR-1",
              "desc": "err",
              "severity": "MAJOR",
              "status": "ERROR",
              "business": false,
              "level": "AUTO"
            },
            {
              "name": "TEST-ERROR-2",
              "desc": "err",
              "severity": "MAJOR",
              "status": "ERROR",
              "business": false,
              "level": "AUTO"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got errors 56"
    },
    {
      "request_id": "uh5UblsP4OTyu0k",
      "tab_token": "none",
      "data": {
        "iface_kind": "errors",
        "errors": {
          "id": 57,
          "type": "errors",
          "desc": "test",
          "name": "es-iJQEZhltLOQgupO",
          "display_name": "Es IJQE ZhltLO QgupO",
          "short_desc": "test",
          "errors_errors": [
            {
              "name": "TEST-ERROR-1",
              "desc": "err",
              "severity": "MAJOR",
              "status": "ERROR",
              "business": false,
              "level": "AUTO"
            },
            {
              "name": "TEST-ERROR-2",
              "desc": "err",
              "severity": "MAJOR",
              "status": "ERROR",
              "business": false,
              "level": "AUTO"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got errors 57"
    },
    {
      "request_id": "slo1cORfPUunvXN",
      "tab_token": "none",
      "data": {
        "iface_kind": "errors",
        "errors": {
          "id": 58,
          "type": "errors",
          "desc": "test",
          "name": "es-uu8r8XR8RKE5To4",
          "display_name": "Es Uu8r8XR8RKE5 To4",
          "short_desc": "test",
          "errors_errors": [
            {
              "name": "TEST-ERROR-1",
              "desc": "err",
              "severity": "MAJOR",
              "status": "ERROR",
              "business": false,
              "level": "AUTO"
            },
            {
              "name": "TEST-ERROR-2",
              "desc": "err",
              "severity": "MAJOR",
              "status": "ERROR",
              "business": false,
              "level": "AUTO"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got errors 58"
    },
    {
      "request_id": "R62VbHcCzrw8km5",
      "tab_token": "none",
      "data": {
        "iface_kind": "errors",
        "errors": {
          "id": 59,
          "type": "errors",
          "desc": "test",
          "name": "es-fbg8JykqD595F8I",
          "display_name": "Es Fbg8 JykqD595F8I",
          "short_desc": "test",
          "errors_errors": [
            {
              "name": "TEST-ERROR-1",
              "desc": "err",
              "severity": "MAJOR",
              "status": "ERROR",
              "business": false,
              "level": "AUTO"
            },
            {
              "name": "TEST-ERROR-2",
              "desc": "err",
              "severity": "MAJOR",
              "status": "ERROR",
              "business": false,
              "level": "AUTO"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got errors 59"
    },
    {
      "request_id": "BqadidpjWSFlbW4",
      "tab_token": "none",
      "data": {
        "iface_kind": "errors",
        "errors": {
          "id": 60,
          "type": "errors",
          "desc": "test",
          "name": "es-GgoOQpLoA58QpHl",
          "display_name": "Es GgoO Qp LoA58 Qp Hl",
          "short_desc": "test",
          "errors_errors": [
            {
              "name": "TEST-ERROR-1",
              "desc": "err",
              "severity": "MAJOR",
              "status": "ERROR",
              "business": false,
              "level": "AUTO"
            },
            {
              "name": "TEST-ERROR-2",
              "desc": "err",
              "severity": "MAJOR",
              "status": "ERROR",
              "business": false,
              "level": "AUTO"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got errors 60"
    },
    {
      "request_id": "nEzUrpweNghOiho",
      "tab_token": "none",
      "data": {
        "iface_kind": "errors",
        "errors": {
          "id": 61,
          "type": "errors",
          "desc": "test",
          "name": "es-mid9FM7iYmpABfO",
          "display_name": "Es Mid9FM7i YmpA BfO",
          "short_desc": "test",
          "errors_errors": [
            {
              "name": "TEST-ERROR-1",
              "desc": "err",
              "severity": "MAJOR",
              "status": "ERROR",
              "business": false,
              "level": "AUTO"
            },
            {
              "name": "TEST-ERROR-2",
              "desc": "err",
              "severity": "MAJOR",
              "status": "ERROR",
              "business": false,
              "level": "AUTO"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got errors 61"
    },
    {
      "request_id": "Gbg2CKyz0uTfNI8",
      "tab_token": "none",
      "data": {
        "iface_kind": "errors",
        "errors": {
          "id": 62,
          "type": "errors",
          "desc": "test",
          "name": "es-4RkCkBaawUVwvfI",
          "display_name": "Es 4 Rk Ck BaawU VwvfI",
          "short_desc": "test",
          "errors_errors": [
            {
              "name": "TEST-ERROR-1",
              "desc": "err",
              "severity": "MAJOR",
              "status": "ERROR",
              "business": false,
              "level": "AUTO"
            },
            {
              "name": "TEST-ERROR-2",
              "desc": "err",
              "severity": "MAJOR",
              "status": "ERROR",
              "business": false,
              "level": "AUTO"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got errors 62"
    },
    {
      "request_id": "TaUxOEMEKUuZaTQ",
      "tab_token": "none",
      "data": {
        "iface_kind": "errors",
        "errors": {
          "id": 63,
          "type": "errors",
          "desc": "test",
          "name": "es-d5LSlv58grknvXk",
          "display_name": "Es D5L Slv58grknv Xk",
          "short_desc": "test",
          "errors_errors": [
            {
              "name": "TEST-ERROR-1",
              "desc": "err",
              "severity": "MAJOR",
              "status": "ERROR",
              "business": false,
              "level": "AUTO"
            },
            {
              "name": "TEST-ERROR-2",
              "desc": "err",
              "severity": "MAJOR",
              "status": "ERROR",
              "business": false,
              "level": "AUTO"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got errors 63"
    }
  ],
  "group": [
    {
      "request_id": "EI661iQd2EJF6t7",
      "tab_token": "none",
      "data": {
        "iface_kind": "group",
        "group": {
          "id": 0,
          "type": "group",
          "name": "DEFAULT",
          "display_name": "Default Group",
          "short_desc": "default group containing all workflows and services",
          "desc": "default group containing all workflows and services"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got group 0"
    },
    {
      "request_id": "auqKgv8iFudVlR3",
      "tab_token": "none",
      "data": {
        "iface_kind": "group",
        "group": {
          "id": 613,
          "type": "group",
          "name": "creator-test-group1-a68744da-15d3-4858-98a0-12d9ec85a5be",
          "display_name": "Creator Test Group1 A68744da 15d3 4858 98a0 12d9ec85a5be",
          "short_desc": "creator test group",
          "desc": "creator test group"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got group 613"
    },
    {
      "request_id": "uV3F7qb9o9Hv6kQ",
      "tab_token": "none",
      "data": {
        "iface_kind": "group",
        "group": {
          "id": 615,
          "type": "group",
          "name": "creator-test-group1-f25c8150-dc78-4123-8634-52aad11b37cf",
          "display_name": "Creator Test Group1 F25c8150 Dc78 4123 8634 52aad11b37cf",
          "short_desc": "creator test group",
          "desc": "creator test group"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got group 615"
    },
    {
      "request_id": "VF69AdXc29HMitI",
      "tab_token": "none",
      "data": {
        "iface_kind": "group",
        "group": {
          "id": 264,
          "type": "group",
          "name": "creator-test-group1-18ca8e9d-a275-4d0f-9197-0fb7e5180993",
          "display_name": "Creator Test Group1 18ca8e9d A275 4d0f 9197 0fb7e5180993",
          "short_desc": "creator test group",
          "desc": "creator test group"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got group 264"
    },
    {
      "request_id": "MbTdQ9uE4RD7OK1",
      "tab_token": "none",
      "data": {
        "iface_kind": "group",
        "group": {
          "id": 265,
          "type": "group",
          "name": "creator-test-group1-706de6e4-45d5-489d-ad77-385507892e86",
          "display_name": "Creator Test Group1 706de6e4 45d5 489d Ad77 385507892e86",
          "short_desc": "creator test group",
          "desc": "creator test group"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got group 265"
    },
    {
      "request_id": "g9EdKLLiP06k7dL",
      "tab_token": "none",
      "data": {
        "iface_kind": "group",
        "group": {
          "id": 388,
          "type": "group",
          "name": "issue-3485-X7SbEgC3ozijTe7",
          "display_name": "Issue 3485 X7 Sb EgC3ozij Te7",
          "short_desc": "test empty group",
          "desc": "test empty group"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got group 388"
    },
    {
      "request_id": "vOc1OLi8tXXeg4n",
      "tab_token": "none",
      "data": {
        "iface_kind": "group",
        "group": {
          "id": 335,
          "type": "group",
          "name": "creator-test-group1-5331b024-ae50-47c2-a344-ced691ae5cb8",
          "display_name": "Creator Test Group1 5331b024 Ae50 47c2 A344 Ced691ae5cb8",
          "short_desc": "creator test group",
          "desc": "creator test group"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got group 335"
    },
    {
      "request_id": "y7FgAod67bse2U0",
      "tab_token": "none",
      "data": {
        "iface_kind": "group",
        "group": {
          "id": 341,
          "type": "group",
          "name": "creator-test-group1-d4990d22-4528-4b71-8b3a-a4ae5fd0c513",
          "display_name": "Creator Test Group1 D4990d22 4528 4b71 8b3a A4ae5fd0c513",
          "short_desc": "creator test group",
          "desc": "creator test group"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got group 341"
    },
    {
      "request_id": "bjSc4ybla8itYjo",
      "tab_token": "none",
      "data": {
        "iface_kind": "group",
        "group": {
          "id": 342,
          "type": "group",
          "name": "creator-test-group1-43b4015b-b013-4aee-8625-09a474f82911",
          "display_name": "Creator Test Group1 43b4015b B013 4aee 8625 09a474f82911",
          "short_desc": "creator test group",
          "desc": "creator test group"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got group 342"
    },
    {
      "request_id": "i27a5W0s2MoQoVw",
      "tab_token": "none",
      "data": {
        "iface_kind": "group",
        "group": {
          "id": 343,
          "type": "group",
          "name": "creator-test-group1-859e4d91-5f5d-4052-bb82-29d740be15ac",
          "display_name": "Creator Test Group1 859e4d91 5f5d 4052 Bb82 29d740be15ac",
          "short_desc": "creator test group",
          "desc": "creator test group"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got group 343"
    }
  ],
  "job": [
    {
      "request_id": "KdUp7VIdW60VXZv",
      "tab_token": "none",
      "data": {
        "iface_kind": "job",
        "job": {
          "id": 11,
          "type": "job",
          "desc": "Java pipeline test job",
          "lang": "java",
          "source": "import com.qoretechnologies.qorus.*;\nimport com.qoretechnologies.qorus.job.*;\n\n@SuppressWarnings(\"deprecation\")\nclass Issue3485JavaTest extends QorusJob {\n    public void run() throws Throwable {\n    }\n}\n",
          "base-class-name": "QorusJob",
          "class-name": "Issue3485JavaTest",
          "schedule": "0 0 1 1 *",
          "name": "issue-3485-java-test",
          "display_name": "Issue 3485 Java Test",
          "short_desc": "Java pipeline test job",
          "version": "1.0",
          "active": false,
          "remote": true,
          "author": ["Qore Technologies, s.r.o."],
          "fsm": [
            {
              "name": "java-test-fsm",
              "triggers": [
                {
                  "method": "run"
                }
              ]
            }
          ]
        },
        "supports_enable": true,
        "supports_active": true,
        "active": false,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got job 11"
    },
    {
      "request_id": "Eo59wRdIOOHnOuA",
      "tab_token": "none",
      "data": {
        "iface_kind": "job",
        "job": {
          "id": 24,
          "type": "job",
          "desc": "test issue 3810",
          "lang": "qore",
          "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass Issue3810 inherits QorusJob {\n    run() {\n    }\n}\n",
          "base-class-name": "QorusJob",
          "class-name": "Issue3810",
          "schedule": "0 0 1 1 *",
          "name": "issue-3810",
          "display_name": "Issue 3810",
          "short_desc": "test issue 3810",
          "version": "1.0",
          "active": false,
          "remote": false,
          "author": ["Qore Technologies, s.r.o."],
          "fsm": [
            {
              "name": "issue-3810",
              "triggers": [
                {
                  "method": "run"
                }
              ]
            }
          ]
        },
        "supports_enable": true,
        "supports_active": true,
        "active": false,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got job 24"
    },
    {
      "request_id": "cgYIKtDqXKHZSfN",
      "tab_token": "none",
      "data": {
        "iface_kind": "job",
        "job": {
          "id": 74,
          "type": "job",
          "desc": "example job with configuration items",
          "lang": "qore",
          "source": "\n%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass Issue3166JobNeg2 inherits QorusJob {\n    run() {\n    }\n\n    private *hash<string, hash<ConfigItemInfo>> getConfigItemsImpl() {\n        return {\n            \"issue-3166-job-config-1\": <ConfigItemInfo>{\n                \"type\": \"bool\",\n                \"description\": \"This is an example configuration item of type bool\",\n                \"strictly_local\": True,\n                \"allowed_values\": (True,)\n            },\n        };\n    }\n}\n",
          "base-class-name": "QorusJob",
          "class-name": "Issue3166JobNeg2",
          "schedule": "* * * * *",
          "name": "issue-3166neg2-job",
          "display_name": "Issue 3166neg2 Job",
          "short_desc": "example job with configuration items",
          "version": "1.0",
          "active": true,
          "remote": true,
          "groups": ["test", "regression"],
          "author": ["Qore Technologies, s.r.o."]
        },
        "supports_enable": true,
        "supports_active": true,
        "active": true,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got job 74"
    },
    {
      "request_id": "ES26Kyz9zarNj2G",
      "tab_token": "none",
      "data": {
        "iface_kind": "job",
        "job": {
          "id": 1230,
          "type": "job",
          "desc": "Job for scheduled FSM \"Fsm Actions 3\"",
          "lang": "qore",
          "source": "class FsmJob inherits QorusJob {run() {}}",
          "base-class-name": "QorusJob",
          "class-name": "FsmJob",
          "schedule": "* * * * *",
          "name": "fsm-actions-3",
          "version": "1.0",
          "active": true,
          "remote": false,
          "fsm": [
            {
              "name": "fsm-actions-3",
              "triggers": []
            }
          ]
        },
        "supports_enable": true,
        "supports_active": true,
        "active": true,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got job 1230"
    },
    {
      "request_id": "cdQgwA56QlImjVb",
      "tab_token": "none",
      "data": {
        "iface_kind": "job",
        "job": {
          "id": 4,
          "type": "job",
          "desc": "Create workflow orders for the telco-om demo",
          "lang": "qore",
          "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass TelcoOmDemo inherits QorusJob {\n    public {\n        hash<string, int> info;\n\n        const MasterWfs = (\n            \"TELCO-SUSPEND-CUSTOMER\",\n            \"TELCO-RESUME-CUSTOMER\",\n            \"TELCO-RETIRE-CUSTOMER\",\n            \"TELCO-CHANGE-MSISDN\",\n            \"TELCO-SIM-SWAP\",\n            \"TELCO-CHANGE-TARIFF-ACCOUNT\",\n            \"TELCO-MNP-PORT-IN\",\n            \"TELCO-MNP-PORT-OUT\",\n            \"TELCO-MNP-PORT-ACROSS\",\n            \"TELCO-PREACTIVATION\",\n            \"TELCO-UPDATE-ACCOUNT\",\n        );\n    }\n\n    run() {\n        int wfiid = omqservice.user.\"telco-billing-rest-api\".activateCustomer();\n        info{\"TELCO-ACTIVATE-CUSTOMER\"} = wfiid;\n        logInfo(\"workflow %y: created workflow_instanceid %d\", \"TELCO-ACTIVATE-CUSTOMER\", wfiid);\n        map doOrder($1, {\"staticdata\": {}}), MasterWfs;\n        saveInfo(info);\n    }\n\n    private doOrder(string name, hash<auto> params) {\n        int wfiid = UserApi::createOrder(name, NOTHING, params);\n        logInfo(\"workflow %y: created workflow_instanceid %d\", name, wfiid);\n        info{name} = wfiid;\n    }\n}\n",
          "base-class-name": "QorusJob",
          "class-name": "TelcoOmDemo",
          "schedule": "*/5 * * * *",
          "name": "telco-om-demo",
          "display_name": "Telco Om Demo",
          "short_desc": "Create workflow orders for the telco-om demo",
          "version": "1.0",
          "active": true,
          "remote": false,
          "groups": ["demo", "demo-telco-om"],
          "author": ["Qore Technologies, s.r.o."]
        },
        "supports_enable": true,
        "supports_active": true,
        "active": true,
        "enabled": false
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got job 4"
    },
    {
      "request_id": "DzjEpTgYMR4GrnR",
      "tab_token": "none",
      "data": {
        "iface_kind": "job",
        "job": {
          "id": 3,
          "type": "job",
          "desc": "deletes sensitive data older than a certain date",
          "lang": "qore",
          "source": "# -*- mode: qore; indent-tabs-mode: nil -*-\n\n%new-style\n%require-types\n%strict-args\n%enable-all-warnings\n\n#! Qorus sensitive data job\nclass QorusSensitiveData inherits QorusJob {\n    public {\n        const Defaults = (\n            \"sensitive-data-cutoff-months\": 6,\n            \"sensitive-data-purge-complete\": True,\n            \"sensitive-data-purge-canceled\": True,\n        );\n    }\n\n    run() {\n        int months = getConfigItemValue(\"cutoff-months\");\n        list<string> statuses = ();\n        if (getConfigItemValue(\"purge-complete\")) {\n            statuses += OMQ::StatComplete;\n        }\n        if (getConfigItemValue(\"purge-canceled\")) {\n            statuses += OMQ::StatCanceled;\n        }\n        date cutoff = now_us() - Qore::months(months);\n        logInfo(\"purging sensitive data older than %y with statuses: %y\", cutoff, statuses);\n        if (!statuses) {\n            logInfo(\"there are no statuses set; set properties for either %y or %y to enable sensitive data purging with this job\",\n                \"purge-complete\", \"purge-canceled\");\n            return;\n        }\n\n        *list<auto> l = map $1.(\"name\", \"version\", \"workflowid\", \"workflow_instanceid\", \"workflowstatus\", \"skey\"),\n            callRestApi(\"DELETE\", \"orders?action=purgeSensitiveData\", (\"maxmodified\": cutoff, \"status\": statuses));\n\n        # log and save information about data purged\n        map logInfo(\"purged sensitive data: %y\", $1), l;\n        JobApi::saveInfo((\"orders_purged\": l));\n    }\n\n    # returns config items for this job\n    private *hash<string, hash<ConfigItemInfo>> getConfigItemsImpl() {\n        return {\n            \"cutoff-months\": <ConfigItemInfo>{\n                \"type\": \"int\",\n                \"default_value\": 6,\n                \"description\": \"age in number of months after which sensitive data is purged\",\n                \"config_group\": \"Sensitive Data Purging\",\n                \"strictly_local\": True,\n            },\n            \"purge-complete\": <ConfigItemInfo>{\n                \"type\": \"bool\",\n                \"default_value\": True,\n                \"description\": \"set to true to purge COMPLETE sensitive workflow order data\",\n                \"config_group\": \"Sensitive Data Purging\",\n                \"strictly_local\": True,\n            },\n            \"purge-canceled\": <ConfigItemInfo>{\n                \"type\": \"bool\",\n                \"default_value\": True,\n                \"description\": \"set to true to purge CANCELED sensitive workflow order data\",\n                \"config_group\": \"Sensitive Data Purging\",\n                \"strictly_local\": True,\n            },\n        };\n    }\n}\n",
          "base-class-name": "QorusJob",
          "class-name": "QorusSensitiveData",
          "schedule": "0 */3 * * *",
          "name": "qorus-sensitive-data",
          "display_name": "Qorus Sensitive Data",
          "short_desc": "deletes sensitive data older than a certain date",
          "version": "6.1",
          "active": false,
          "remote": true,
          "groups": ["qorus-admin"],
          "author": ["Qore Technologies, s.r.o."]
        },
        "supports_enable": true,
        "supports_active": true,
        "active": false,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got job 3"
    },
    {
      "request_id": "blTY56VKoMdwMmS",
      "tab_token": "none",
      "data": {
        "iface_kind": "job",
        "job": {
          "id": 881,
          "type": "job",
          "desc": "Test for the `trunc` attribute in mappers with DB output columns",
          "lang": "qore",
          "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass Issue4046 inherits QorusJob {\n    run() {\n        Mapper m = getMapper(\"issue-4046\");\n        m.mapData({\n            \"num\": 100,\n            \"string\": \"this is a very long string, loger than the column can take\",\n        });\n    }\n}\n",
          "base-class-name": "QorusJob",
          "class-name": "Issue4046",
          "schedule": "0 0 * * *",
          "name": "issue-4046",
          "display_name": "Issue 4046",
          "short_desc": "Test for the 'trunc' attribute in mappers with DB output columns",
          "version": "1.0",
          "active": false,
          "remote": true,
          "groups": ["regression", "test"],
          "author": ["Qore Technologies, s.r.o."],
          "mappers": ["issue-4046"]
        },
        "supports_enable": true,
        "supports_active": true,
        "active": false,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got job 881"
    },
    {
      "request_id": "jSsIgZ7SUNIO4Va",
      "tab_token": "none",
      "data": {
        "iface_kind": "job",
        "job": {
          "id": 75,
          "type": "job",
          "desc": "example job with configuration items",
          "lang": "qore",
          "source": "\n%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass Issue3166JobNeg4 inherits QorusJob {\n    run() {\n    }\n\n    private *hash<string, hash<ConfigItemInfo>> getConfigItemsImpl() {\n        return {\n            \"issue-3166-job-config-1\": <ConfigItemInfo>{\n                \"type\": \"int\",\n                \"default_value\": 123,\n                \"description\": \"This is an example configuration item of type int\",\n                \"strictly_local\": True,\n                \"allowed_values\": (123, 23, 123, 4, 1)\n            },\n        };\n    }\n}\n",
          "base-class-name": "QorusJob",
          "class-name": "Issue3166JobNeg4",
          "schedule": "* * * * *",
          "name": "issue-3166neg4-job",
          "display_name": "Issue 3166neg4 Job",
          "short_desc": "example job with configuration items",
          "version": "1.0",
          "active": true,
          "remote": true,
          "groups": ["test", "regression"],
          "author": ["Qore Technologies, s.r.o."]
        },
        "supports_enable": true,
        "supports_active": true,
        "active": true,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got job 75"
    },
    {
      "request_id": "4dWEDGWg1aTdFbr",
      "tab_token": "none",
      "data": {
        "iface_kind": "job",
        "job": {
          "id": 17,
          "type": "job",
          "desc": "issue 3537 test",
          "lang": "qore",
          "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass Issue3537Test inherits QorusJob {\n    run() {\n        int num = rand() % 1000;\n        hash<Issue3537> h = omqservice.user.\"issue-3537-test\".get(num);\n        if (h.\"code\" != num) {\n            throw \"ERROR\", sprintf(\"expected %y; got %y\", num, h.\"code\");\n        }\n        logInfo(\"code %y received correctly (%s)\", h.\"code\", h.fullType());\n    }\n}\n",
          "base-class-name": "QorusJob",
          "class-name": "Issue3537Test",
          "schedule": "0 0 1 1 *",
          "name": "issue-3537-test",
          "display_name": "Issue 3537 Test",
          "short_desc": "issue 3537 test",
          "version": "1.0",
          "active": false,
          "remote": true,
          "author": ["Qore Technologies, s.r.o."],
          "classes": [
            {
              "id": 1,
              "name": "Issue3537Shared"
            }
          ]
        },
        "supports_enable": true,
        "supports_active": true,
        "active": false,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got job 17"
    },
    {
      "request_id": "DpivAqUQgNgTBAw",
      "tab_token": "none",
      "data": {
        "iface_kind": "job",
        "job": {
          "id": 19,
          "type": "job",
          "desc": "test",
          "lang": "qore",
          "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass Issue3563Pipeline inherits QorusJob {\n    run() {\n    }\n}\n",
          "base-class-name": "QorusJob",
          "class-name": "Issue3563Pipeline",
          "schedule": "0 * * * *",
          "name": "issue-3563-pipeline",
          "display_name": "Issue 3563 Pipeline",
          "short_desc": "test",
          "version": "1.0",
          "active": false,
          "remote": true,
          "fsm": [
            {
              "name": "issue-3563-pipeline-fsm",
              "triggers": [
                {
                  "method": "run"
                }
              ]
            }
          ]
        },
        "supports_enable": true,
        "supports_active": true,
        "active": false,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got job 19"
    }
  ],
  "mapper": [
    {
      "request_id": "8P0PetQbmdT0oN1",
      "tab_token": "none",
      "data": {
        "iface_kind": "mapper",
        "mapper": {
          "id": 1,
          "type": "mapper",
          "mappertype": "Mapper",
          "desc": "telco billing account mapper",
          "fields": {
            "body.BillCycle": {
              "context": "$static:{bill-cycle}"
            },
            "body.Name": {
              "code": "TelcoCreateBillingAccount::getName"
            },
            "body.PaymentInfo.Address": {
              "context": "$sensitive-alias:{payment-1.value.billing-address}"
            },
            "body.PaymentInfo.CVV2": {
              "context": "$sensitive-alias:{payment-1.value.CVV2}"
            },
            "body.PaymentInfo.Expiration": {
              "context": "$sensitive-alias:{payment-1.value.card-expiration-date}"
            },
            "body.PaymentInfo.Id": {
              "context": "$sensitive-alias:{payment-1.svalue}"
            },
            "body.PaymentInfo.Name": {
              "context": "$sensitive-alias:{payment-1.value.name}"
            },
            "body.PaymentInfo.Type": {
              "context": "$sensitive-alias:{payment-1.value.type}"
            },
            "body.RequestId": {
              "context": "$local:workflow_instanceid"
            },
            "body.TaxId": {
              "context": "$sensitive-alias:{party-1.svalue}"
            },
            "body.Type": {
              "context": "$static:type"
            }
          },
          "name": "telco-create-billing-account",
          "display_name": "Telco Create Billing Account",
          "short_desc": "telco billing account mapper",
          "version": "1.0",
          "mapper_options": {
            "mapper-input": {
              "type": "type",
              "name": "qore",
              "path": "/hash",
              "custom-fields": {}
            },
            "mapper-output": {
              "type": "connection",
              "name": "rest-billing-demo",
              "path": "/accounts/POST/",
              "subtype": "request",
              "custom-fields": {}
            },
            "output_provider_passive": true
          }
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got mapper 1"
    },
    {
      "request_id": "zeIwPaouWRozPNc",
      "tab_token": "none",
      "data": {
        "iface_kind": "mapper",
        "mapper": {
          "id": 2,
          "type": "mapper",
          "mappertype": "Mapper",
          "desc": "mapper code test",
          "fields": {
            "output-1": {
              "code": "issue3364mappercode::getMapperField"
            },
            "output-2": {
              "name": "input-1",
              "code": "issue3364mappercode::getMapperField"
            },
            "output-3": {
              "name": "input-2"
            },
            "output-4": "input-1",
            "output-5": {
              "constant": 123
            },
            "output-6": "input-1",
            "output-7": "input-3"
          },
          "name": "issue3364mapper",
          "display_name": "Issue3364mapper",
          "short_desc": "mapper code test",
          "version": "1.0",
          "author": ["Qore Technologies, s.r.o."],
          "mapper_options": {
            "mapper-input": {
              "input-1": {
                "desc": "input 1"
              },
              "input-2": "input 2",
              "input-3": "input 3"
            },
            "mapper-output": {
              "output-1": "output 1",
              "output-2": "output 2",
              "output-3": "output 3",
              "output-4": {
                "desc": "output 4",
                "maxlen": 43,
                "type": "string",
                "mand": true
              },
              "output-5": {
                "desc": "output 5"
              },
              "output-6": {
                "desc": "output 6"
              },
              "output-7": "output 7"
            }
          }
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got mapper 2"
    },
    {
      "request_id": "YZt9f1vSjAWunDe",
      "tab_token": "none",
      "data": {
        "iface_kind": "mapper",
        "mapper": {
          "id": 3,
          "type": "mapper",
          "mappertype": "Mapper",
          "desc": "mapper code test",
          "fields": {
            "output-1": {
              "code": "issue3406mappercode::getMapperField"
            },
            "output-2": {
              "name": "input-1",
              "code": "issue3406mappercode::getMapperField"
            },
            "output-3": {
              "name": "input-2"
            },
            "output-4": "input-1",
            "output-5": {
              "constant": 123
            },
            "output-6": "input-1",
            "output-7": "input-3"
          },
          "name": "issue3406mapper",
          "display_name": "Issue3406mapper",
          "short_desc": "mapper code test",
          "version": "1.0",
          "author": ["Qore Technologies, s.r.o."],
          "mapper_options": {
            "mapper-input": {
              "input-1": {
                "desc": "input 1"
              },
              "input-2": "input 2",
              "input-3": "input 3"
            },
            "mapper-output": {
              "output-1": "output 1",
              "output-2": "output 2",
              "output-3": "output 3",
              "output-4": {
                "desc": "output 4",
                "maxlen": 43,
                "type": "string",
                "mand": true
              },
              "output-5": {
                "desc": "output 5"
              },
              "output-6": {
                "desc": "output 6"
              },
              "output-7": "output 7"
            }
          }
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got mapper 3"
    },
    {
      "request_id": "yuw6iDSkX4ctml8",
      "tab_token": "none",
      "data": {
        "iface_kind": "mapper",
        "mapper": {
          "id": 4,
          "type": "mapper",
          "mappertype": "Mapper",
          "desc": "low code mapper test 1",
          "fields": {
            "d": {
              "name": "a"
            },
            "e": {
              "name": "b"
            },
            "f": {
              "name": "c"
            }
          },
          "name": "lowcode-test-1",
          "display_name": "Lowcode Test 1",
          "short_desc": "low code mapper test 1",
          "version": "1.0",
          "author": ["Qore Technologies, s.r.o."],
          "mapper_options": {
            "mapper-input": {
              "type": "type",
              "name": "qore",
              "path": "/hash",
              "can_manage_fields": true,
              "custom-fields": {
                "a": {
                  "name": "a",
                  "desc": "a",
                  "type": {
                    "typename": "string",
                    "name": "string",
                    "supported_options": {
                      "qore.no_null": {
                        "type": "bool",
                        "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                      },
                      "string.encoding": {
                        "type": "string",
                        "desc": "the output encoding when writing to the type"
                      },
                      "string.max_size_chars": {
                        "type": "integer",
                        "desc": "the maximum length of the string in characters"
                      }
                    },
                    "options": {
                      "qore.no_null": true
                    },
                    "base_type": "string",
                    "mandatory": true,
                    "types_accepted": ["string"],
                    "types_returned": ["string"],
                    "fields": {},
                    "can_manage_fields": false
                  },
                  "isCustom": true,
                  "canBeNull": false,
                  "firstCustomInHierarchy": true,
                  "isChild": false,
                  "level": 0,
                  "path": "a",
                  "parentPath": false
                },
                "b": {
                  "name": "b",
                  "desc": "b",
                  "type": {
                    "typename": "string",
                    "name": "string",
                    "supported_options": {
                      "qore.no_null": {
                        "type": "bool",
                        "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                      },
                      "string.encoding": {
                        "type": "string",
                        "desc": "the output encoding when writing to the type"
                      },
                      "string.max_size_chars": {
                        "type": "integer",
                        "desc": "the maximum length of the string in characters"
                      }
                    },
                    "options": {
                      "qore.no_null": true
                    },
                    "base_type": "string",
                    "mandatory": true,
                    "types_accepted": ["string"],
                    "types_returned": ["string"],
                    "fields": {},
                    "can_manage_fields": false
                  },
                  "isCustom": true,
                  "canBeNull": false,
                  "firstCustomInHierarchy": true,
                  "isChild": false,
                  "level": 0,
                  "path": "b",
                  "parentPath": false
                },
                "c": {
                  "name": "c",
                  "desc": "c",
                  "type": {
                    "typename": "string",
                    "name": "string",
                    "supported_options": {
                      "qore.no_null": {
                        "type": "bool",
                        "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                      },
                      "string.encoding": {
                        "type": "string",
                        "desc": "the output encoding when writing to the type"
                      },
                      "string.max_size_chars": {
                        "type": "integer",
                        "desc": "the maximum length of the string in characters"
                      }
                    },
                    "options": {
                      "qore.no_null": true
                    },
                    "base_type": "string",
                    "mandatory": true,
                    "types_accepted": ["string"],
                    "types_returned": ["string"],
                    "fields": {},
                    "can_manage_fields": false
                  },
                  "isCustom": true,
                  "canBeNull": false,
                  "firstCustomInHierarchy": true,
                  "isChild": false,
                  "level": 0,
                  "path": "c",
                  "parentPath": false
                }
              }
            },
            "mapper-output": {
              "type": "type",
              "name": "qore",
              "path": "/hash",
              "can_manage_fields": true,
              "custom-fields": {
                "d": {
                  "name": "d",
                  "desc": "d",
                  "type": {
                    "typename": "string",
                    "name": "softstring",
                    "supported_options": {
                      "qore.no_null": {
                        "type": "bool",
                        "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                      },
                      "string.encoding": {
                        "type": "string",
                        "desc": "the output encoding when writing to the type"
                      },
                      "string.max_size_chars": {
                        "type": "integer",
                        "desc": "the maximum length of the string in characters"
                      }
                    },
                    "options": {
                      "qore.no_null": true
                    },
                    "base_type": "string",
                    "mandatory": true,
                    "types_accepted": [
                      "string",
                      "bool",
                      "float",
                      "int",
                      "integer",
                      "date",
                      "number"
                    ],
                    "types_returned": ["string"],
                    "fields": {},
                    "can_manage_fields": false
                  },
                  "isCustom": true,
                  "canBeNull": false,
                  "firstCustomInHierarchy": true,
                  "isChild": false,
                  "level": 0,
                  "path": "d",
                  "parentPath": false
                },
                "e": {
                  "name": "e",
                  "desc": "e",
                  "type": {
                    "typename": "string",
                    "name": "softstring",
                    "supported_options": {
                      "qore.no_null": {
                        "type": "bool",
                        "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                      },
                      "string.encoding": {
                        "type": "string",
                        "desc": "the output encoding when writing to the type"
                      },
                      "string.max_size_chars": {
                        "type": "integer",
                        "desc": "the maximum length of the string in characters"
                      }
                    },
                    "options": {
                      "qore.no_null": true
                    },
                    "base_type": "string",
                    "mandatory": true,
                    "types_accepted": [
                      "string",
                      "bool",
                      "float",
                      "int",
                      "integer",
                      "date",
                      "number"
                    ],
                    "types_returned": ["string"],
                    "fields": {},
                    "can_manage_fields": false
                  },
                  "isCustom": true,
                  "canBeNull": false,
                  "firstCustomInHierarchy": true,
                  "isChild": false,
                  "level": 0,
                  "path": "e",
                  "parentPath": false
                },
                "f": {
                  "name": "f",
                  "desc": "f",
                  "type": {
                    "typename": "string",
                    "name": "softstring",
                    "supported_options": {
                      "qore.no_null": {
                        "type": "bool",
                        "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                      },
                      "string.encoding": {
                        "type": "string",
                        "desc": "the output encoding when writing to the type"
                      },
                      "string.max_size_chars": {
                        "type": "integer",
                        "desc": "the maximum length of the string in characters"
                      }
                    },
                    "options": {
                      "qore.no_null": true
                    },
                    "base_type": "string",
                    "mandatory": true,
                    "types_accepted": [
                      "string",
                      "bool",
                      "float",
                      "int",
                      "integer",
                      "date",
                      "number"
                    ],
                    "types_returned": ["string"],
                    "fields": {},
                    "can_manage_fields": false
                  },
                  "isCustom": true,
                  "canBeNull": false,
                  "firstCustomInHierarchy": true,
                  "isChild": false,
                  "level": 0,
                  "path": "f",
                  "parentPath": false
                }
              }
            }
          }
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got mapper 4"
    },
    {
      "request_id": "UCu4lLFeDtqTqcc",
      "tab_token": "none",
      "data": {
        "iface_kind": "mapper",
        "mapper": {
          "id": 6,
          "type": "mapper",
          "mappertype": "Mapper",
          "desc": "mapper to bridge Create Order to Cancel Order in flow issue-3816-2",
          "fields": {
            "workflow_instanceid": {
              "name": "workflow_instanceid"
            }
          },
          "name": "issue-3816-2-Create Order-Cancel Order",
          "display_name": "Issue 3816 2 Create Order Cancel Order",
          "short_desc": "mapper to bridge Create Order to Cancel Order in flow issue-3816-2",
          "version": "1.0",
          "mapper_options": {
            "mapper-input": {
              "type": "factory",
              "name": "qorus-api",
              "path": "/workflows/create-order",
              "supports_request": true,
              "is_api_call": true,
              "custom-fields": {}
            },
            "mapper-output": {
              "type": "factory",
              "name": "qorus-api",
              "path": "/workflows/cancel-order",
              "supports_request": true,
              "is_api_call": true,
              "custom-fields": {}
            }
          }
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got mapper 6"
    },
    {
      "request_id": "ZCjqscU5KukUUwB",
      "tab_token": "none",
      "data": {
        "iface_kind": "mapper",
        "mapper": {
          "id": 7,
          "type": "mapper",
          "mappertype": "Mapper",
          "desc": "Provides arguments to the create-order call",
          "fields": {
            "workflow": {
              "constant": "DUMMY-TEST"
            },
            "staticdata": {
              "constant": {}
            }
          },
          "name": "issue-3816-create-order",
          "display_name": "Issue 3816 Create Order",
          "short_desc": "Provides arguments to the create-order call",
          "version": "1.0",
          "author": ["Qore Technologies, s.r.o."],
          "mapper_options": {
            "mapper-input": {
              "type": "type",
              "name": "qore",
              "can_manage_fields": true,
              "path": "/hash",
              "custom-fields": {}
            },
            "mapper-output": {
              "type": "type",
              "name": "qoretechnologies",
              "can_manage_fields": false,
              "path": "/qorus-api/workflows/create-order",
              "subtype": "request",
              "custom-fields": {}
            }
          }
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got mapper 7"
    },
    {
      "request_id": "kANefT3VhSoj5du",
      "tab_token": "none",
      "data": {
        "iface_kind": "mapper",
        "mapper": {
          "id": 9,
          "type": "mapper",
          "mappertype": "Mapper",
          "desc": "test for https://git.qoretechnologies.com/qorus/issues/issues/3444",
          "fields": {
            "id": {
              "name": "id"
            },
            "string": {
              "name": "rec.key"
            }
          },
          "name": "issue-3444",
          "display_name": "Issue 3444",
          "short_desc": "test for https://git",
          "version": "1.0",
          "author": ["Qore Technologies, s.r.o."],
          "mapper_options": {
            "mapper-input": {
              "can_manage_fields": true,
              "custom-fields": {
                "id": {
                  "canBeNull": false,
                  "desc": "id",
                  "firstCustomInHierarchy": true,
                  "isChild": false,
                  "isCustom": true,
                  "level": 0,
                  "name": "id",
                  "parentPath": false,
                  "path": "id",
                  "type": {
                    "base_type": "int",
                    "can_manage_fields": false,
                    "fields": {},
                    "mandatory": true,
                    "name": "int",
                    "options": {
                      "qore.no_null": true
                    },
                    "supported_options": {
                      "qore.no_null": {
                        "desc": "if True then NULL is not supported on input if NOTHING is also not accepted",
                        "type": "bool"
                      }
                    },
                    "typename": "int",
                    "types_accepted": ["int"],
                    "types_returned": ["int"]
                  }
                },
                "rec": {
                  "canBeNull": false,
                  "desc": "rec",
                  "firstCustomInHierarchy": true,
                  "isChild": false,
                  "isCustom": true,
                  "level": 0,
                  "name": "rec",
                  "parentPath": false,
                  "path": "rec",
                  "type": {
                    "base_type": "hash<auto>",
                    "can_manage_fields": true,
                    "fields": {
                      "key": {
                        "canBeNull": false,
                        "desc": "key",
                        "isCustom": true,
                        "name": "key",
                        "type": {
                          "base_type": "string",
                          "can_manage_fields": false,
                          "fields": {},
                          "mandatory": true,
                          "name": "string",
                          "options": {
                            "qore.no_null": true
                          },
                          "supported_options": {
                            "qore.no_null": {
                              "desc": "if True then NULL is not supported on input if NOTHING is also not accepted",
                              "type": "bool"
                            },
                            "string.encoding": {
                              "desc": "the output encoding when writing to the type",
                              "type": "string"
                            },
                            "string.max_size_chars": {
                              "desc": "the maximum length of the string in characters",
                              "type": "integer"
                            }
                          },
                          "typename": "string",
                          "types_accepted": ["string"],
                          "types_returned": ["string"]
                        }
                      },
                      "subrec": {
                        "canBeNull": false,
                        "desc": "subrec",
                        "isCustom": true,
                        "name": "subrec",
                        "type": {
                          "base_type": "auto",
                          "can_manage_fields": true,
                          "fields": {
                            "value": {
                              "canBeNull": false,
                              "desc": "value",
                              "isCustom": true,
                              "name": "value",
                              "type": {
                                "base_type": "string",
                                "can_manage_fields": false,
                                "fields": {},
                                "mandatory": true,
                                "name": "string",
                                "options": {
                                  "qore.no_null": true
                                },
                                "supported_options": {
                                  "qore.no_null": {
                                    "desc": "if True then NULL is not supported on input if NOTHING is also not accepted",
                                    "type": "bool"
                                  },
                                  "string.encoding": {
                                    "desc": "the output encoding when writing to the type",
                                    "type": "string"
                                  },
                                  "string.max_size_chars": {
                                    "desc": "the maximum length of the string in characters",
                                    "type": "integer"
                                  }
                                },
                                "typename": "string",
                                "types_accepted": ["string"],
                                "types_returned": ["string"]
                              }
                            }
                          },
                          "mandatory": false,
                          "name": "auto",
                          "options": null,
                          "supported_options": null,
                          "typename": "any",
                          "types_accepted": ["any"],
                          "types_returned": ["any"]
                        }
                      }
                    },
                    "mandatory": true,
                    "name": "hash<auto>",
                    "options": {
                      "qore.no_null": true
                    },
                    "supported_options": {
                      "qore.no_null": {
                        "desc": "if True then NULL is not supported on input if NOTHING is also not accepted",
                        "type": "bool"
                      }
                    },
                    "typename": "hash",
                    "types_accepted": ["hash<auto>"],
                    "types_returned": ["hash<auto>"]
                  }
                },
                "string": {
                  "canBeNull": false,
                  "desc": "string",
                  "firstCustomInHierarchy": true,
                  "isChild": false,
                  "isCustom": true,
                  "level": 0,
                  "name": "string",
                  "parentPath": false,
                  "path": "string",
                  "type": {
                    "base_type": "string",
                    "can_manage_fields": false,
                    "fields": {},
                    "mandatory": true,
                    "name": "string",
                    "options": {
                      "qore.no_null": true
                    },
                    "supported_options": {
                      "qore.no_null": {
                        "desc": "if True then NULL is not supported on input if NOTHING is also not accepted",
                        "type": "bool"
                      },
                      "string.encoding": {
                        "desc": "the output encoding when writing to the type",
                        "type": "string"
                      },
                      "string.max_size_chars": {
                        "desc": "the maximum length of the string in characters",
                        "type": "integer"
                      }
                    },
                    "typename": "string",
                    "types_accepted": ["string"],
                    "types_returned": ["string"]
                  }
                }
              },
              "name": "qore",
              "path": "/hash",
              "type": "type"
            },
            "mapper-output": {
              "can_manage_fields": true,
              "custom-fields": {
                "id": {
                  "canBeNull": false,
                  "desc": "id",
                  "firstCustomInHierarchy": true,
                  "isChild": false,
                  "isCustom": true,
                  "level": 0,
                  "name": "id",
                  "parentPath": false,
                  "path": "id",
                  "type": {
                    "base_type": "int",
                    "can_manage_fields": false,
                    "fields": {},
                    "mandatory": true,
                    "name": "int",
                    "options": {
                      "qore.no_null": true
                    },
                    "supported_options": {
                      "qore.no_null": {
                        "desc": "if True then NULL is not supported on input if NOTHING is also not accepted",
                        "type": "bool"
                      }
                    },
                    "typename": "int",
                    "types_accepted": ["int"],
                    "types_returned": ["int"]
                  }
                },
                "rec": {
                  "canBeNull": false,
                  "desc": "rec",
                  "firstCustomInHierarchy": true,
                  "isChild": false,
                  "isCustom": true,
                  "level": 0,
                  "name": "rec",
                  "parentPath": false,
                  "path": "rec",
                  "type": {
                    "base_type": "hash<auto>",
                    "can_manage_fields": true,
                    "fields": {
                      "key": {
                        "canBeNull": false,
                        "desc": "key",
                        "isCustom": true,
                        "name": "key",
                        "type": {
                          "base_type": "string",
                          "can_manage_fields": false,
                          "fields": {},
                          "mandatory": true,
                          "name": "string",
                          "options": {
                            "qore.no_null": true
                          },
                          "supported_options": {
                            "qore.no_null": {
                              "desc": "if True then NULL is not supported on input if NOTHING is also not accepted",
                              "type": "bool"
                            },
                            "string.encoding": {
                              "desc": "the output encoding when writing to the type",
                              "type": "string"
                            },
                            "string.max_size_chars": {
                              "desc": "the maximum length of the string in characters",
                              "type": "integer"
                            }
                          },
                          "typename": "string",
                          "types_accepted": ["string"],
                          "types_returned": ["string"]
                        }
                      },
                      "subrec": {
                        "canBeNull": false,
                        "desc": "subrec",
                        "isCustom": true,
                        "name": "subrec",
                        "type": {
                          "base_type": "auto",
                          "can_manage_fields": true,
                          "fields": {
                            "value": {
                              "canBeNull": false,
                              "desc": "value",
                              "isCustom": true,
                              "name": "value",
                              "type": {
                                "base_type": "string",
                                "can_manage_fields": false,
                                "fields": {},
                                "mandatory": true,
                                "name": "string",
                                "options": {
                                  "qore.no_null": true
                                },
                                "supported_options": {
                                  "qore.no_null": {
                                    "desc": "if True then NULL is not supported on input if NOTHING is also not accepted",
                                    "type": "bool"
                                  },
                                  "string.encoding": {
                                    "desc": "the output encoding when writing to the type",
                                    "type": "string"
                                  },
                                  "string.max_size_chars": {
                                    "desc": "the maximum length of the string in characters",
                                    "type": "integer"
                                  }
                                },
                                "typename": "string",
                                "types_accepted": ["string"],
                                "types_returned": ["string"]
                              }
                            }
                          },
                          "mandatory": false,
                          "name": "auto",
                          "options": null,
                          "supported_options": null,
                          "typename": "any",
                          "types_accepted": ["any"],
                          "types_returned": ["any"]
                        }
                      }
                    },
                    "mandatory": true,
                    "name": "hash<auto>",
                    "options": {
                      "qore.no_null": true
                    },
                    "supported_options": {
                      "qore.no_null": {
                        "desc": "if True then NULL is not supported on input if NOTHING is also not accepted",
                        "type": "bool"
                      }
                    },
                    "typename": "hash",
                    "types_accepted": ["hash<auto>"],
                    "types_returned": ["hash<auto>"]
                  }
                },
                "string": {
                  "canBeNull": false,
                  "desc": "string",
                  "firstCustomInHierarchy": true,
                  "isChild": false,
                  "isCustom": true,
                  "level": 0,
                  "name": "string",
                  "parentPath": false,
                  "path": "string",
                  "type": {
                    "base_type": "string",
                    "can_manage_fields": false,
                    "fields": {},
                    "mandatory": true,
                    "name": "string",
                    "options": {
                      "qore.no_null": true
                    },
                    "supported_options": {
                      "qore.no_null": {
                        "desc": "if True then NULL is not supported on input if NOTHING is also not accepted",
                        "type": "bool"
                      },
                      "string.encoding": {
                        "desc": "the output encoding when writing to the type",
                        "type": "string"
                      },
                      "string.max_size_chars": {
                        "desc": "the maximum length of the string in characters",
                        "type": "integer"
                      }
                    },
                    "typename": "string",
                    "types_accepted": ["string"],
                    "types_returned": ["string"]
                  }
                }
              },
              "name": "qore",
              "path": "/hash",
              "type": "type"
            }
          }
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got mapper 9"
    },
    {
      "request_id": "w6tGa2BJr4sj0jZ",
      "tab_token": "none",
      "data": {
        "iface_kind": "mapper",
        "mapper": {
          "id": 10,
          "type": "mapper",
          "mappertype": "Mapper",
          "desc": "mapper test mapper",
          "fields": {
            "output_1": {
              "name": "input_1"
            },
            "output_2": {
              "name": "input_2"
            },
            "output_3": {
              "constant": 123
            }
          },
          "name": "mapper-test-1",
          "display_name": "Mapper Test 1",
          "short_desc": "mapper test mapper",
          "version": "1.0",
          "author": ["Qore Technologies, s.r.o."],
          "mapper_options": {
            "mapper-input": {
              "custom-fields": {},
              "name": "omquser",
              "path": "/table_1",
              "type": "datasource"
            },
            "mapper-output": {
              "custom-fields": {},
              "name": "omquser",
              "path": "/table_2",
              "type": "datasource"
            },
            "output_provider_bulk": true
          }
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got mapper 10"
    },
    {
      "request_id": "45Y8kucRQokDyz6",
      "tab_token": "none",
      "data": {
        "iface_kind": "mapper",
        "mapper": {
          "id": 11,
          "type": "mapper",
          "mappertype": "Mapper",
          "desc": "mapper test mapper",
          "fields": {
            "output_1": {
              "name": "input_1"
            },
            "output_2": {
              "name": "input_2"
            },
            "output_3": {
              "constant": 123
            }
          },
          "name": "mapper-test-2",
          "display_name": "Mapper Test 2",
          "short_desc": "mapper test mapper",
          "version": "1.0",
          "author": ["Qore Technologies, s.r.o."],
          "mapper_options": {
            "mapper-input": {
              "type": "remote",
              "name": "mapper-test-2",
              "path": "/datasources/omquser/table_1"
            },
            "mapper-output": {
              "type": "remote",
              "name": "mapper-test-2",
              "path": "/datasources/omquser/table_2"
            },
            "output_provider_bulk": true
          }
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got mapper 11"
    },
    {
      "request_id": "3IIUVThjjIFhUuk",
      "tab_token": "none",
      "data": {
        "iface_kind": "mapper",
        "mapper": {
          "id": 12,
          "type": "mapper",
          "mappertype": "Mapper",
          "desc": "mapper code test",
          "fields": {
            "output_1": {
              "name": "body.result"
            },
            "output_2": {
              "name": "body.docs"
            },
            "output_3": {
              "constant": 123
            }
          },
          "name": "mapper-test-3",
          "display_name": "Mapper Test 3",
          "short_desc": "mapper code test",
          "version": "1.0",
          "author": ["Qore Technologies, s.r.o."],
          "mapper_options": {
            "mapper-input": {
              "type": "connection",
              "subtype": "response",
              "name": "soap-simple",
              "path": "/getCompanyInfo"
            },
            "mapper-output": {
              "type": "datasource",
              "name": "omquser",
              "path": "/table_2"
            },
            "output_provider_bulk": true
          }
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got mapper 12"
    }
  ],
  "mapper-code": [
    {
      "request_id": "i1RT40H2T1LFLfo",
      "tab_token": "none",
      "data": {
        "iface_kind": "mapper-code",
        "mapper-code": {
          "id": 125,
          "type": "mapper-code",
          "desc": "mapper code",
          "lang": "qore",
          "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass issue3406mappercode {\n    static string getMapperField(auto ignored, hash<auto> record) {\n        string result;\n        foreach auto key in (keys record) {\n            result += \"_\" + key;\n        }\n        return result;\n    }\n\n    static auto getOutput4(auto ignored, hash<auto> record) {\n        return \"test4\";\n    }\n\n    static string get_value(string value) {\n        return \"test\" + value;\n    }\n\n    static string getValue(auto ignored, hash record) {\n        return issue3406mappercode::get_value(\"testdata\");\n    }\n}",
          "name": "issue3406mappercode",
          "display_name": "Issue3406mappercode",
          "short_desc": "mapper code",
          "version": "1.0",
          "author": ["Qore Technologies, s.r.o."],
          "mapper-methods": [
            {
              "name": "getMapperField",
              "desc": "test method 1"
            },
            {
              "name": "getOutput4",
              "desc": "test method 2"
            },
            {
              "name": "getValue",
              "desc": "test method 3"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got mapper-code 125"
    },
    {
      "request_id": "LDdtUHSGNaChYgH",
      "tab_token": "none",
      "data": {
        "iface_kind": "mapper-code",
        "mapper-code": {
          "id": 124,
          "type": "mapper-code",
          "desc": "CRM to ERP demo mapper code",
          "lang": "qore",
          "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass CrmToErpAccountSyncCode {\n    static auto get_event_id(auto ctx, hash<auto> record) {\n        return {\n            \"salesforce_event_id\": event_id,\n        };\n    }\n\n    static auto get_account_ids(auto ctx, hash<auto> record) {\n        return {\n            \"salesforce_account_id\": account_ids[0],\n        };\n    }\n\n    static auto get_message_body(auto ctx, hash<auto> record) {\n        return {\n            \"lastname\": static_data.Name,\n            \"address\": static_data.BillingAddress.Street,\n            \"postalcode\": static_data.BillingAddress.PostalCode,\n        };\n    }\n}\n",
          "name": "CrmToErpAccountSyncCode",
          "display_name": "Crm To Erp Account Sync Code",
          "short_desc": "CRM to ERP demo mapper code",
          "version": "1.0",
          "author": ["Qore Technologies, s.r.o."],
          "mapper-methods": [
            {
              "name": "get_event_id",
              "desc": "ensures order is created once for unique values"
            },
            {
              "name": "get_account_ids",
              "desc": "returns account ids"
            },
            {
              "name": "get_message_body",
              "desc": "returns message body"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got mapper-code 124"
    },
    {
      "request_id": "ajeAjfBcVZCsigd",
      "tab_token": "none",
      "data": {
        "iface_kind": "mapper-code",
        "mapper-code": {
          "id": 123,
          "type": "mapper-code",
          "desc": "mapper code",
          "lang": "qore",
          "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass issue3364mappercode {\n    static string getMapperField(auto ignored, hash<auto> record) {\n        string result;\n        foreach auto key in (keys record) {\n            result += \"_\" + key;\n        }\n        return result;\n    }\n\n    static auto getOutput4(auto ignored, hash<auto> record) {\n        return \"test4\";\n    }\n\n    static string get_value(string value) {\n        return \"test\" + value;\n    }\n\n    static string getValue(auto ignored, hash record) {\n        return issue3364mappercode::get_value(\"testdata\");\n    }\n}",
          "name": "issue3364mappercode",
          "display_name": "Issue3364mappercode",
          "short_desc": "mapper code",
          "version": "1.0",
          "author": ["Qore Technologies, s.r.o."],
          "mapper-methods": [
            {
              "name": "getMapperField",
              "desc": "test method 1"
            },
            {
              "name": "getOutput4",
              "desc": "test method 2"
            },
            {
              "name": "getValue",
              "desc": "test method 3"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got mapper-code 123"
    }
  ],
  "pipeline": [
    {
      "request_id": "00OYe61sgNA4Qmw",
      "tab_token": "none",
      "data": {
        "iface_kind": "pipeline",
        "pipeline": {
          "id": 112,
          "type": "pipeline",
          "desc": "pipeline 4",
          "name": "pipeline4",
          "display_name": "Pipeline4",
          "short_desc": "pipeline 4",
          "children": [
            {
              "pid": "id1",
              "name": "Issue3485JavaProcessor1",
              "type": "processor",
              "children": [
                {
                  "pid": "id2",
                  "name": "Issue3485JavaProcessor2",
                  "type": "processor"
                }
              ]
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got pipeline 112"
    },
    {
      "request_id": "cpf4vzTJzJK8WIR",
      "tab_token": "none",
      "data": {
        "iface_kind": "pipeline",
        "pipeline": {
          "id": 17,
          "type": "pipeline",
          "desc": "test for the BBM_DataProviderRecordCreateProcessor building block",
          "name": "bbm-data-provider-create-processor-test",
          "display_name": "Bbm Data Provider Create Processor Test",
          "short_desc": "test for the BBM_DataProviderRecordCreateProcessor building block",
          "children": [
            {
              "type": "processor",
              "name": "BBM_GetPipelineData",
              "pid": "U3eP3jeIV",
              "children": [
                {
                  "type": "processor",
                  "name": "BBM_DataProviderRecordCreateProcessor",
                  "pid": "T1w5s6wjx"
                }
              ]
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got pipeline 17"
    },
    {
      "request_id": "uQbTZGBzq20cfuD",
      "tab_token": "none",
      "data": {
        "iface_kind": "pipeline",
        "pipeline": {
          "id": 130,
          "type": "pipeline",
          "desc": "pipeline 6",
          "name": "pipeline6",
          "display_name": "Pipeline6",
          "short_desc": "pipeline 6",
          "children": [
            {
              "type": "processor",
              "name": "Issue3485Processor1",
              "pid": "id1",
              "children": [
                {
                  "type": "processor",
                  "name": "Issue3485Processor2",
                  "pid": "id2",
                  "children": [
                    {
                      "type": "processor",
                      "name": "Issue3485Processor3",
                      "pid": "id3"
                    }
                  ]
                }
              ]
            }
          ],
          "input-provider": {
            "name": "omquser",
            "path": "/pipe_table_1",
            "type": "datasource"
          },
          "input-provider-options": {
            "input_provider_search": {
              "type": "hash",
              "value": "{col_1: 2}\n"
            }
          }
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got pipeline 130"
    },
    {
      "request_id": "DvJeWydR2WNEVD7",
      "tab_token": "none",
      "data": {
        "iface_kind": "pipeline",
        "pipeline": {
          "id": 271,
          "type": "pipeline",
          "desc": "low code test pipeline",
          "name": "pipeline7",
          "display_name": "Pipeline7",
          "short_desc": "low code test pipeline",
          "children": [
            {
              "type": "mapper",
              "name": "lowcode-test-1:1.0",
              "children": [
                {
                  "type": "processor",
                  "name": "LowCodeTestSaveOutput",
                  "pid": "IgMlO9rhaF"
                }
              ]
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got pipeline 271"
    },
    {
      "request_id": "bQK0uG9UhDCZWy1",
      "tab_token": "none",
      "data": {
        "iface_kind": "pipeline",
        "pipeline": {
          "id": 117,
          "type": "pipeline",
          "desc": "pipeline 2",
          "name": "pipeline2",
          "display_name": "Pipeline2",
          "short_desc": "pipeline 2",
          "children": [
            {
              "pid": "id1",
              "name": "Issue3485Processor1",
              "type": "processor",
              "children": [
                {
                  "pid": "id2",
                  "name": "Issue3485Processor2",
                  "type": "processor"
                }
              ]
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got pipeline 117"
    },
    {
      "request_id": "ORl0DwR4BYxDuGh",
      "tab_token": "none",
      "data": {
        "iface_kind": "pipeline",
        "pipeline": {
          "id": 111,
          "type": "pipeline",
          "desc": "pipeline 3",
          "name": "pipeline3",
          "display_name": "Pipeline3",
          "short_desc": "pipeline 3",
          "children": [
            {
              "pid": "id1",
              "name": "Issue3485Processor2",
              "type": "processor",
              "children": [
                {
                  "pid": "id2",
                  "name": "Issue3485Processor1",
                  "type": "processor"
                }
              ]
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got pipeline 111"
    },
    {
      "request_id": "jVua9xivLFl6jxT",
      "tab_token": "none",
      "data": {
        "iface_kind": "pipeline",
        "pipeline": {
          "id": 100,
          "type": "pipeline",
          "desc": "Factory test pipeline",
          "name": "factory-test",
          "display_name": "Factory Test",
          "short_desc": "Factory test pipeline",
          "children": [
            {
              "type": "processor",
              "name": "Issue3485Processor4",
              "pid": "08w9QCqkM"
            }
          ],
          "input-provider": {
            "type": "factory",
            "name": "csvread",
            "path": "",
            "options": {
              "path": {
                "type": "string",
                "value": "$xconfig:{csv-input-path}"
              },
              "header_names": {
                "type": "softbool",
                "value": true
              },
              "date_format": {
                "type": "string",
                "value": "DD.MM.YYYY"
              },
              "fields": {
                "type": "hash<auto>",
                "value": {
                  "id": "int",
                  "activation_date": "date"
                }
              }
            }
          }
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got pipeline 100"
    },
    {
      "request_id": "7AaBe39lYHkcmbP",
      "tab_token": "none",
      "data": {
        "iface_kind": "pipeline",
        "pipeline": {
          "id": 113,
          "type": "pipeline",
          "desc": "pipeline 5",
          "name": "pipeline5",
          "display_name": "Pipeline5",
          "short_desc": "pipeline 5",
          "children": [
            {
              "name": "Issue3485PythonProcessor1",
              "type": "processor",
              "pid": "id1",
              "children": [
                {
                  "name": "Issue3485PythonProcessor2",
                  "type": "processor",
                  "pid": "id2"
                }
              ]
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got pipeline 113"
    },
    {
      "request_id": "5MIMtNND0OmeJ4a",
      "tab_token": "none",
      "data": {
        "iface_kind": "pipeline",
        "pipeline": {
          "id": 18,
          "type": "pipeline",
          "desc": "Read DB data and create CSV file",
          "name": "julius-meinl-mews-netsuite-transform",
          "display_name": "Julius Meinl Mews Netsuite Transform",
          "short_desc": "Read DB data and create CSV file",
          "children": [
            {
              "type": "mapper",
              "name": "julius-meinl-mews-netsuite-transform:1.0",
              "children": [
                {
                  "type": "processor",
                  "name": "BBM_DataProviderRecordCreateProcessor",
                  "pid": "9rOhHL7TlQ1I"
                }
              ]
            }
          ],
          "input-provider": {
            "type": "datasource",
            "name": "omquser",
            "transaction_management": true,
            "path": "/mews_accounting",
            "descriptions": [
              "Data provider for database `pgsql:omquser@omquser`; use the search API with the `sql` and `args` arguments to execute record-based queries",
              "Record-based data provider for db table `public.mews_accounting`; supports create, read/search, update, delete, upsert, and bulk operations"
            ],
            "supports_read": true,
            "supports_update": true,
            "supports_create": true,
            "supports_delete": true,
            "supports_messages": "NONE"
          },
          "input-provider-options": {
            "input_provider_search": {
              "type": "hash",
              "value": "{qorus_jiid: \"$local:service_method_args[0]\"}\n"
            }
          }
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got pipeline 18"
    },
    {
      "request_id": "ZxTpvUiJeBpzFhX",
      "tab_token": "none",
      "data": {
        "iface_kind": "pipeline",
        "pipeline": {
          "id": 19,
          "type": "pipeline",
          "desc": "test",
          "name": "bbm-simple-filter-pipeline-data-test-2",
          "display_name": "Bbm Simple Filter Pipeline Data Test 2",
          "short_desc": "test",
          "children": [
            {
              "type": "processor",
              "name": "BBM_GetPipelineData",
              "pid": "gc_wFTIjY",
              "children": [
                {
                  "type": "processor",
                  "name": "BBM_SimpleFilterPipelineData",
                  "pid": "NEF3L8hSZ",
                  "children": [
                    {
                      "type": "mapper",
                      "name": "bbm-simple-filter-pipeline-data-test-2:1.0",
                      "children": [
                        {
                          "type": "processor",
                          "name": "PipelineElementSaveDataInJob",
                          "pid": "8heYLpGMm"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got pipeline 19"
    }
  ],
  "queue": [
    {
      "request_id": "Bf6QCkyzoJZRih5",
      "tab_token": "none",
      "data": {
        "iface_kind": "queue",
        "queue": {
          "id": 8,
          "type": "queue",
          "desc": "asynchronous test queue for REF-TEST workflow",
          "name": "ref-test",
          "display_name": "Ref Test",
          "short_desc": "asynchronous test queue for REF-TEST workflow"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got queue 8"
    },
    {
      "request_id": "L8rdRBolw7sP2kU",
      "tab_token": "none",
      "data": {
        "iface_kind": "queue",
        "queue": {
          "id": 9,
          "type": "queue",
          "desc": "issue 2495 asynchronous test queue",
          "name": "issue-2495-test",
          "display_name": "Issue 2495 Test",
          "short_desc": "issue 2495 asynchronous test queue"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got queue 9"
    },
    {
      "request_id": "yxys88fBuZMfw7n",
      "tab_token": "none",
      "data": {
        "iface_kind": "queue",
        "queue": {
          "id": 10,
          "type": "queue",
          "desc": "asynchronous test queue for the ERRORTEST workflow",
          "name": "errortest-async",
          "display_name": "Errortest Async",
          "short_desc": "asynchronous test queue for the ERRORTEST workflow"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got queue 10"
    },
    {
      "request_id": "xO4opM4qIq6TMqs",
      "tab_token": "none",
      "data": {
        "iface_kind": "queue",
        "queue": {
          "id": 11,
          "type": "queue",
          "desc": "wf-api asynchronous test queue 1",
          "name": "async_queue_1",
          "display_name": "Async Queue 1",
          "short_desc": "wf-api asynchronous test queue 1"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got queue 11"
    },
    {
      "request_id": "GvoDMAmLFLlCKg0",
      "tab_token": "none",
      "data": {
        "iface_kind": "queue",
        "queue": {
          "id": 12,
          "type": "queue",
          "desc": "wf-api asynchronous test queue 2",
          "name": "async_queue_2",
          "display_name": "Async Queue 2",
          "short_desc": "wf-api asynchronous test queue 2"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got queue 12"
    },
    {
      "request_id": "Y6t5FSExi2sksas",
      "tab_token": "none",
      "data": {
        "iface_kind": "queue",
        "queue": {
          "id": 1,
          "type": "queue",
          "desc": "asynchronous demo queue",
          "name": "demo-queue",
          "display_name": "Demo Queue",
          "short_desc": "asynchronous demo queue"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got queue 1"
    },
    {
      "request_id": "5BQPHjHbVPYsMtE",
      "tab_token": "none",
      "data": {
        "iface_kind": "queue",
        "queue": {
          "id": 15,
          "type": "queue",
          "desc": "Class workflow asynchronous test queue",
          "name": "issue3102queue",
          "display_name": "Issue3102queue",
          "short_desc": "Class workflow asynchronous test queue"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got queue 15"
    },
    {
      "request_id": "nmTXSYbAmfkh7xH",
      "tab_token": "none",
      "data": {
        "iface_kind": "queue",
        "queue": {
          "id": 3,
          "type": "queue",
          "desc": "Class workflow asynchronous test queue",
          "name": "qore-class-test",
          "display_name": "Qore Class Test",
          "short_desc": "Class workflow asynchronous test queue"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got queue 3"
    },
    {
      "request_id": "867kFRRu2jzCo5E",
      "tab_token": "none",
      "data": {
        "iface_kind": "queue",
        "queue": {
          "id": 5,
          "type": "queue",
          "desc": "asynchronous test queue",
          "name": "async-test",
          "display_name": "Async Test",
          "short_desc": "asynchronous test queue"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got queue 5"
    },
    {
      "request_id": "cnQj0nvHqFtw9hC",
      "tab_token": "none",
      "data": {
        "iface_kind": "queue",
        "queue": {
          "id": 2,
          "type": "queue",
          "desc": "example queue",
          "name": "example-step-1",
          "display_name": "Example Step 1",
          "short_desc": "example queue"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got queue 2"
    }
  ],
  "service": [
    {
      "request_id": "wfZqUzdvWAEk46t",
      "tab_token": "none",
      "data": {
        "iface_kind": "service",
        "service": {
          "id": 620,
          "type": "service",
          "desc": "Qorus status information service",
          "lang": "qore",
          "source": "# -*- mode: qore; indent-tabs-mode: nil -*-\n# Qorus System Service Definitions\n\n/*\n  Copyright (C) 2003 - 2023 Qore Technologies, s.r.o., all rights reserved\n\n  **** NOTICE ****\n    All information contained herein is, and remains the property of Qore\n    Technologies, s.r.o. and its suppliers, if any.  The intellectual and\n    technical concepts contained herein are proprietary to Qore Technologies,\n    s.r.o. and its suppliers and may be covered by Czech, European, U.S. and\n    Foreign Patents, patents in process, and are protected by trade secret or\n    copyright law.  Dissemination of this information or reproduction of this\n    material is strictly forbidden unless prior written permission is obtained\n    from Qore Technologies, s.r.o.\n*/\n\n/** @see @ref ::QorusSystemInfoService for method information\n\n    This service provides many methods for retrieving information about Qorus configuration and data.\n\n    This service is used heavily by the Qorus client programs to provide information about metadata and order data\n    status.\n\n    Some methods interface directly with the Qorus server to provide the most up-to-date information possible without\n    having to go first to the database.\n*/\n\n%new-style\n%require-types\n%strict-args\n%enable-all-warnings\n\n%requires SqlUtil\n\n%try-module oracle\n%define NO_ORACLE\n%endtry\n\nconst defaults = {\n    \"row-limit\" : 100,  # maximum number of rows to return in various places\n};\n\nconst Grouping = {\n    \"hourly\": \\cop_year_hour(),\n    \"daily\": \\cop_year_day(),\n    \"monthly\": \\cop_year_month(),\n    \"yearly\": \\cop_year(),\n};\n\nclass OptionHelper {\n    static auto getOption(string opt) {\n        # get service parameters\n        return UserApi::propGet(\"info\"){opt}\n            ?? defaults{opt}\n            ?? OMQ::UserApi::UserApi::getOption(opt);\n    }\n}\n\nclass SQLCommon {\n    public {}\n\n    hash processWorkflowMetadata(softint id) {\n        ServiceApi::checkWorkflowAccess(id);\n\n        return (\n            # keynames\n            \"keylist\"  : omqp.select(\"select keyname from workflow_keys where workflowid = %d\", id).keyname,\n\n            # get steps\n            \"steps\"    : omqp.select(\"select * from steps where stepid in (select stepid from workflow_steps where workflowid = %d)\", id),\n\n            # get step dependencies\n            \"step_deps\": omqp.select(\"select * from workflow_steps where workflowid = %d\", id),\n\n            # get segment dependencies\n            \"seg_deps\" : omqp.select(\"select * from segment_dependencies where workflowid = %d\", id),\n\n            # get segment-step definitions\n            \"seg_steps\": omqp.select(\"select * from segment_steps where workflowid = %d\", id),\n\n            # get option info\n            \"options\"  : omqp.select(\"select * from workflow_options where workflowid = %d\", id),\n\n            # get group info from RBAC cache\n            \"groups\"   : Qorus.rbac.getWorkflowGroups(id),\n        );\n    }\n\n    *list getOrdersFromKey(softstring key, softstring value) {\n        *list rv;\n\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                rv = omqp.selectRows(\"select wi.workflowid, oik.workflow_instanceid from order_instance_keys oik, \"\n                    \"order_instance oi, workflow_instance wi where oi.workflow_instanceid = oik.workflow_instanceid \"\n                    \"and oi.workflow_instanceid = wi.workflow_instanceid and keyname = %v and value = %v\", key, value);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        *hash wah = ServiceApi::getWorkflowAccessHash();\n        if (exists wah)\n            # filter list by visible workflows\n            rv = map $1, rv, (wah.($1.workflowid));\n\n        return rv;\n    }\n\n    *list getWorkflowSummaryOverview(date date, bool useSqlCache = True, bool with_deprecated = True) {\n        *list wfids = ServiceApi::getWorkflowAccessList();\n        if (exists wfids && !wfids)\n            return;\n        return map $1, SnapshotsInfoHelper::getReportWfs(date, wfids, with_deprecated, True).contextIterator();\n    }\n\n    *hash getWorkflowOverview(date date, *softlist wfids, bool useSqlCache = True, bool with_deprecated = True) {\n        if (wfids) {\n            ServiceApi::checkWorkflowAccess(wfids);\n        } else {\n            wfids = ServiceApi::getWorkflowAccessList();\n            if (exists wfids && !wfids)\n                return;\n        }\n        return SnapshotsInfoHelper::getReportWfs(date, wfids, with_deprecated);\n    }\n\n    *hash<auto> getTags(string t, softint id) {\n        *hash q;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                q = omqp.select(\"select tag, value from %s_tags where %sid = %v\", t, t, id);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        *hash h;\n\n        foreach hash<auto> row in (q.contextIterator()) {\n            if (row.tag =~ /^_/) {\n                splice row.tag, 0, 1;\n                h.sys.(row.tag) = row.value;\n            } else {\n                h.(row.tag) = row.value;\n            }\n        }\n\n        return h;\n    }\n\n    *hash<auto> getServiceMetadata(auto args) {\n        if (exists args && exists args[0]) {\n            ServiceApi::checkServiceAccess(args);\n        } else {\n            args = ServiceApi::getServiceAccessList();\n        }\n\n        string sql;\n        if (exists args && exists args[0]) {\n            sql = sprintf(\"select * from services where serviceid in (%s)\",\n                QorusSystemService::compatDeprecatedMakeSelectList(QorusSystemInfoService::qdriver, args));\n        } else {\n            sql = \"select * from services where (name, created) in (select name, max(created) as created from services group by name)\";\n        }\n\n        *hash<auto> h;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                h = omqp.select(sql);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        return h;\n    }\n\n    *hash<auto> getServiceMetadataFromName(string type, string name, *string ver) {\n        type = toupper(type);\n\n        string sql;\n        if (!strlen(ver)) {\n            sql = sprintf(\"select * from services where service_type = '%s' and (name, created) in (select name, max(created) as created from services where name = '%s' group by name)\",\n                           type, name);\n        } else {\n            sql = sprintf(\"select * from services where serviceid in (select serviceid from services where service_type = '%s' and name = '%s' and version = '%s')\", type, name, ver);\n        }\n\n        *hash h;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                h = omqp.select(sql);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        if (elements h.serviceid) {\n            ServiceApi::checkServiceAccess(h.serviceid);\n        }\n\n        return h;\n    }\n\n    *hash<auto> getJobOverview(date date, auto jobids, bool useSqlCache = True) {\n        if (exists jobids) {\n            ServiceApi::checkJobAccess(jobids);\n        } else {\n            jobids = ServiceApi::getJobAccessList();\n        }\n\n        return SnapshotsInfoHelper::getReportJobs(date, jobids);\n    }\n} # class SQLCommon\n\n%ifndef NO_ORACLE\nclass SQLOracle inherits SQLCommon {\n    hash<auto> processWorkflowMetadata(softint workflowid) {\n        ServiceApi::checkWorkflowAccess(workflowid);\n\n        *hash result;\n\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                result = omqp.select(\"begin qorus_system_info.process_workflow_metadata(%v, :keyname, :steps, :step_deps, :seg_deps, :seg_steps, :options, :groups); end;\",\n                                     workflowid, Type::Hash, Type::Hash, Type::Hash, Type::Hash, Type::Hash, Type::Hash, Type::Hash);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex)) {\n                    continue;\n                }\n                rethrow;\n            }\n            break;\n        }\n\n        result.keyname = result.keyname.keyname;\n        result.groups = Qorus.rbac.getWorkflowGroups(workflowid);\n        return result;\n    }\n\n    hash<auto> getServiceMetadata(*softlist args) {\n        if (exists args && exists args[0]) {\n            ServiceApi::checkServiceAccess(args);\n        } else {\n            args = ServiceApi::getServiceAccessList();\n        }\n\n        *hash r;\n\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                on_error omqp.rollback();\n                on_success omqp.commit();\n\n                r = omqp.exec(\"begin qorus_system_info.get_service_metadata(%v, :resultset); end;\",\n                                exists args && exists args[0] ? bindOracleCollection(\"sys.odcinumberlist\", args) : NOTHING, Type::Hash);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex)) {\n                    continue;\n                }\n                rethrow;\n            }\n            break;\n        }\n\n        return r.resultset;\n    }\n\n    hash<auto> getServiceMetadataFromName(string type, string name, *string ver) {\n        *hash r;\n\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                on_error omqp.rollback();\n                on_success omqp.commit();\n\n                r = omqp.exec(\"begin qorus_system_info.get_service_metadata_name(%v, %v, %v, :resultset); end;\",\n                                    type, name, strlen(ver) ? ver : NULL, Type::Hash);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        if (elements r.resultset.serviceid) {\n            ServiceApi::checkServiceAccess(r.resultset.serviceid);\n        }\n\n        return r.resultset;\n    }\n\n} #SQLOracle\n%endif\n\n*hash<auto> sub processMetadata(*hash<auto> q, bool compat, string t) {\n    *hash h;\n\n    string idc;\n    if (t) {\n        idc = t + \"id\";\n    }\n\n    # transform query results into a hash\n    context (q) {\n        h.%name.%version = %%;\n        # delete redundant and empty keys\n        h.%name.%version -= (\"name\", \"version\");\n\n        foreach string k in (keys h.%name.%version) {\n            if (h.%name.%version{k} == NULL && k != \"description\")\n                 delete h.%name.%version{k};\n        }\n\n        if (compat) {\n            h.%name.%version += (\"createdby\": \"omq\", \"modifiedby\": \"omq\");\n        }\n\n        # get tags\n        h.%name.%version.tags = sqlHandler.getTags(t, %%{idc});\n    }\n\n    return h;\n}\n\nhash<auto> sub processJobMetadataRow(hash row) {\n    # delete empty keys\n    foreach string k in (keys row)\n        if (row{k} === NULL && k != \"description\")\n            delete row{k};\n\n    row += (\n        \"jobid\": int(row.jobid),\n        \"sessionid\": int(row.sessionid),\n        \"active\": boolean(row.active),\n        \"run_skipped\": boolean(row.run_skipped),\n        \"groups\": Qorus.rbac.getJobGroups(row.jobid),\n    );\n\n    return row;\n}\n\n*hash<auto> sub processJobMetadata(*hash<auto> q) {\n    *hash h;\n    # transform query results into a hash\n    context (q) {\n        h.%name = processJobMetadataRow(%%) + (\n            # add library info\n            \"lib\": getLibrary(\"job_lib\", \"jobid\", %jobid),\n            \"tags\": sqlHandler.getTags(\"job\", %jobid),\n        );\n    }\n\n    return h;\n}\n\nhash<auto> sub postProcessJobInstance(hash job) {\n    job.job_instanceid = int(job.job_instanceid);\n    job.jobid = int(job.jobid);\n    job.sessionid = int(job.sessionid);\n\n    if (job.completed === NULL)\n        delete job.completed;\n\n    if (job.info === NULL) {\n        delete job.info;\n    } else {\n        job.info = UserApi::deserializeQorusData(job.info);\n    }\n\n    job.jobstatus = OMQ::SQLJSMap.(job.jobstatus);\n\n    return job;\n}\n\nhash<string, list<hash<auto>>> sub getLibrary(string table, string key, softint id) {\n    # prevent possible SQL injections\n    if (!inlist(table, ('workflow_lib', 'service_lib', 'job_lib'))) {\n        throw \"INFO-GET-LIBRARY-ERROR\", sprintf(\"Unallowed table to select from: %s\", table);\n    }\n    if (!inlist(key, ('workflowid', 'serviceid', 'jobid'))) {\n        throw \"INFO-GET-LIBRARY-ERROR\", sprintf(\"Unallowed column to be used in WHERE clause: %s\", key);\n    }\n\n    hash<string, list<hash<auto>>> lib = {\n        \"functions\": (),\n        \"classes\": (),\n        \"constants\": (),\n    };\n    # get library objects\n    string sql = sprintf(\"select * from %s where %s = %v\", table, key);\n\n    *hash<auto> h;\n    QorusRestartableTransaction trans();\n    while (True) {\n        try {\n            # we can just release the lock because the query is read-only\n            on_error omqp.rollback();\n\n            h = omqp.select(sql, id);\n        } catch (hash<ExceptionInfo> ex) {\n            # restart the transaction if necessary\n            if (trans.restartTransaction(ex)) {\n                continue;\n            }\n            rethrow;\n        }\n        break;\n    }\n\n    context (h) {\n        if (%type == OMQ::OT_FUNCTION) {\n            *hash<auto> fi = Qorus.qmm.lookupFuncInfoFromName(%name);\n            lib.functions += {\n                \"name\"    : %name,\n                \"version\" : fi.version,\n                \"id\"      : fi.function_instanceid,\n            };\n        } else if (%type == OMQ::OT_CLASS) {\n            *hash<auto> ci = Qorus.qmm.lookupClassInfoFromName(%name);\n            lib.classes += {\n                \"name\"    : %name,\n                \"version\" : ci.version,\n                \"id\"      : ci.classid,\n            };\n        } else if (%type == OMQ::OT_CONSTANT) {\n            *hash<auto> ci = Qorus.qmm.lookupConstantInfoFromName(%name);\n            lib.constants += {\n                \"name\"    : %name,\n                \"version\" : ci.version,\n                \"id\"      : ci.constantid,\n            };\n        }\n    }\n    return lib;\n}\n\n# change structure to be like old workflow metadata structure with flows\nsub makeCompatWorkflow(reference h, string name, string version) {\n    h.initflowid = h.workflowid;\n    h.createdby = \"omq\";\n    h.modifiedby = \"omq\";\n\n    foreach hash step in (\\h.steps)\n        step += (\"createdby\":\"omq\",\"modifiedby\":\"omq\");\n\n    h.flows[0] = (\n        \"flowid\"            : h.workflowid,\n        \"name\"              : name,\n        \"version\"           : version,\n        \"description\"       : h.description,\n        \"created\"           : h.created,\n        \"createdby\"         : \"omq\",\n        \"modified\"          : h.modified,\n        \"modifiedby\"        : \"omq\",\n        \"steps\"             : h.steps,\n        \"step_dependencies\" : h.step_dependencies,\n        \"flow_segments\"     : h.workflow_segments,\n        \"segments\"          : h.segments\n    );\n\n    if (exists h.patch)\n        h.flows[0].patch = h.patch;\n\n    h.flow_dependencies = (\n        \"flowid\": h.workflowid,\n        \"dependson_flowid\": h.workflowid,\n        );\n\n    delete h.step_dependencies;\n    delete h.workflow_segments;\n    delete h.segments;\n    delete h.steps;\n}\n\n# return old workflow hash structure, with flow information\n*hash sub processWorkflowMetadataCompat(*hash inh) {\n    *hash h = processWorkflowMetadata(inh);\n\n    foreach string name in (keys h) {\n        foreach string version in (keys h{name}) {\n            # fake old structures with flows\n            makeCompatWorkflow(\\h{name}{version}, name, version);\n        }\n    }\n    return h;\n}\n\n*hash sub processWorkflowMetadata(*hash q) {\n    #printf(\"processWorkflowMetadata() q=%y\\n\", q);\n\n    hash h;\n    # transform query results into a hash\n    context wq (q) {\n        # delete redundant and empty keys\n        hash wh = %% - (\"name\", \"version\");\n        foreach string k in (keys wh)\n            if (wh{k} === NULL && k != \"description\")\n                 delete wh{k};\n\n        wh.deprecated = boolean(wh.deprecated);\n        wh.manual_autostart = boolean(wh.manual_autostart);\n\n        *hash result = sqlHandler.processWorkflowMetadata(%workflowid);\n\n        # get workflow keys\n        wh.keylist = result.keyname;\n\n        # get steps\n        wh.steps = ();\n        context (result.steps) { # sq\n            hash s = %%;\n            # delete empty keys\n            foreach string k in (keys s) {\n                if (s{k} === NULL) {\n                    # delete the key if there is no value, unless it's the description\n                    if (k != \"description\")\n                        delete s{k};\n                    else {\n                        # use the primary function's description\n                        hash sh = Qorus.qmm.lookupFunc(%stepfunction_instanceid);\n                        s.description = sh.description;\n                    }\n                }\n            }\n            if (s.workflow_event_typeid) {\n                s.event = Qorus.qmm.lookupEvent(s.workflow_event_typeid) + (\"typeid\": s.workflow_event_typeid);\n                delete s.workflow_event_typeid;\n            }\n            wh.steps += s;\n        }\n\n        # get step dependencies\n        wh.step_dependencies = ();\n        context (result.step_deps)\n            wh.step_dependencies +=\n            ( \"stepid\" : %stepid,\n              \"dependson_stepid\" : %dependson_stepid );\n\n        # get segment dependencies\n        wh.workflow_segments = ();\n        context (result.seg_deps)\n            wh.workflow_segments +=\n            ( \"segmentid\"           : %segmentid,\n              \"dependson_segmentid\" : %dependson_segmentid );\n\n        # get segment-step definitions\n        context (result.seg_steps) {\n            if (!exists wh.segments.%segmentid)\n                wh.segments.%segmentid = ();\n            wh.segments.%segmentid += (\n                \"stepid\": %stepid,\n                \"dependson_stepid\": %dependson_stepid,\n            );\n        }\n\n        # get option info\n        hash opts = map {$1.name: $1.description}, result.options.contextIterator();\n\n        if (opts)\n            wh.options = opts;\n\n        wh += (\n            \"lib\": getLibrary(\"workflow_lib\", \"workflowid\", %workflowid),\n            \"tags\": sqlHandler.getTags(\"workflow\", %workflowid),\n            );\n\n        h.%name.%version = wh;\n    }\n\n    return h;\n}\n\n*hash sub processServiceMetadata(*hash q, bool compat) {\n    hash h;\n\n    SqlUtil::AbstractTable service_methods = QorusSystemService::getSqlTableSystemTrans(\"omq\", \"service_methods\");\n\n    # transform query results into a hash\n    context (q) {\n        h.%name.%version = %% + {\n            \"autostart\": boolean(%autostart),\n            \"manual_autostart\": boolean(%manual_autostart),\n        };\n\n        if (compat) {\n            h.%name.%version += (\"createdby\": \"omq\", \"modifiedby\": \"omq\");\n        }\n\n        # delete redundant and empty keys\n        h.%name.%version -= (\"name\", \"version\");\n\n        # return class_source as class_based\n        h.%name.%version.class_based = exists remove h.%name.%version.class_source;\n\n        foreach string k in (keys h.%name.%version) {\n            if (h.%name.%version{k} == NULL && k != \"description\") {\n                 delete h.%name.%version{k};\n            }\n\n        }\n\n        # get method information\n        list l = ();\n        ServiceApi::checkServiceAccess(%serviceid);\n\n        hash<auto> sql = {\n            \"columns\" : (\n                \"service_methodid\", \"name\", \"description\", \"author\", \"locktype\", \"internal\",\n                cop_as(\"writeflag\", \"write\"), \"created\", \"modified\",\n            ),\n            \"where\": {\n                \"serviceid\" : %serviceid,\n            },\n        };\n\n        *hash h;\n\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n                h = service_methods.select(sql);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex)) {\n                    continue;\n                }\n                rethrow;\n            }\n            break;\n        }\n        trans.reset();\n\n        context (h) {\n            hash m = %%;\n            # delete empty keys\n            foreach string k in (keys m) {\n                if (m{k} == NULL && k != \"description\") {\n                    delete m{k};\n                }\n            }\n\n            if (compat) {\n                m += ( \"createdby\" : \"omq\", \"modifiedby\" : \"omq\");\n            }\n\n            m.tags = sqlHandler.getTags(\"service_method\", %service_methodid);\n\n            l += m;\n        }\n\n        h.%name.%version += (\n            \"methods\": l,\n            \"lib\"    : getLibrary(\"service_lib\", \"serviceid\", %serviceid),\n            \"groups\" : Qorus.rbac.getServiceGroups(%serviceid),\n            \"tags\": sqlHandler.getTags(\"service\", %serviceid),\n        );\n    }\n\n    return h;\n}\n\n# list of allowable functions in SQL conditions\nconst SQLWhiteList = (\"to_date\", \"in\");\n\nsub do_cond(reference wcond, string k, *softlist l) {\n    if (l)\n        wcond{k} = l.size() > 1 ? op_in(l) : l[0];\n}\n\n# issue #2920 if there is a single element list and no '%' character, then a string may be returned instead of a hash\nauto sub do_cond_like_string(softlist l) {\n    l = map $1.toString(), l;\n    return l.size() > 1 ? op_in(l) : ((l[0] =~ /%/) ? op_like(l[0]) : l[0]);\n}\n\nsub do_cond_like_string(reference<hash> wcond, string k, *softlist l, *bool force_like) {\n    if (l) {\n        l = map $1.toString(), l;\n        wcond{k} = (l.size() > 1) ? op_in(l) : ((force_like || l[0] =~ /%/) ? op_like(l[0]) : l[0]);\n    }\n}\n\nsub do_cond_like(reference<hash> wcond, string k, *softlist l, *bool force_like) {\n    if (l)\n        wcond{k} = (l.size() > 1) ? op_in(l) : ((force_like || l[0] =~ /%/) ? op_like(l[0]) : l[0]);\n}\n\nsub do_cond_int(reference<hash> wcond, string k, *softlist l) {\n    if (l)\n        wcond{k} = l.size() > 1 ? op_in((map $1.toInt(), l)) : l[0].toInt();\n}\n\nsub do_cond_bool(reference<hash> wcond, string k, auto v, bool use_null = False) {\n    if (exists v)\n        wcond{k} = parse_boolean(v) ? 1 : (use_null ? NULL : 0);\n}\n\n# parses a string to an int or a list of int and returns a where condition hash\nsub do_cond_int_list(reference<hash> wcond, string k, auto v) {\n    if (v.val()) {\n        v = v =~ /,/ ? (map $1.toInt(), v.split(\",\")) : v.toInt();\n        wcond{k} = v.lsize() > 1 ? op_in(v) : v;\n    }\n}\n\n# parses a string to a list or a string with an optional like clause and returns a where condition hash\nsub do_cond_string_like_list(reference<hash> wcond, string k, auto v) {\n    if (v.val()) {\n        if (v =~ /,/)\n            v = map trim($1), v.split(\",\");\n        if (v.lsize() > 1)\n            wcond{k} = op_in(v);\n        else\n            wcond{k} = (v =~ /%/) ? op_like(v) : v;\n    }\n}\n\nsub process_workflow_id_and_name(reference wcond, hash h) {\n    if (h.workflowid && h.workflowid =~ /,/)\n        h.workflowid = h.workflowid.split(\",\");\n    if (h.workflowname) {\n        if (h.workflowname =~ /,/)\n            h.workflowname = h.workflowname.split(\",\");\n        foreach string wfn in (h.workflowname) {\n            *hash<string, int> wh = Qorus.qmm.rLookupWorkflow(wfn);\n            # ensure h.workflowid is a list\n            if (h.workflowid.typeCode() != NT_LIST) {\n                softlist l = h.workflowid;\n                h.workflowid = l;\n            }\n            if (wh) {\n                # add workflowids from name to workflowid list\n                h.workflowid += wh.values();\n            } else if (!h.workflowid) {\n                # otherwise make sure the search fails\n                h.workflowid += -1;\n            }\n        }\n    }\n    *hash<auto> wfah = ServiceApi::getWorkflowAccessHash();\n    if (exists wfah) {\n        if (!wfah)\n            throw \"WORKFLOW-ACCESS-ERROR\", \"user cannot access any workflows\";\n\n        # enforce workflow filter list\n        if (h.workflowid) {\n            list wl = ();\n            map wl += $1, h.workflowid, wfah.$1 || $1 < 0;\n            h.workflowid = wl;\n        }\n    }\n\n    if (h.workflowid) {\n        if (h.workflowid.lsize() > 1)\n            wcond.workflowid = op_in(map $1.toInt(), h.workflowid);\n        else if (h.workflowid.typeCode() == NT_LIST)\n            wcond.workflowid = h.workflowid[0].toInt();\n        else\n            wcond.workflowid = h.workflowid.toInt();\n    }\n}\n\nlist sub get_wfid_list(list l) {\n    list wl = ();\n    bool err;\n    foreach any wfid in (l) {\n        if (wfid != int(wfid)) {\n            # try to get a name and verion\n            *list l1 = (wfid =~ x/([^:]+)?(:(.*)?)?/);\n            my (*string name, *string ver) = (l1[0], l1[2]);\n            # ignore empty or invalid strings\n            if (!name) {\n                continue;\n            }\n\n            try {\n                # lookup workflowid from workflow name; access is filtered afterwards if necessary\n                if (ver) {\n                    wl += Qorus.qmm.getWorkflowId(name, ver);\n                } else {\n                    hash<auto> wh = Qorus.qmm.rLookupWorkflow(name);\n                    wl += wh.values();\n                }\n            } catch (hash<ExceptionInfo> ex) {\n                err = True;\n                ServiceApi::logDebug(\"ignoring reference to unknown workflow %y: %s: %s\", name, ex.err, ex.desc);\n            }\n        } else {\n            wl += wfid.toInt();\n        }\n    }\n    if (err)\n        wl += -1;\n\n    #logDebug(\"get_wfid_list(%y) rv: %y\", l, wl);\n    return wl;\n}\n\nauto sub get_accessible_workflows(*softlist<auto> l) {\n    *hash wfah = ServiceApi::getWorkflowAccessHash();\n\n    auto rl;\n    if (exists wfah) {\n        if (!wfah)\n            throw \"WORKFLOW-ACCESS-ERROR\", \"user cannot access any workflows\";\n\n        if (l) {\n            list wl = map $1, get_wfid_list(l), wfah.$1;\n            rl = wl.size() > 1 ? op_in(wl) : wl[0];\n        } else\n            rl = wfah.size() > 1 ? op_in((map $1.toInt(), keys wfah)) : int(wfah.firstKey());\n    } else if (l) {\n        l = get_wfid_list(l);\n        rl = l.size() > 1 ? op_in(l) : l[0];\n    }\n\n    #logDebug(\"get_accessible_workflows(%y) rv: %y\", l, rl);\n    return rl;\n}\n\n# SQL data operation logger\nsub log_data(string sql, *list args) {\n    ServiceApi::logDebug(\"SQL: %s, args: %y\", sql, args);\n}\n\nconst SqlDataOpt = (\"sqlarg_callback\": \\log_data());\n\n# oracle returns durations in a fraction of a day\n# mysql returns durations in the number of seconds\n# postgresql returns durations as intervals (true durations)\nconst ProcIntervalCols = (map $1 + \"duration\", (\"min\", \"avg\", \"max\")) + (map $1 + \"processing\", (\"min\", \"avg\", \"max\"));\n\n#! the main info service class\nclass QorusSystemInfoService inherits QorusSystemService {\n    public {\n        const SessionColumnMap = {\n            \"id\": \"sessionid\",\n            \"key\": \"instancekey\",\n            \"url\": \"xmlrpc_server\",\n            \"status\": \"sessionstatus\",\n        };\n\n        # setup global sqlHandler object\n        static SQLCommon sqlHandler;\n\n        static string qdriver;\n    }\n\n    #! initializes the info service\n    constructor() {\n        qdriver = omqp.getDriverName();\n\n        switch (qdriver) {\n%ifndef NO_ORACLE\n            case \"oracle\": {\n                sqlHandler = new SQLOracle();\n                break;\n            }\n%endif\n            default: {\n                sqlHandler = new SQLCommon();\n                break;\n            }\n        }\n    }\n\n    #! returns workflow instance status from workflow_instanceid: COMPAT VERSION with fake flow and flow_instance information (removed in Qorus v2); use getWorkflowStatus2() instead\n    /** @param id the workflow_instanceid\n        @deprecated use getWorkflowStatus2() instead\n    */\n    static deprecated *hash getWorkflowStatus(softint id) {\n        *hash h = QorusSystemInfoService::getWorkflowStatus2(id);\n        if (!exists h)\n            return;\n\n        hash fi = (\n            \"flowid\"           : h.workflowid,\n            \"flow_instanceid\"  : h.workflow_instanceid,\n            \"name\"             : h.name,\n            \"version\"          : h.version,\n            \"description\"      : h.description,\n            \"patch\"            : h.patch,\n            \"flowstatus\"       : h.workflowstatus,\n            \"started\"          : h.started,\n            \"completed\"        : h.completed,\n            \"segment_instance\" : h.segment_instance,\n            \"step_instance\"    : h.step_instance,\n            \"createdby\"        : \"omq\",\n            \"modified\"         : h.modified,\n            \"modifiedby\"       : \"omq\"\n            );\n\n        delete h.step_instance;\n        delete h.segment_instance;\n\n        h += (\"createdby\":\"omq\",\"modifiedby\":\"omq\");\n\n        h.flow_instance = list(fi);\n\n        return h;\n    }\n\n    #! returns workflow order data instance status from the workflow_instanceid\n    /** This method will retrieve information directly from the internal server cache if possible, otherwise data is retrieved from the database\n        @param wfiid the workflow_instanceid\n        @return NOTHING if the workflow_instanceid is not valid, otherwise a hash with the following keys:\n        - \\c name: the name of the workflow (metadata)\n        - \\c version: the version of the workflow (metadata)\n        - \\c workflow_instanceid: the instance id of the workflow order data instance\n        - \\c workflowstatus: the status of the workflow (see @ref StatusDescriptions for possible values)\n        - \\c workflowid: the id of the workflow (metadata)\n        - \\c status_sessionid: either 0 (meaning no Qorus application instance 'owns' the data) or the application sessionid that 'owns' the workflow order data instance (see @ref appsessionmodel)\n        - \\c parent_workflow_instanceid: the parent workflow_instanceid if the workflow order data instance is a subworkflow instance\n        - \\c started: the date/time the workflow order data instance was originally created\n        - \\c completed: the date/time the workflow order data instance received status @ref OMQ::StatComplete\n        - \\c custom_status: the custom status for the workflow order data instance, if any\n        - \\c custom_status_desc: the description for the custom status for the workflow order data instance, if any\n        - \\c scheduled: the date/time the order is scheduled for future execution, if any\n        - \\c priority: the priority of the order\n        - \\c segment_instance: a list of hashes for each segment with the following keys:\n        - \\c segmentid: the segment ID\n        - \\c segmentstatus: the status of the segment (see @ref StatusDescriptions for possible values)\n        - \\c created: date/time the segment was created\n        - \\c modified: date/time the segment was last modified\n        - \\c steps: a list of stepids in the segment\n        - \\c step_instance: a hash keyed by stepid of steps in the workflow; each step hash value will have the following keys:\n        - \\c name: name of the step (step metadata)\n        - \\c version: version of the step (step metadata)\n        - \\c steptype: type of the step (step metadata, see @ref StepTypes for possible values)\n        - \\c arraytype: array attribute of the step (step metadata, see @ref StepArrayTypes for possible values)\n        - \\c stepid: id of the step (step metadata)\n        - \\c stepstatus: status of the step (see @ref StatusDescriptions for possible values); note that for array steps with more than 1 element, this will be a composite status according to @ref OMQ::StatusOrder)\n        - \\c started: date/time the step was first created in the DB\n        - \\c completed: date/time the step got status @ref OMQ::StatComplete\n        - \\c custom_status: the custom status for the step, if any\n        - \\c custom_status_desc: the description for the custom status for the step, if any\n        - [\\c event]: only present for event steps; if present, this will be a hash with the following keys:\n            - \\c name: the event type name\n            - \\c desc: the event type description\n            - \\c typeid: the event type id\n            - [\\c key]: if not an arraystep, the event key will be present here\n        - [\\c subworkflow_instanceid]: only present for subworkflow steps: the workflow_instanceid of the subworkflow bound to the step\n        - [\\c subworkflowstatus]: only present for subworkflow steps: the status of the subworkflow instance bound to the step\n        - [\\c substeps]: only present for array steps; if present, this will be a list of hashes with the following keys:\n            - \\c stepid: same as the stepid in the parent data structure\n            - \\c ind: the step index number\n            - \\c stepstatus: the status of the step (see @ref StatusDescriptions for possible values)\n            - \\c started: date/time the step was first created in the DB\n            - \\c completed: date/time the step got status @ref OMQ::StatComplete\n            - \\c eventkey: the eventkey bound to the step, if any\n            - \\c custom_status: the custom status for the step, if any\n            - \\c custom_status_desc: the description for the custom status for the step, if any\n        - \\c errors: a list of hashes with the following keys for errors raised while processing the workflow order data instance\n        - \\c stepid: the stepid of the step that created the error\n        - \\c ind: the index of the step\n        - \\c severity: severity of the error: @ref ErrorSeverityCodes\n        - \\c error: the error code\n        - \\c description: description of the error\n        - \\c info: information about the error\n        - \\c business_error: True if the error is a business error, False if not\n        - \\c created: the date/time the error was raised\n        - \\c workflow_instanceid: the same as the workflow_instanceid of the parent data structure\n        @throw WORKFLOW-ACCESS-ERROR this is exeption is thrown when @ref RBAC is enabled; the call is made from the network, and the user does not have the right to access the given workflow\n    */\n    static *hash getWorkflowStatus2(softstring wfiid) {\n        # workflow access checked in SegmentManager\n        return SM.getWorkflowInstanceStatus(wfiid);\n    }\n\n    #! returns order instance info from workflow_instanceid\n    static *hash getOrderInfo(softstring wfiid) {\n        # workflow access checked in SegmentManager\n        return SM.getOrderInfoSummary(wfiid);\n    }\n\n    #! returns order instance info from external_order_instanceid\n    static *list getOrderInfoFromExternalID(softstring id) {\n        # workflow access checked in SegmentManager\n        return SM.getOrderInfoSQL(\"external_order_instanceid\", id);\n    }\n\n    #! returns order instance info from user order key (params: workflowname, workflowversion, keyname, value)\n    softlist getOrderInfoFromKey(string name, string version, softstring key, softstring value) {\n        # get workflowid\n        *softint wfid = Qorus.qmm.rLookupWorkflow(name, version);\n\n        if (!wfid) {\n            throw \"UKNOWN-WORKFLOW\", sprintf(\"no workflow exists with name='%s', version='%s'\", name, version);\n        }\n\n        checkWorkflowAccess(wfid);\n\n        hash sql = (\n            \"columns\" : (\"workflow_instanceid\"),\n            \"where\"   : (\n                \"workflowid\" : wfid,\n                \"keyname\"    : key,\n                \"value\"      : value,\n            ),\n        );\n        SqlUtil::AbstractTable order_instance_keys = getSqlTableSystemTrans(\"omq\", \"order_instance_keys\");\n        *list wfiids;\n\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                wfiids = order_instance_keys.select(sql).workflow_instanceid;\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        return map SM.getOrderInfoSummary($1), wfiids;\n    }\n\n    #! returns order instance info from the key and value\n    static softlist getOrdersFromKey(softstring key, softstring value) {\n        # get workflow_instanceids\n        *list l = sqlHandler.getOrdersFromKey(key, value);\n        return map SM.getOrderInfoSummary($1.workflow_instanceid), l;\n    }\n\n    #! returns order instance info from the workflow name, key, and value\n    /** @return @ref nothing if there is no match or a list of hashes with the following keys:\n        - \\c workflowid\n        - \\c workflow_instanceid\n    */\n    *list getWorkflowListFromWorkflowKey(string workflow, softstring key, softstring value) {\n        *list l;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                l = omqp.selectRows(\"select wi.workflowid, oik.workflow_instanceid from order_instance_keys oik, \"\n                    \"order_instance oi, workflow_instance wi, workflows w where \"\n                    \"oi.workflow_instanceid = oik.workflow_instanceid \"\n                    \"and oi.workflow_instanceid = wi.workflow_instanceid and keyname = %v \"\n                    \"and value = %v and wi.workflowid = w.workflowid and w.name = %v\", key, value, workflow);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        if (l) {\n            checkWorkflowAccess((map $1.workflowid, l));\n        }\n\n        return l;\n    }\n\n    #! returns all information about a workflow from a user order key (params: workflowname, workflowversion, keyname, value)\n    hash getAllInfoFromOrderKey(string name, string version, softstring key, softstring value) {\n        hash rv.order = getOrderInfoFromKey(name, version, key, value);\n        rv.workflows = ();\n\n        # now retrieve workflow information\n        foreach hash wf in (rv.order.workflows)\n            rv.workflows += getWorkflowStatus(wf.workflow_instanceid);\n\n        return rv;\n    }\n\n    #! gets workflow overview, params: [date, [workflowids]]: If no date is given, default = last 24 hours\n    /**\n        @throw PARAMETER-ERROR the date passed was not valid\n\n        @param date optional, order instance modified threshold. Items modified in last day are used if it's not given.\n        @param wfids optional, list of workflow IDs (not order instances) to be used in search criteria\n        @param useSqlCache optional, default True. Unused/deprecated.\n        @param with_deprecated if False then no workflows with the deprecated flag set are returned\n\n        @return hash or nothing - grouped information about workflow statuses\n    */\n    static *hash<auto> getWorkflowOverview(softdate date = now() - 1D, *softlist wfids, softbool useSqlCache = True, softbool with_deprecated = True) {\n        # check parameters\n        if (date < 1000-01-01)\n            throw \"PARAMETER-ERROR\", sprintf(\"first parameter must be a valid date or NOTHING (given: %y)\", date);\n\n        *hash rv;\n        *hash<auto> q = sqlHandler.getWorkflowOverview(date, wfids, useSqlCache, with_deprecated);\n        context (q) sortBy (%name) {\n            rv.%name.%version.workflowid = %workflowid;\n            int t = int(%total);\n            rv.%name.%version.(OMQ::SQLStatMap.%workflowstatus) = t;\n            rv.%name.%version.TOTAL += t;\n        }\n\n        ServiceApi::logDebug(\"getWorkflowOverview() date: %y wfids: %y cache: %y dep: %y\", date, wfids,\n            useSqlCache, with_deprecated);\n\n        return rv;\n    }\n\n    #! gets workflow overview, params: [date, [name, [version]]]: If no date is given, default = last 24 hours\n    /**\n        @throw PARAMETER-ERROR the date passed was not valid\n        @param date optional, order instance modified threshold. Items modified in last day are used if it's not given.\n        @param name optional workflow name to be used in search criteria\n        @param version optional workflow version to be used in search criteria\n        @param useSqlCache optional, default True. Unused/deprecated.\n        @param with_deprecated if False then no workflows with the deprecated flag set are returned\n\n        @return hash or nothing - grouped information about workflow statuses\n    */\n    static *hash getWorkflowOverviewFromName(softdate date = now() - 1D, *string name, *string version, softbool useSqlCache = True, softbool with_deprecated = True) {\n        # check parameters\n        if (date < 1000-01-01)\n            throw \"PARAMETER-ERROR\", sprintf(\"first parameter must be a valid date (given: %y)\", date);\n\n        auto wfids;\n        if (exists name) {\n            *hash<string, int> wi = Qorus.qmm.rLookupWorkflow(name);\n            if (exists version) {\n                if (!exists wi{version})\n                    throw \"UNKNOWN-WORKFLOW\", sprintf(\"workflow %s:%s does not exist\", name, version);\n                wfids = wi{version}.workflowid;\n            } else {\n                if (!wi)\n                    throw \"UNKNOWN-WORKFLOW\", sprintf(\"workflow %s does not exist\", name);\n                wfids = wi.values();\n            }\n            wfids = exists version ? wi{version} : wi.values();\n            #UserApi::logDebug(\"getWorkflowOverviewFromName() name: %y wi: %y wfids: %y\", name, wi, wfids);\n        }\n\n        return QorusSystemInfoService::getWorkflowOverview(date, wfids, useSqlCache, with_deprecated);\n    }\n\n    #! gets system overview, params: [date]: If no date is given, default = last 24 hours\n    /**\n        @throw PARAMETER-ERROR the date passed was not valid\n\n        @param date optional, order instance modified threshold. Items modified in last day are used if it's not given.\n        @param useSqlCache optional, default True. Unused/deprecated.\n        @param with_deprecated if False then no workflows with the deprecated flag set are returned\n\n        @return hash or nothing - summary workflow status information\n    */\n    static *list getWorkflowSummaryOverview(softdate date = now() - 1D, softbool useSqlCache = True, softbool with_deprecated = True) {\n        # check parameters\n        if (date < 1000-01-01)\n            throw \"PARAMETER-ERROR\", sprintf(\"first parameter must be a valid date or NOTHING (given: %y)\", date);\n\n        return sqlHandler.getWorkflowSummaryOverview(date, useSqlCache, with_deprecated);\n    }\n\n    #! gets workflow metadata (optional params: list of IDs), returns: hash of workflow metadata keyed by name and then version: COMPAT VERSION with fake flow information (removed in Qorus v2); use getWorkflowMetadata2() instead\n    /** @deprecated use getWorkflowMetadata2() instead\n    */\n    deprecated *hash getWorkflowMetadata() {\n        hash sql = (\n            \"where\" : (exists argv ? (\"workflowid\" : op_in(argv)) : {}),\n        );\n        AbstractTable wfs = getSqlTableSystemTrans(\"omq\", \"workflows\");\n        *hash rv;\n\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                rv = wfs.select(sql);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        return processWorkflowMetadataCompat(rv);\n    }\n\n    #! gets workflow metadata (optional params: list of IDs), returns: hash of workflow metadata keyed by name and then version\n    /** @return NOTHING if the workflowids are not valid, otherwise a hash keyed by workflow name where the values are hases keyed by workflow version with values as hashes of workflow information having the following keys:\n        - \\c workflowid: the id of the workflow\n        - \\c patch: the \\c \"patch\" value of the workflow\n        - \\c description: the description of the workflow\n        - \\c errorfunction_instanceid: id of the @ref dep_errorfunction\n        - \\c attach_func_instanceid: id of the @ref dep_attach\n        - \\c onetimeinit_func_instanceid: id of the @ref dep_onetimeinit\n        - \\c created: the date/time the workflow was created in the DB\n        - \\c modified: the date/time the workflow was last modified in the DB\n        - \\c keylist: either NOTHING or a list of valid @ref wf_keylist \"workflow order keys\"\n        - \\c steps: a list of step hashes defining the steps in the workflow; each step hash will have the following keys:\n        - \\c stepid: the stepid of the step\n        - \\c steptype: type of the step (see @ref StepTypes for possible values)\n        - \\c arraytype: array attribute of the step (see @ref StepArrayTypes for possible values)\n        - \\c name: name of the step\n        - \\c version: version of the step\n        - [\\c patch]: the \\c \"patch\" value of the step\n        - \\c description: description of the step\n        - \\c stepfunction_instanceid: id of the @ref dep_primarystepfunc\n        - [\\c validationfunction_instanceid]: id of the @ref dep_validationfunc\n        - [\\c endfunction_instanceid]: id of the @ref dep_asyncbackendfunc for asynchronous steps\n        - [\\c arrayfunction_instanceid]: id of the @ref dep_arrayfunc for array steps\n        - [\\c queueid]: id of the @ref queue_objects \"asynchronous queue\" for asynchronous steps\n        - \\c created: the date/time the step was created in the DB\n        - \\c modified: the date/time the step was last modified in the DB\n        - [\\c event]: a hash of event information (present if the steptype = @ref OMQ::ExecEvent):\n            - \\c name: name of the event type\n            - \\c desc: description of the event type\n            - \\c typeid: the event type ID\n        - \\c step_dependencies: a list of hashes of step dependencies with the following keys:\n        - \\c stepid: the stepid of the step\n        - \\c dependson_stepid: the stepid of the step that the step depends on (note that if a hash has \\c stepid = \\c dependson_stepid, then the step has no dependencies)\n        - \\c workflow_segments: a list of hashes of segment dependencies with the following keys:\n        - \\c segmentid: the segmentid of the segment\n        - \\c dependson_segmentid: the segnentid of the segment that the segment depends on (note that if a hash has \\c segmentid = \\c dependson_segmentid, then the segment has no dependencies)\n        - \\c segments: a hash of segments where the keys are segmentids and the values are step dependency lists within that segment; the step dependency list elements are hashes with the following keys:\n        - \\c stepid: the stepid of the step\n        - \\c dependson_stepid: the stepid of the step that the step depends on (note that if a hash has \\c stepid = \\c dependson_stepid, then the step has no dependencies within the given segment)\n        - \\c options: a hash of options where the keys are the option names, and the values are the option descriptions\n        - \\c lib: a hash keyed by library object type (key values: \\c \"functions\", \\c \"classes\", \\c \"constants\"); the value of each key will be a list of hashes with the following keys (empty lists mean no objects of that type are listed as library objects of the workflow):\n        - \\c name: the name of the library object\n        - \\c version: the version of the library object\n        - \\c id: the ID of the library object (referencing the tables, \\c FUNCTION_INSTANCE, \\c CLASSES, or \\c CONSTANTS)\n        - \\c groups: a list of RBAC group names that this service is a member of\n\n        @throw WORKFLOW-ACCESS-ERROR this is exeption is thrown when @ref RBAC is enabled; the call is made from the network, and the user does not have the right to access the given workflow\n\n        @note if this method is called externally, and the user has a limited list of accessible workflows, then only information about the workflows the user can access is returned; if the user requests a particular workflow and does not have access to that workflow, then a \\c WORKFLOW-ACCESS-ERROR exception is raised\n    */\n    *hash getWorkflowMetadata2() {\n        hash sql = {\n            \"where\" : (exists argv ? (\"workflowid\" : op_in(argv)) : {}),\n        };\n        AbstractTable wfs = getSqlTableSystemTrans(\"omq\", \"workflows\");\n        *hash rv;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                rv = wfs.select(sql);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        return processWorkflowMetadata(rv);\n    }\n\n    #! gets workflow metadata from name and version (params: name, optional: version), returns: hash of workflow metadata keyed by name and then version: COMPAT VERSION with fake flow information; use getWorkflowMetadataFromName2() instead\n    /** @deprecated use getWorkflowMetadataFromName2() instead\n\n        @throw WORKFLOW-ACCESS-ERROR this is exeption is thrown when @ref RBAC is enabled; the call is made from the network, and the user does not have the right to access the given workflow\n\n        @note if this method is called externally, and the user has a limited list of accessible workflows, then only information about the workflows the user can access is returned; if the user requests a particular workflow and does not have access to that workflow, then a \\c WORKFLOW-ACCESS-ERROR exception is raised\n    */\n    *hash getWorkflowMetadataFromName(string name, *string ver) {\n        hash sql = {\n            \"where\" : (\n                \"name\" : name,\n            ) + (strlen(ver) ? (\"version\" : ver) : {}),\n        };\n        AbstractTable wfs = getSqlTableSystemTrans(\"omq\", \"workflows\");\n        *hash rv;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                rv = wfs.select(sql);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex)) {\n                    continue;\n                }\n                rethrow;\n            }\n            break;\n        }\n\n        if (elements rv.workflowid) {\n            checkWorkflowAccess(rv.workflowid);\n        }\n\n        return processWorkflowMetadataCompat(rv);\n    }\n\n    #! gets workflow metadata from name and version (params: name, optional: version), returns: hash of workflow metadata keyed by name and then version, new version without flows (removed in Qorus v2)\n    /** @param name the name of the workflow\n        @param ver the optional version of the workflow to return\n        @return see getWorkflowMetadata2() for the definition of the hash returned\n\n        @throw WORKFLOW-ACCESS-ERROR this is exeption is thrown when @ref RBAC is enabled; the call is made from the network, and the user does not have the right to access the given workflow\n\n        @note if this method is called externally, and the user has a limited list of accessible workflows, then only information about the workflows the user can access is returned; if the user requests a particular workflow and does not have access to that workflow, then a \\c WORKFLOW-ACCESS-ERROR exception is raised\n    */\n    *hash getWorkflowMetadataFromName2(string name, *string ver) {\n        hash sql = (\n            \"where\" : (\n                \"name\" : name,\n            ) + (strlen(ver) ? (\"version\" : ver) : {}),\n        );\n        AbstractTable wfs = getSqlTableSystemTrans(\"omq\", \"workflows\");\n        *hash rv;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                rv = wfs.select(sql);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        if (elements rv.workflowid) {\n            checkWorkflowAccess(rv.workflowid);\n        }\n\n        return processWorkflowMetadata(rv);\n    }\n\n    #! retrieves function data from the function_instanceid (params: function_instanceid), returns: hash of function data keyed by name and then version\n    *hash getFunctionInstance(softint fiid, *softdate date) {\n        if (!fiid)\n            throw \"PARAMETER-ERROR\", \"function_instanceid is a required parameter for info.getFunctionInstance()\";\n\n        hash sql = (\n            \"where\" : (\n                \"function_instanceid\" : fiid,\n            ) + (exists date ? (\"modified\" : op_gt(date)) : {}),\n        );\n        SqlUtil::AbstractTable function_instance = getSqlTableSystemTrans(\"omq\", \"function_instance\");\n        *hash result;\n\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                result = function_instance.select(sql);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        return processMetadata(result, True, \"function_instance\");\n    }\n\n    #! retrieves function data from the name and optionally the version (params: name, [version]), returns: hash of function data keyed by name and then version\n    *hash getFunctionInstanceFromName(string name, *string ver) {\n        hash sql = {\n            \"where\" : (\n                \"name\" : name,\n            ) + (strlen(ver) ? (\"version\" : ver) : {}),\n        };\n        SqlUtil::AbstractTable function_instance = getSqlTableSystemTrans(\"omq\", \"function_instance\");\n        *hash result;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                result = function_instance.select(sql);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        return processMetadata(result, True, \"function_instance\");\n    }\n\n    #! retrieves method data from the service_methodid (params: service_methodid), returns: hash of method data\n    /** @param mid the method ID\n        @param date if this date is present, then information will only be returned if the method has been modified after the given date\n        @return NOTHING if no data is available, or a hash with the following info:\n        - \\c service_methodid: the method ID (corresponding to the mid argument)\n        - \\c serviceid: the ID of the service\n        - \\c name: the method name\n        - \\c description: the method description\n        - \\c locktype: the lock attribute for the method, see @ref MethodLockAttributes for possible values\n        - \\c internal: a flag where 0 = not internal, 1 = internal\n        - \\c body: the method body\n        - \\c created: the create date/time of the method record\n        - \\c modified: the modification date/time of the method record\n        - \\c write: a flag where 0 = not write, 1 = write\n        - \\c tags: any service method tags; the special tag \\c \"sys\" is a hash with system tags\n\n        @throw SERVICE-ACCESS-ERROR @ref RBAC is enabled and the user does not have access to the given service\n\n        @note if this method is called externally, and the user does not have access to the given service, then a \\c SERVICE-ACCESS-ERROR exception is raised\n    */\n    *hash getServiceMethod2(softint mid, *softdate date) {\n        hash sql = (\n            \"where\" : (\n                \"service_methodid\" : mid,\n            ) + (exists date ? (\"modified\" : op_gt(compatDeprecatedDbDate(qdriver, date))) : {}),\n        );\n        SqlUtil::AbstractTable wfs = getSqlTableSystemTrans(\"omq\", \"service_methods\");\n        *hash q;\n\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                q = wfs.selectRow(sql);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        if (q) {\n            checkServiceAccess(q.serviceid);\n        } else {\n            return;\n        }\n\n        # process query results\n        # delete empty keys\n        foreach string k in (keys q) {\n            if (q{k} == NULL && k != \"description\") {\n                delete q{k};\n            }\n        }\n\n        # rename \"writeflag\" column to \"write\" if present\n        if (q.writeflag) {\n            q.write = remove q.writeflag;\n        }\n\n        q.tags = sqlHandler.getTags(\"service_method\", mid);\n\n        return q;\n    }\n\n    #! retrieves method data from the service_methodid (params: service_methodid), returns: hash of method data\n    /** @deprecated use getServiceMethod2() instead; this method is the same but provides 2 additional hardcoded fields for backwards-compatibility\n\n        @param mid the method ID\n        @param date if this date is present, then information will only be returned if the method has been modified after the given date\n        @return NOTHING if no data is available, or a hash with the same keys as the return value of getServiceMethod2() with 2 additional hardcoded fields:\n        - \\c createdby: hardcoded to \\c \"omq\"\n        - \\c modifiedby: hardcoded to \\c \"omq\"\n\n        @throw SERVICE-ACCESS-ERROR @ref RBAC is enabled and the user does not have access to the given service\n\n        @note if this method is called externally, and the user does not have access to the given service, then a \\c SERVICE-ACCESS-ERROR exception is raised\n    */\n    *hash getServiceMethod(softint mid, *softdate date) {\n        *hash h = getServiceMethod2(mid, date);\n\n        if (h)\n            return h + ( \"createdby\" : \"omq\", \"modifiedby\" : \"omq\" );\n    }\n\n    #! retrieves service metadata (optional params: list of service ids), returns: service info keyed by name. NOTE: if no list is given, only the latest version of each service will be returned\n    static *hash getServiceMetadata() {\n        # service access is checked in getServiceMetadata\n        *hash r = sqlHandler.getServiceMetadata(argv);\n        if (r)\n            return processServiceMetadata(r, True);\n    }\n\n    #! retrieves service metadata from the type, name and optional version (params: type, name, [version]), returns: service info keyed by name. NOTE: if no version is given, only the latest version will be returned\n    static *hash getServiceMetadataFromName(string type, string name, *string ver) {\n        if (!type)\n            throw \"PARAMETER-ERROR\", \"type is a required parameter for info.getServiceMetadataFromName() (try 'system' or 'user')\";\n\n        if (!name)\n            throw \"PARAMETER-ERROR\", \"name is a required parameter for info.getServiceMetadataFromName()\";\n\n        type = type.upr();\n        # service access is checked in getServiceMetadataFromName\n        *hash r = sqlHandler.getServiceMetadataFromName(type, name, ver);\n        if (r)\n            return processServiceMetadata(r, True);\n    }\n\n    #! retrieves function library information as a list of hashes with the keys name, function_instanceid\n    static list getLibraryMetadata() {\n        return omqp.selectRows(\"select name, function_instanceid from function_instance where function_type = 'GENERIC' order by name\");\n    }\n\n    #! gets a list of workflow instance ids (not more than 100 by default, can be overridden with the 4th argument), params: workflowid (single value, list, or NOTHING), date, [statuses, num rows]\n    *list getWorkflowInstanceList(*softlist workflowid, *softdate date = now() - 1D, auto stati, softint rownum = OptionHelper::getOption(\"row-limit\")) {\n        # check parameters\n\n        if (!exists workflowid) {\n            workflowid = getWorkflowAccessList();\n        }\n\n        if (!rownum)\n            rownum = OptionHelper::getOption(\"row-limit\");\n\n        if (date < 1000-01-01)\n            throw \"PARAMETER-ERROR\", sprintf(\"first parameter must be a valid date (given: %y)\", date);\n\n        foreach auto status in (stati) {\n            if (!OMQ::StatMap{status})\n                throw \"PARAMETER-ERROR\", sprintf(\"%y is not a valid workflow status (valid statuses: %y)\", status, OMQ::StatMap.keys());\n        }\n\n        if (exists workflowid) {\n            checkWorkflowAccess(workflowid);\n        }\n\n        # map workflow statuses to SQL statuses\n        stati = map OMQ::StatMap.$1, stati;\n\n        hash sql = (\n            \"columns\": (\"workflow_instanceid\"),\n            \"where\": (\n                \"modified\": op_ge(date),\n            ) + (exists stati ? (\"workflowstatus\" : op_in(stati)) : {}),\n            \"limit\": rownum,\n        );\n        if (workflowid) {\n            sql.\"where\".workflowid = op_in(workflowid);\n        }\n        SqlUtil::AbstractTable workflow_instance = getSqlTableSystemTrans(\"omq\", \"workflow_instance\");\n\n        *list l;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                l = workflow_instance.select(sql).workflow_instanceid;\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex)) {\n                    continue;\n                }\n                rethrow;\n            }\n            break;\n        }\n\n        return l;\n    }\n\n    #! gets a list of workflow instance ids; this is the safe and preferred variant of this method\n    /** This is the preferred variant of this method, using safe SQL handling; oview uses this variant\n\n        @param wfids a list of WF ids (or names) or NOTHING\n        @param statuses a list with requested statuses in expanded form ('ERROR') or NOTHING\n        @param modified a limit (>=) for MODIFIED columnn or NOTHING\n        @param rownum limit for max rows\n        @param offset the starting row\n        @param sort the sorting key for SQL \\c \"order by\"\n        @param wfiids zero or more workflow_instanceids to use to filter the results\n        @param desc sort the results descending\n        @param minstarted the minstarted date\n        @param maxstarted the maxstarted date\n    */\n    list getWorkflowInstances(*softlist wfids, *list statuses, *softdate modified, softint rownum = OptionHelper::getOption(\"row-limit\"), *int offset, *softlist sort, *softlist wfiids, *softbool desc, *date minstarted, *date maxstarted) {\n        logDebug(\"getWorkflowInstances: wfids: %y statuses: %y mod: %y rownum: %y sort: %y offset: %y wfiids: %y desc: %y\", wfids, statuses, modified, rownum, sort, offset, wfiids, desc);\n\n        AbstractTable workflows = Qorus.dsmanager.getOmqTable(\"workflows\");\n        AbstractTable workflow_instance = Qorus.dsmanager.getOmqTable(\"workflow_instance\");\n\n        if (sort) {\n            # process sort keys\n            bool hwf;\n            foreach string k in (\\sort) {\n                k = k.lwr();\n                if (!workflows.describe().hasKey(k) && !workflow_instance.describe().hasKey(k))\n                    throw \"ORDER-SORT-ERROR\", sprintf(\"sort key %y is not valid; valid keys: %y\", k, (workflows.describe().getHash() + workflow_instance.describe().getHash()).keys());\n                if (k == \"workflow_instanceid\")\n                    hwf = True;\n            }\n\n            # the sort key must also have a unique column to ensure consistent sort order\n            if (!hwf)\n                sort += \"workflow_instanceid\";\n        }\n\n        hash wcond;\n\n        if (wfiids)\n            wcond.workflow_instanceid = op_in(wfiids);\n\n        if (statuses)\n            wcond.workflowstatus = op_in(map OMQ::StatMap.$1, statuses);\n\n        if (exists modified)\n            wcond.modified = op_ge(modified);\n\n        if (minstarted)\n            wcond.started = op_ge(minstarted);\n        if (maxstarted)\n            wcond.\"1:started\" = op_lt(maxstarted);\n\n        *hash wfah = getWorkflowAccessHash();\n        list wl = ();\n        if (exists wfah) {\n            if (!wfah)\n                throw \"WORKFLOW-ACCESS-ERROR\", \"user cannot access any workflows\";\n\n            if (wfids) {\n                foreach auto e in (wfids) {\n                    softint id;\n                    if (e =~ /[a-z]/i)\n                        id = Qorus.qmm.getWorkflowId(e);\n                    else\n                        id = e;\n                    if (wfah{id})\n                        wl += id;\n                }\n            } else\n                wl = wfah.keys();\n        } else if (wfids)\n            wl = wfids;\n\n        if (wl) {\n            list wnl = ();\n            list wil = ();\n            foreach auto e in (wl) {\n                if (e =~ /[a-z]/i)\n                    wnl += e;\n                else\n                    wil += e;\n            }\n            if (wil)\n                wcond.workflowid = op_in(wil);\n            if (wnl)\n                wcond.\"w.name\" = op_in(wnl);\n        }\n\n        hash sh = (\n            \"comment\": \"qorus.info.getWorkflowInstances\",\n            \"columns\": (\"w.name\", \"w.version\", \"workflow_instanceid\", \"workflowid\", \"workflowstatus\", \"status_sessionid\", \"started\", \"completed\", \"modified\", \"parent_workflow_instanceid\", \"synchronous\", \"business_error\", \"operator_lock\", \"note_count\", cop_as(\"warnings\", \"warning_count\"), cop_as(\"errors\", \"error_count\"), \"custom_status\", \"priority\", \"scheduled\"),\n            \"where\": wcond,\n            \"join\": join_inner(workflows, \"w\"),\n            \"limit\": rownum,\n            \"offset\": offset,\n            \"orderby\": sort,\n            \"desc\": desc,\n        );\n\n        #logDebug(\"SH: %N opt: %y\", sh, SqlDataOpt);\n\n        *list sqlresult;\n\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                sqlresult = workflow_instance.selectRows(sh, SqlDataOpt);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessar\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        if (sqlresult)\n            sqlresult = SM.processWorkflowResults(sqlresult);\n\n        return sqlresult;\n    }\n\n    #! gets a list of workflow instance ids, params: workflowid, condition, number of rows (100 default)\n    /** @param workflowid a WF id or 0\n        @param condition a string with any SQL condition used in WHERE clause\n        @param rownum limit for max rows\n\n        @deprecated use the variant taking a workflow ID list instead\n    */\n    deprecated list getWorkflowInstances(softint workflowid, *string condition, int rownum = OptionHelper::getOption(\"row-limit\")) {\n        logDebug(\"getWorkflowInstances: wfid: %y condition: %y rownum: %y\", workflowid, condition, rownum);\n\n        # wfiid related condition - all use %v binding from workflowidsqlBind\n        string workflowidsql;\n        # a value holder to be bound in workflowidsql later\n        auto workflowidsqlBind;\n\n        if (!rownum)\n            rownum = OptionHelper::getOption(\"row-limit\");\n\n        if (workflowid > 0) {\n            checkWorkflowAccess(workflowid);\n            workflowidsql = \" where wi.workflowid = %v \";\n            workflowidsqlBind = int(workflowid);\n        }\n        # TODO/FIXME: test this case\n        else if (exists (*list wfl = getWorkflowAccessList())) {\n            if (exists wfl && !elements wfl)\n                throw \"WORKFLOW-ACCESS-ERROR\", \"user cannot access any workflows\";\n            if (qdriver == \"oracle\") {\n                workflowidsql = \" where wi.workflowid in (\n                                select column_value\n                                    from table(cast(in_transform_number(%v) as num_array))\n                            ) \";\n            } else {\n                workflowidsql = \" where wi.workflowid in (%s) \";\n            }\n            workflowidsqlBind = compatDeprecatedMakeSelectList(qdriver, wfl);\n        } else {\n            # failsafe - binding failback for no value required.\n            workflowidsql = \" where %v=1 \";\n            workflowidsqlBind = 1;\n        }\n\n        hash h;\n        if (exists condition) {\n            h = processCondition(\\condition);\n            if (strlen(condition))\n                splice condition, 0, 0, \" and \";\n        }\n\n        string sql = sprintf(\"select wi.WORKFLOW_INSTANCEID, wi.WORKFLOWID,\n    wi.WORKFLOWSTATUS, wi.STATUS_SESSIONID, wi.STARTED, wi.COMPLETED,\n    wi.MODIFIED, wi.PARENT_WORKFLOW_INSTANCEID, wi.SYNCHRONOUS, wi.business_error,\n    wi.ARCHIVE, wi.WARNINGS as \\\"warning_count\\\", wi.ERRORS as \\\"error_count\\\", wi.custom_status, priority, scheduled, operator_lock, note_count\n    from workflow_instance wi %s %s %s%s%s\",\n                h.join_oi ? \"join order_instance oi on wi.WORKFLOW_INSTANCEID = oi.WORKFLOW_INSTANCEID\" : \"\",\n                h.join_oik ? \"left join order_instance_keys oik on wi.WORKFLOW_INSTANCEID = oik.WORKFLOW_INSTANCEID\" : \"\",\n                workflowidsql,\n                condition,\n                qdriver == \"oracle\" ? \" and rownum <= %v\" : \" limit %v\"\n        );\n    #    logInfo(\"SQL: %s\\nARGs: %N %N\", sql, workflowidsqlBind, rownum);\n        *list sqlresult;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                sqlresult = omqp.selectRows(sql, workflowidsqlBind, rownum);\n                #printf(\"sql=%s\\nresult=%y\\n\", sql, sqlresult);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                throw \"DATABASE_ERROR\", sprintf(\"%s %s: SQL: %y\", ex.err, ex.desc, sql);\n            }\n            break;\n        }\n\n        if (sqlresult)\n            sqlresult = SM.processWorkflowResults(sqlresult, True);\n\n        return sqlresult;\n    }\n\n    #! retrieves workflow instances from a key value and optional key name\n    *list getWorkflowInstancesByKeyValue(softlist val, *softstring key, *softlist wfids, *softlist statuses, *date modified, softint rownum = OptionHelper::getOption(\"row-limit\"), *int offset, *softlist sort, *softlist wfiids, *softbool desc, *date minstarted, *date maxstarted) {\n        logDebug(\"getWorkflowInstancesBtKeyValue: val: %y key: %y wfids: %y statuses: %y mod: %y rownum: %y sort: %y offset: %y wfiids: %y desc: %y\", val, key, wfids, statuses, modified, rownum, sort, offset, wfiids, desc);\n\n        AbstractTable workflows = Qorus.dsmanager.getOmqTable(\"workflows\");\n        AbstractTable workflow_instance = Qorus.dsmanager.getOmqTable(\"workflow_instance\");\n        AbstractTable order_instance_keys = Qorus.dsmanager.getOmqTable(\"order_instance_keys\");\n\n        if (sort) {\n            # process sort keys\n            bool hwf;\n            foreach string k in (\\sort) {\n                k = k.lwr();\n                if (!workflows.describe().hasKey(k) && !workflow_instance.describe().hasKey(k))\n                    throw \"ORDER-SORT-ERROR\", sprintf(\"sort key %y is not valid; valid keys: %y\", k, (workflows.describe().getHash() + workflow_instance.describe().getHash()).keys());\n                if (k == \"workflow_instanceid\")\n                    hwf = True;\n            }\n\n            # the sort key must also have a unique column to ensure consistent sort order\n            if (!hwf)\n                sort += \"workflow_instanceid\";\n        }\n\n        hash wcond;\n\n        if (val.size() > 1)\n            wcond.\"oik.value\" = op_in(val);\n        else {\n            auto v = val[0];\n            if (v =~ /%/)\n                wcond.\"oik.value\" = op_like(v);\n            else\n                wcond.\"oik.value\" = v;\n        }\n\n        if (wfiids)\n            wcond.workflow_instanceid = op_in(wfiids);\n\n        if (statuses)\n            wcond.workflowstatus = op_in(map OMQ::StatMap.$1, statuses);\n\n        if (exists modified)\n            wcond.modified = op_ge(modified);\n\n        if (minstarted)\n            wcond.started = op_ge(minstarted);\n        if (maxstarted)\n            wcond.\"1:started\" = op_lt(maxstarted);\n\n        if (key)\n            wcond.\"oik.keyname\" = key;\n\n        *hash wfah = getWorkflowAccessHash();\n        if (exists wfah) {\n            if (!wfah)\n                throw \"WORKFLOW-ACCESS-ERROR\", \"user cannot access any workflows\";\n\n            if (wfids) {\n                list wl = ();\n                map wl += $1, wfids, wfah.$1;\n                wcond.workflowid = op_in(wl);\n            }\n            else\n                wcond.workflowid = op_in(wfah.keys());\n        } else if (wfids)\n            wcond.workflowid = op_in(wfids);\n\n        hash sh = (\n            \"comment\": \"qorus.info.getWorkflowInstancesByKeyValue\",\n            \"columns\": (\"w.name\", \"w.version\", \"workflow_instanceid\", \"workflowid\", \"workflowstatus\", \"status_sessionid\", \"started\", \"completed\", \"modified\", \"parent_workflow_instanceid\", \"synchronous\", \"business_error\", \"operator_lock\", \"note_count\", cop_as(\"warnings\", \"warning_count\"), cop_as(\"errors\", \"error_count\"), \"custom_status\", \"priority\", \"scheduled\"),\n            \"join\": (join_inner(order_instance_keys, \"oik\") + join_inner(workflows, \"w\")),\n            \"where\": wcond,\n            \"limit\": rownum,\n            \"offset\": offset,\n            \"orderby\": sort,\n            \"desc\": desc,\n        );\n\n        #logDebug(\"SH: %N\\n\", sh);\n\n        *list sqlresult;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                sqlresult = workflow_instance.selectRows(sh, SqlDataOpt);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        if (sqlresult)\n            sqlresult = SM.processWorkflowResults(sqlresult);\n\n        return sqlresult;\n    }\n\n    private *list searchWorkflowInstancesPriv(string dsname, hash h) {\n        AbstractTable workflows = getSqlTableSystemTrans(dsname, \"workflows\");\n        AbstractTable workflow_instance = getSqlTableSystemTrans(dsname, \"workflow_instance\");\n\n        if (!h.limit)\n            h.limit = OptionHelper::getOption(\"row-limit\");\n\n        if (h.desc)\n            h.desc = parse_boolean(h.desc);\n\n        if (h.sort) {\n            if (h.sort && h.sort =~ /,/)\n                h.sort = h.sort.split(\",\");\n\n            # process sort keys\n            bool hwf;\n            foreach string k in (\\h.sort) {\n                k = k.lwr();\n                if (!workflows.describe().hasKey(k) && !workflow_instance.describe().hasKey(k))\n                    throw \"ORDER-SORT-ERROR\", sprintf(\"sort key %y is not valid; valid keys: %y\", k,\n                        (workflows.describe().getHash() + workflow_instance.describe().getHash()).keys());\n                if (k == \"workflow_instanceid\")\n                    hwf = True;\n            }\n\n            # the sort key must also have a unique column to ensure consistent sort order\n            if (!hwf) {\n                if (h.sort.typeCode() != NT_LIST)\n                    h.sort = list(h.sort);\n                h.sort += \"workflow_instanceid\";\n            }\n        } else if (h.desc)\n            h.sort = \"workflow_instanceid\";\n\n        hash jh = join_inner(workflows, \"w\");\n\n        hash wcond;\n\n        if (h.keyvalue) {\n            jh += join_inner(getSqlTableSystemTrans(dsname, \"order_instance_keys\"), \"oik\");\n\n            if (h.keyvalue && h.keyvalue =~ /,/) {\n                h.keyvalue = h.keyvalue.split(\",\");\n            }\n\n            if (h.keyvalue.lsize() > 1) {\n                # issue #25.1: ensure that key values are strings for the DB query\n                wcond.\"oik.value\" = op_in(map $1.toString(), h.keyvalue);\n            } else {\n                if (h.keyvalue =~ /%/) {\n                    wcond.\"oik.value\" = op_like(h.keyvalue);\n                } else {\n                    # issue #25.1: ensure that key values are strings for the DB query\n                    wcond.\"oik.value\" = h.keyvalue.toString();\n                }\n\n                if (h.keyname) {\n                    if (h.keyname =~ /%/)\n                        wcond.\"oik.keyname\" = op_like(h.keyname);\n                    else\n                        wcond.\"oik.keyname\" = h.keyname;\n                }\n            }\n        }\n\n        if (h.workflow_instanceid) {\n            if (h.workflow_instanceid && h.workflow_instanceid =~ /,/)\n                h.workflow_instanceid = h.workflow_instanceid.split(\",\");\n\n            if (h.workflow_instanceid.lsize() > 1)\n                wcond.workflow_instanceid = op_in(map $1.toInt(), h.workflow_instanceid);\n            else\n                wcond.workflow_instanceid = h.workflow_instanceid.toInt();\n        }\n\n        if (h.status) {\n            h.status = h.status.upr();\n            # make into a list\n            if (h.status && h.status =~ /,/) {\n                h.status = h.status.split(\",\");\n            }\n\n            wcond.workflowstatus = op_in(map OMQ::StatMap.$1, h.status);\n        }\n\n        if (h.modified.val())\n            wcond.modified = op_ge(date(h.modified));\n\n        if (h.maxmodified.val())\n            wcond.\"1:modified\" = op_lt(date(h.maxmodified));\n\n        if (h.minstarted.val())\n            wcond.started = op_ge(date(h.minstarted));\n        if (h.maxstarted.val())\n            wcond.\"1:started\" = op_lt(date(h.maxstarted));\n\n        process_workflow_id_and_name(\\wcond, h);\n\n        hash sh = (\n            \"comment\": \"qorus.info.searchWorkflowInstances\",\n            \"columns\": (\"w.name\", \"w.version\", \"workflow_instanceid\", \"workflowid\", \"workflowstatus\", \"status_sessionid\", \"started\", \"completed\", \"modified\", \"parent_workflow_instanceid\", \"synchronous\", \"business_error\", \"operator_lock\", \"note_count\", cop_as(\"warnings\", \"warning_count\"), cop_as(\"errors\", \"error_count\"), \"custom_status\", \"priority\", \"scheduled\"),\n            \"join\": jh,\n            \"where\": wcond,\n            \"limit\": h.limit,\n            \"offset\": h.offset,\n            \"orderby\": h.sort,\n            \"desc\": h.desc,\n        );\n\n        #logDebug(\"SH: %N\\n\", sh);\n\n        *list sqlresult;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                sqlresult = workflow_instance.selectRows(sh, SqlDataOpt);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        if (sqlresult)\n            sqlresult = SM.processWorkflowResults(sqlresult);\n\n        return sqlresult;\n    }\n\n    #! searches for workflow order instances according to a hash\n    /** @param h a hash of search parameters with the following keys (all are optional):\n        - \\c keyname: the name of a search key to be used with the \\a keyvalue value(s)\n        - \\c keyvalue: the value(s) of workflow order search key(s) to use (optionally used in conjunction with \\a keyname)\n        - \\c workflowname: all accessible versions of the given workflow name\n        - \\c workflowid: workflowid values(s)\n        - \\c workflow_instanceid: workflow_instanceid values(s)\n        - \\c status: status value(s)\n        - \\c modified: minimum modified date\n        - \\c maxmodified: maximum modified date\n        - \\c minstarted: minimum start date\n        - \\c maxstarted: maximum start date\n        - \\c limit: max number of rows to return, if not given, then the value of the \\a \"row-limit\" option is used (default: 100)\n        - \\c offset: row offset\n        - \\c sort: columns for sorting the results\n        - \\c desc: return in descending order\n\n        @return @ref nothing if no rows match or a list of hashes with the following keys:\n        - \\c name: the name of the workflow\n        - \\c version: the version of the workflow\n        - \\c workflow_instanceid: the workflow order instance ID\n        - \\c workflowid: the workflow ID\n        - \\c workflowstatus: the status of the workflow order instance\n        - \\c status_sessionid: the application session ID that owns the workflow order instance data or 0 if the data is now owned by any application session\n        - \\c started: the start date/time of the workflow order instance\n        - \\c completed: the completed date/time for the workflow order instance\n        - \\c modified: the last modified date/time of the workflow order instance\n        - \\c parent_workflow_instanceid: the parent workflow_instanceid if the workflow is a child workflow order\n        - \\c synchronous: the synchronous flag for the workflow order instance\n        - \\c business_error: the business error flag for the workflow order instance\n        - \\c archive: the archive flag for the workflow order instance (presented only if it goes from archive datasource)\n        - \\c operator_lock: the username of the user owning the lock on the workflow order instance data\n        - \\c note_count: the number of notes attached to the workflow order instance\n        - \\c warning_count: the warning count of the workflow order instance\n        - \\c error_count: the error count of the workflow order instance\n        - \\c custom_status: any custom status for the workflow order instance\n        - \\c priority: the priority of the workflow order instance\n        - \\c scheduled: the scheduled date for the workflow order instance\n        - \\c archive: if retrieved from the archive datasource\n\n        @since\n        - Qorus 3.0.2\n        - the \\a workflowname option was added in Qorus 3.1\n    */\n    *list searchWorkflowInstances(*hash h) {\n        logDebug(\"searchWorkflowInstances(): h: %y\", h);\n        softint expected = h.limit ?? OptionHelper::getOption(\"row-limit\");\n\n        *list ret = searchWorkflowInstancesPriv(\"omq\", h);\n        int lsize = ret.lsize();\n        if (lsize < expected && (*string dsarch = Qorus.props.get(\"arch\").datasource))\n            ret += map $1 + (\"archive\": True), searchWorkflowInstancesPriv(dsarch, h + (\"limit\": expected - lsize));\n        logDebug(\"searchWorkflowInstances() returning %d row%s\", ret.size(), ret.size() == 1 ? \"\" : \"s\");\n        return ret;\n    }\n\n    #! return the Workflow Instance Overview info, PARAMS: list(hash(\"ID\",[optional: \"date\"])), RETURN: list(hash(info))\n    list getWorkflowInstanceOverview(list wfilist) {\n        # inly wfiids\n        list wfiIDlist = ();\n        # mapping of wfiids to its modified date. (But I still don't get meaning of this selection...)\n        hash wfiid2date = {};\n\n        foreach hash obj in (wfilist) {\n            checkWorkflowAccess(obj.ID);\n            push wfiIDlist, obj.ID;\n\n            if (exists obj.ID) {\n                wfiid2date{obj.ID} = obj.date;\n            }\n        } # foreach\n\n        string sql;\n        auto args;\n        if (qdriver == \"oracle\") {\n%ifndef NO_ORACLE\n            sql = sprintf(\"select wi.*,\n                    (select count(STEPID) from step_instance si\n                        where wi.WORKFLOW_INSTANCEID = si.WORKFLOW_INSTANCEID) as STEPS,\n                    (select count(ERROR_INSTANCEID) from error_instance ei\n                        where wi.WORKFLOW_INSTANCEID = ei.WORKFLOW_INSTANCEID) as ERRORS\n                    from workflow_instance wi\n                    where wi.WORKFLOW_INSTANCEID in (\n                                select column_value\n                                    from table(%v)\n                            )\");\n            args = bindOracleCollection(\"sys.odcinumberlist\", wfiIDlist);\n%else\n            throw \"ORACLE-ERROR\", \"Qore 'oracle' module is mandatory but it's missing\";\n%endif\n        } else {\n            sql = sprintf(\"select wi.*,\n                    (select count(STEPID) from step_instance si\n                        where wi.WORKFLOW_INSTANCEID = si.WORKFLOW_INSTANCEID) as STEPS,\n                    (select count(ERROR_INSTANCEID) from error_instance ei\n                        where wi.WORKFLOW_INSTANCEID = ei.WORKFLOW_INSTANCEID) as ERRORS\n                    from workflow_instance wi\n                    where wi.WORKFLOW_INSTANCEID in (%s)\");\n            args = compatDeprecatedMakeSelectList(qdriver, wfiIDlist);\n        }\n\n        list sqlresult;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                sqlresult = omqp.selectRows(sql, args);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        if (sqlresult) {\n            # remove date related info\n            sqlresult = select sqlresult, $1.modified != wfiid2date{$1.workflow_instanceid};\n            # process it\n            sqlresult = SM.processWorkflowResults(sqlresult);\n        }\n\n        return sqlresult;\n    }\n\n    #! gets a list of step instances, params: wfiid\n    list getStepInstanceList(softint wfiId) {\n        checkWorkflowInstanceAccess(wfiId);\n\n        # setup closure to process step entries\n        code proc = hash sub (hash h) {\n            if (h.eventkey === NULL)\n                h -= (\"eventkey\", \"workflow_event_typeid\");\n\n            h += (\n                \"stepstatus\"      : OMQ::SQLStatMap.(h.stepstatus),\n                \"flow_instanceid\" : h.workflow_instanceid,\n                \"business_error\"  : (h.retries == -1 ? True : False),\n                \"retries\"         : (h.retries >= 0 ? h.retries : \"0\"),\n                ) - \"workflow_instanceid\";\n\n            return h;\n        };\n\n        *list l;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                l = omqp.selectRows(\"select * from step_instance natural left join step_instance_events where workflow_instanceid = %v order by started, ind\", wfiId);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        # issue 1777: ensure that array steps are ordered by ind\n        return map proc($1), l;\n    }\n\n    #! gets a list of error instances, params: wfiid, [stepId, ind]\n    list getErrorInstanceList(softint wfiid, *softint stepId, *softint ind) {\n        checkWorkflowInstanceAccess(wfiid);\n\n        string sql = sprintf(\"select ei.*\n            from error_instance ei\n            where ei.workflow_instanceid = %v%s%s order by error_instanceid\",\n            exists stepId ? \" and stepid = %v\" : \"\",\n            exists ind ? \" and ind = %v\" : \"\"\n            );\n\n        list sqlargs = ();\n        push sqlargs, wfiid;\n        if (exists stepId)\n            push sqlargs, stepId;\n        if (exists ind)\n            push sqlargs, ind;\n\n        *list l;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                l = omqp.vselectRows(sql, sqlargs);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        return map $$ + (\"business_error\":boolean($1.business_error)), l;\n    }\n\n    #! gets a list of error instances, params: wfiid, [stepId]\n    list getErrorInstanceListByWFIID(softint wfiid, *softint stepId) {\n        checkWorkflowInstanceAccess(wfiid);\n\n        string sql = sprintf(\"select ei.*\n            from error_instance ei\n            where ei.workflow_instanceid = %v%s order by error_instanceid\",\n            exists stepId ? \" and stepid = %v\" : \"\"\n            );\n\n        list sqlargs = ();\n        push sqlargs, wfiid;\n        if (exists stepId)\n            push sqlargs, stepId;\n\n        *list l;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                l = omqp.vselectRows(sql, sqlargs);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        return map $$ + (\"business_error\":boolean($1.business_error)), l;\n    }\n\n    #! retrieves class data from a classid; returns: hash of class data keyed by name and then version\n    *hash<auto> getClass(softint classid, *softdate date) {\n        AbstractTable classes = getSqlTableSystemTrans(\"omq\", \"classes\");\n\n        # do not use hash<auto> here\n        hash class_sh = {\n            \"where\": {\"classid\": classid},\n        };\n        if (exists date) {\n            class_sh.\"where\".modified = op_gt(date);\n        }\n\n        *hash<auto> h;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                string sql;\n                h = classes.select(class_sh, \\sql);\n\n                # get required classes from the cache\n                if (!h.classid) {\n                    return;\n                }\n                softlist<softint> required_classid_list = keys Qorus.qmm.lookupClass(h.classid[0]).requires;\n                if (required_classid_list) {\n                    hash<string, bool> required_hash;\n                    QorusSystemInfoService::getClassesIntern((map {$1: True}, required_classid_list), classes, \\required_hash);\n                    if (required_hash) {\n                        # must wrap this to be a list in query (hash of lists) format\n                        h.requires = ((map $1.toInt(), keys required_hash),);\n                    }\n                }\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        return processMetadata(h, True, \"class\");\n    }\n\n    static private getClassesIntern(hash<string, bool> classid_hash, AbstractTable classes, reference<hash<string, bool>> req_classes) {\n        # make sure we get classes only once\n        # remove all classes we already have\n        classid_hash -= (keys req_classes);\n        if (!classid_hash) {\n            return;\n        }\n        req_classes += classid_hash;\n\n        foreach string classid in (keys classid_hash) {\n            # get required classes from the cache\n            softlist<softstring> classid_list = keys Qorus.qmm.lookupClass(classid).requires;\n            if (classid_list) {\n                QorusSystemInfoService::getClassesIntern((map {$1: True}, classid_list), classes, \\req_classes);\n            }\n        }\n    }\n\n    #! retrieves class data from the class name and optional version (params: name, [version]), returns: hash of class data keyed by name and then version\n    static *hash getClassFromName(string name, *string ver) {\n        if (!strlen(name))\n            throw \"PARAMETER-ERROR\", \"name is a required parameter for info.getClassFromName()\";\n\n        string sql = \"select * from classes where name = %v\";\n        list sqlargs = ();\n        push sqlargs, name;\n\n        if (strlen(ver)) {\n            sql += \" and version = %v\";\n            push sqlargs, ver;\n        }\n\n        *hash h;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                h = omqp.vselect(sql, sqlargs);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        return processMetadata(h, True, \"class\");\n    }\n\n    #! retrieves constant data from the constantid (params: constantid), returns: hash of constant data keyed by name and then version\n    static *hash getConstant(softint constantid, *softdate date) {\n        if (!constantid)\n            throw \"PARAMETER-ERROR\", \"constantid is a required parameter for info.getConstant()\";\n\n        string sql = \"select * from constants where constantid = %v\";\n        list sqlargs = ();\n        push sqlargs, constantid;\n\n        if (exists date) {\n            sql += \" and modified > %v\";\n            push sqlargs, date;\n        }\n\n        *hash h;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                h = omqp.vselect(sql, sqlargs);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        return processMetadata(h, True, \"constant\");\n    }\n\n    #! retrieves constant data from the constant name and optional version (params: name, [version]), returns: hash of constant data keyed by name and then version\n    static *hash getConstantFromName(string name, *string ver) {\n        if (!strlen(name))\n            throw \"PARAMETER-ERROR\", \"name is a required parameter for info.getConstantFromName()\";\n\n        string sql = \"select * from constants where name = %v\";\n        list sqlargs = ();\n        push sqlargs, name;\n\n        if (strlen(ver)) {\n            sql += sprintf(\" and version = %v\", ver);\n            push sqlargs, ver;\n        }\n\n        *hash h;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                h = omqp.vselect(sql, sqlargs);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        return processMetadata(h, True, \"constant\");\n    }\n\n    #! gets step metadata (optional params: list of IDs), returns: hash of step metadata information keyed by name and then version\n    *hash getStepMetadata() {\n        hash sh = {\n            \"where\": {\n                \"stepid\": op_in(argv),\n            },\n        };\n\n        *hash h;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                AbstractTable t = getSqlTableSystem(\"omq\", \"steps\");\n                h = t.select(sh);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        return processMetadata(h, True, \"step\");\n    }\n\n    private *hash getTreeWithWorkflowInstancePriv(string dsname, softint wfiid, softbool compat = False) {\n        AbstractTable workflows = getSqlTableSystemTrans(dsname, \"workflows\");\n        AbstractTable workflow_instance = getSqlTableSystemTrans(dsname, \"workflow_instance\");\n\n        # NOTE: any changes here have to be reflected in SegmentManager::getTreeWithWorkflowInstanceIntern()\n        # select hash; join on workflows\n        hash<auto> sh += {\n            \"join\": join_inner(workflows, \"w\"),\n            \"columns\": WorkflowOrderHierarchyKeys + (map sprintf(\"w.%s\", $1), WorkflowHierarchyKeys),\n        };\n\n        # get the topmost parent\n        string sql = \"select workflowid, parent_workflow_instanceid as pwid from workflow_instance wi where \"\n            \"workflow_instanceid = %v\";\n        auto rs;\n        int pwid = wfiid;\n        bool first = True;\n        AbstractDatasource ds = dsname == \"omq\" ? omqp : getDatasourcePool(dsname);\n        QorusRestartableTransaction trans();\n        do {\n            *hash<auto> rv;\n\n            while (True) {\n                try {\n                    # we can just release the lock because the query is read-only\n                    on_error omqp.rollback();\n\n                    rv = ds.selectRow(sql, pwid);\n                } catch (hash<ExceptionInfo> ex) {\n                    # restart the transaction if necessary\n                    if (trans.restartTransaction(ex))\n                        continue;\n                    rethrow;\n                }\n                break;\n            }\n            trans.reset();\n\n            # check workflow access for the first workflow instance only\n            if (first && rv.workflowid) {\n                checkWorkflowAccess(rv.workflowid);\n                first = False;\n            }\n\n            rs = int(rv.pwid);\n            if (rs > 0) {\n                pwid = rs;\n            }\n        } while (rs > 0);\n\n        # get the root node\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                rs = workflow_instance.selectRows(sh + {\n                    \"comment\" : \"qorus.info.getTreeWithWorkflowInstance\",\n                    \"where\": (\"workflow_instanceid\": pwid),\n                    \"limit\": 1,\n                }, SqlDataOpt)[0];\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n        trans.reset();\n\n        if (!rs) {\n            return;\n        }\n\n        # fetch & build the tree\n        hash<string, hash<auto>> wiTree;\n\n        # add initial element\n        wiTree{pwid} = SM.getTreeRow(rs, compat);\n\n        # now fetch and build the tree\n        list<int> toFetch = (pwid,);\n        while (toFetch) {\n            list<int> l = toFetch;\n            toFetch = ();\n            while (l) {\n                list<int> pl = extract l, 0, 180;\n                while (True) {\n                    try {\n                        # we can just release the lock because the query is read-only\n                        on_error omqp.rollback();\n\n                        rs = workflow_instance.select(sh + {\n                            \"comment\": \"qorus.info.getTreeWithWorkflowInstance\",\n                            \"where\": (\"parent_workflow_instanceid\": op_in(pl)),\n                        }, SqlDataOpt);\n                    } catch (hash<ExceptionInfo> ex) {\n                        # restart the transaction if necessary\n                        if (trans.restartTransaction(ex)) {\n                            continue;\n                        }\n                        rethrow;\n                    }\n                    break;\n                }\n                trans.reset();\n\n                #remove rs{\"workflowid_1\", \"name_1\", \"version_1\", \"modified_1\"};\n\n                # fill the values\n                map wiTree{$1.workflow_instanceid} = SM.getTreeRow($1, compat), rs.contextIterator();\n\n                # next party to fetch\n                toFetch += rs.workflow_instanceid;\n            }\n        } # while\n\n        # issue 1719 sort hierarchy info in \"children-first\" order\n        return SM.sortHierarchy(wiTree);\n    }\n\n    #! retrieves tree view like structure that contains specific instanceid (params: wfiid)\n    *hash<auto> getTreeWithWorkflowInstance(softint wfiid, softbool compat = False) {\n        *hash<auto> ret = getTreeWithWorkflowInstancePriv(\"omq\", wfiid, compat);\n        if (ret) {\n            return ret;\n        }\n        *string dsarch = Qorus.props.get(\"arch\").datasource;\n        if (dsarch) {\n            ret = getTreeWithWorkflowInstancePriv(dsarch, wfiid, compat);\n        }\n        return ret;\n    }\n\n    #! Retrieves all workflow instance info (params: wfiid, [last_modified]; output hash keys: InstanceInfo, OrderInfo, StepInstances, ErrorInstances, LastModified\n    /** @param wfiid the workflow instance ID of the order\n        @param last_modified only retrieve information if changed after this date (if the argument is present); note that this argument is ignored if the workflow order data is cached; in this case, all information are returned and this argument is ignored\n        @param compat add keys for backwards-compatibility with very old versions of Qorus\n        @param with_sensitive_data also return @ref sensitive_data in the \\c OrderInfo key\n\n        @return NOTHING if the workflow instance ID does not exist, otherwise a hash is returned with the following keys:\n        - \\c InstanceInfo: information about the workflow order; see getWFIInstanceInfo() return value for the value of this key see the \\c OrderInfo key also\n        - \\c OrderInfo: information about the actual order information\n        - \\c StepInstances: information about steps in the current workflow order\n        - \\c ErrorInstances: information about errors raised against the workflow order\n        - \\c HierarchyInfo: information about all parent and/or child workflows related to this workflow order\n        - \\c AuditEvents: if any audit events were created for the given job instance, they will appear as hashes in a list assigned to this key; the hashes will have the following keys:\n        - \\c audit_eventid: the audit event ID (unique key in the \\c AUDIT_EVENTS table)\n        - [\\c related_audit_eventid]: related audit event ID\n        - \\c audit_event_code: the audit event code (see @ref AuditEventCodes for possible values)\n        - [\\c audit_user_event]: the user audit event code string (present only when \\c audit_event_code is @ref OMQ::AE_USER_EVENT)\n        - [\\c reason]: the reason for the event\n        - \\c who: the initiator of the event\n        - \\c source: a string describing the source of the event\n        - [\\c info1]: an informational string about the event\n        - [\\c info2]: an informational string about the event\n        - \\c created: the date/time the audit event was created\n        - \\c event: the string description corresponding to the \\c audit_event_code (see @ref AuditEventStrings for possible values)\n        - \\c LastModified: the last modified date of the workflow order if the data is retrieved from the DB, otherwise the current date and time if the information was retrieved form the workflow order cache\n\n        @throw SENSITIVE-DATA-ERROR this exception is thrown when \\a with_sensitive_data is @ref True \"True\" and the request is received over an insecure connection\n        @throw AUTHORIZATION-ERROR this exception is thrown when \\a with_sensitive_data is @ref True \"True\" and the user has neither @ref OMQ::QR_READ_SENSITIVE_DATA or @ref OMQ::QR_SENSITIVE_DATA_CONTROL\n\n        @since Qorus 3.1.1 this API supports retrieving sensitive data over internal and encrypted connections by authorized users\n    */\n    *hash<auto> getWFIAllInfo(softint wfiid, *softdate last_modified, softbool compat = False, softbool with_sensitive_data = False) {\n        # ensure that sensitive data is only returned over a secure connection and by an authorized user\n        if (with_sensitive_data) {\n            verifySensitiveDataRequestRo();\n        }\n\n        #logDebug(\"getWFIAllInfo() cx: %N\", get_call_context());\n        # workflow access is checked in SegmentManager::getWFIAllInfo()\n        *hash result = SM.getWFIAllInfo(wfiid, last_modified, compat, with_sensitive_data);\n\n        if (result) {\n            return result;\n        }\n\n        *hash InstanceInfo = QorusSystemInfoService::getWFIInstanceInfo(wfiid, last_modified, compat);\n        if (!exists InstanceInfo) {\n            return;\n        }\n\n        checkWorkflowAccess(InstanceInfo.InstanceInfo.workflowid);\n\n        *hash HierarchyInfo   = QorusSystemInfoService::getTreeWithWorkflowInstance(wfiid, compat);\n        *date LastModified    = InstanceInfo.LastModified;\n\n        *hash OrderInfo       = QorusSystemInfoService::getWFIOrderInfo(wfiid, last_modified, compat,\n            with_sensitive_data);\n        LastModified          = LastModified > OrderInfo.LastModified ? LastModified : OrderInfo.LastModified;\n\n        *hash StepInstances   = QorusSystemInfoService::getWFIStepInstances(wfiid, last_modified, compat);\n        LastModified          = LastModified > StepInstances.LastModified ? LastModified : StepInstances.LastModified;\n\n        *hash ErrorInstances  = QorusSystemInfoService::getWFIErrorInstances(wfiid, last_modified, compat);\n        LastModified          = LastModified > ErrorInstances.LastModified ? LastModified : ErrorInstances.LastModified;\n\n        if (InstanceInfo) {\n            result.InstanceInfo = InstanceInfo.InstanceInfo;\n        }\n        if (OrderInfo) {\n            result.OrderInfo = OrderInfo.OrderInfo;\n        }\n        if (StepInstances) {\n            result.StepInstances = StepInstances.StepInstances;\n        }\n        if (ErrorInstances) {\n            result.ErrorInstances = ErrorInstances.ErrorInstances;\n        }\n        if (HierarchyInfo) {\n            result.HierarchyInfo = HierarchyInfo;\n        }\n\n        result.AuditEvents = SM.getWorkflowAuditEventsSQL(wfiid);\n\n        if (LastModified) {\n            result.LastModified = LastModified;\n        }\n\n        return result;\n    }\n\n    private *hash getWFIInstanceInfoPriv(string dsname, softint wfiid, *softdate last_modified,\n            softbool compat = False) {\n        if (!wfiid) {\n            throw \"PARAMETER-ERROR\", \"Missing workflow instance id\";\n        }\n\n        hash<auto> wh += {\n            \"workflow_instanceid\": wfiid,\n        };\n        if (exists last_modified) {\n            wh.modified = op_gt(last_modified);\n        }\n\n        *hash<auto> InstanceInfo;\n        AbstractDatasource ds = dsname == \"omq\" ? omqp : getDatasourcePool(dsname);\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                AbstractTable workflow_instance = QorusSystemService::getSqlTableSystem(dsname, \"workflow_instance\");\n                InstanceInfo = workflow_instance.selectRow({\"where\": wh});\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex)) {\n                    continue;\n                }\n                rethrow;\n            }\n            break;\n        }\n\n        #printf(\"DEBUG getWFIInstanceInfo(wfiid=%d, lmd=%y) sql=%y q=%y\\n\", wfiid, last_modified, sql, InstanceInfo);\n\n        if (!InstanceInfo) {\n            return;\n        }\n\n        checkWorkflowAccess(InstanceInfo.workflowid);\n\n        # add metadata\n        {\n            *hash<auto> wh = Qorus.qmm.lookupWorkflow(InstanceInfo.workflowid);\n            if (!wh) {\n                throw \"WORKFLOW-ERROR\", sprintf(\"workflowid %d is referenced in the database by \"\n                    \"workflow_instanceid %d, but no such workflow is cached\", InstanceInfo.workflowid, wfiid);\n            }\n            InstanceInfo = wh{\n                \"name\",\n                \"version\",\n                \"autostart\",\n                \"manual_autostart\",\n                \"deprecated\",\n                \"max_instances\",\n            } + InstanceInfo;\n            if (InstanceInfo.custom_status) {\n                InstanceInfo.custom_status_desc = wh.custom_statuses{InstanceInfo.custom_status};\n            }\n        }\n\n        return (\n            \"InstanceInfo\": InstanceInfo + (\n                \"workflowstatus\": OMQ::SQLStatMap.(InstanceInfo.workflowstatus),\n                \"business_error\": boolean(InstanceInfo.business_error),\n                \"priority\": int(InstanceInfo.priority),\n                \"synchronous\": InstanceInfo.synchronous.toBool(),\n            ) + (compat ? (\"createdby\": \"omq\", \"modifiedby\": \"omq\") : NOTHING),\n            \"LastModified\": InstanceInfo.modified);\n    }\n\n    #! Retrieves only workflow instance info (params: wfiid, [last_modified]; output hash keys: InstanceInfo, LastModified\n    /** @param wfiid the workflow instance ID of the order\n        @param last_modified only retrieve information if changed after this date (if the argument is present)\n        @param compat add keys for backwards-compatibility with very old versions of Qorus\n\n        @return NOTHING if the criteria do not match any workflow order, otherwise a hash with the following keys:\n        - \\c InstanceInfo: a hash with the following keys:\n        - \\c name: the name of the workflow (metadata)\n        - \\c version: the version of the workflow (metadata)\n        - \\c workflow_instanceid: equal to the wfiid argument\n        - \\c workflowid: the workflowid of the workflow (metadata)\n        - \\c workflowstatus: the status of the workflow (see @ref StatusDescriptions for possible values)\n        - \\c status_sessionid: the Qorus application session that the order belongs to or 0 if not owned by any session\n        - \\c parent_workflow_instanceid: the parent workflow instance ID if this workflow is a subworkflow\n        - \\c synchronous: 1 for an order currently being executed synchronously\n        - \\c business_error: \\c True if the @ref OMQ::StatError status is due to a business error\n        - \\c workflowstatus_orig: the original status of the workflow (only if the status is @ref OMQ::StatBlocked or @ref OMQ::StatCanceled; see @ref StatusDescriptions for possible values)\n        - \\c custom_status: the custom status set for the order (if any)\n        - \\c scheduled: the scheduled date for the workflow (if any)\n        - \\c priority: the order priority\n        - \\c started: the date/time the workflow order was created\n        - \\c completed: the date/time the workflow order got a @ref OMQ::StatComplete status\n        - \\c modified: the last modified date/time\n        - \\c archive: the archive flag for the workflow order instance (presented only if it goes from archive datasource)\n        - \\c LastModified: the last modified date of the workflow order instance\n    */\n    *hash getWFIInstanceInfo(softint wfiid, *softdate last_modified, softbool compat = False) {\n        *hash ret = getWFIInstanceInfoPriv(\"omq\", wfiid, last_modified, compat);\n        if (!ret) {\n            *string dsarch = Qorus.props.get(\"arch\").datasource;\n            if (!dsarch)\n                return ret;\n            ret = getWFIInstanceInfoPriv(dsarch, wfiid, last_modified, compat);\n            if (ret)\n                ret.InstanceInfo.archive = True;\n        }\n        return ret;\n    }\n\n    private *hash getWFIOrderInfoPriv(string dsname, softint wfiid, *softdate last_modified,\n            softbool compat = False, softbool with_sensitive_data = False) {\n        if (!wfiid)\n            throw \"PARAMETER-ERROR\", \"Missing workflow instance id\";\n\n        # ensure that sensitive data is only returned over a secure connection and by an authorized user\n        if (with_sensitive_data) {\n            verifySensitiveDataRequestRo();\n        }\n\n        checkWorkflowInstanceAccess(wfiid);\n\n        string sql = \"select * from order_instance where WORKFLOW_INSTANCEID = %v\";\n        softlist sqlargs = wfiid;\n\n        if (exists last_modified) {\n            # static data will not be returned in case last_modified is present\n            sql += \" and modified > %v\";\n            sqlargs += last_modified;\n        }\n\n        *hash OrderInfo;\n        AbstractDatasource ds = dsname == \"omq\" ? omqp : getDatasourcePool(dsname);\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                OrderInfo = ds.vselectRow(sql, sqlargs);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                if (Qorus.getDebugSystem())\n                    logDebug(\"SQL: %s\", sql);\n                rethrow;\n            }\n            break;\n        }\n        trans.reset();\n\n        if (!OrderInfo)\n            return;\n\n        *date LastModified = OrderInfo.modified;\n        OrderInfo += {\n            # parse dynamic data\n            \"dynamicdata\": deserializeQorusData(OrderInfo.dynamicdata),\n\n            # parse static data\n            \"staticdata\": deserializeQorusData(OrderInfo.staticdata),\n        };\n\n        # issue #2880: get step dynamic data\n        {\n            AbstractTable t = getSqlTableSystemTrans(dsname, \"step_instance_data\");\n            hash<auto> select_hash = {\n                \"where\": {\n                    \"workflow_instanceid\": wfiid,\n                },\n                \"orderby\": (\"stepid\", \"ind\"),\n            };\n            *hash<auto> h;\n            while (True) {\n                try {\n                    on_error omqp.rollback();\n\n                    h = t.select(select_hash);\n                } catch (hash<ExceptionInfo> ex) {\n                    # restart the transaction if necessary\n                    if (trans.restartTransaction(ex))\n                        continue;\n                    rethrow;\n                }\n                break;\n            }\n            trans.reset();\n\n            if (h.stepid.lsize()) {\n                # make a hash keyed by stepid\n                hash<auto> stepinfo;\n                hash<auto> stepdata;\n                foreach hash<auto> row in (h.contextIterator()) {\n                    if (!stepinfo{row.stepid}) {\n                        stepinfo{row.stepid} = Qorus.qmm.lookupStep(row.stepid);\n                    }\n                    stepdata{row.stepid}[row.ind] = deserializeQorusData(row.data);\n                }\n\n                OrderInfo.stepdata = map (stepinfo{$1.key}{\"name\", \"version\", \"steptype\", \"arraytype\"} + {\n                    \"stepid\": $1.key.toInt(),\n                    \"data\": $1.value,\n                }), stepdata.pairIterator();\n            }\n        }\n\n        # retrieve sensitive data\n        {\n            AbstractTable t = getSqlTableSystemTrans(dsname, \"sensitive_order_data\");\n            hash wcond = (\"workflow_instanceid\": wfiid);\n            if (with_sensitive_data) {\n                hash sd;\n                *hash h;\n                while (True) {\n                    try {\n                        on_error omqp.rollback();\n\n                        h = t.select((\"where\": wcond));\n                    } catch (hash<ExceptionInfo> ex) {\n                        # restart the transaction if necessary\n                        if (trans.restartTransaction(ex))\n                            continue;\n                        rethrow;\n                    }\n                    break;\n                }\n                trans.reset();\n                context (h) {\n                    string svalue = Qorus.decodeDecryptSensitiveValue(%svalue);\n                    string aad = sprintf(\"%d-%s-%s\", wfiid, %skey, svalue);\n                    sd{%skey}{svalue}.data = Qorus.deserializeDecryptSensitiveData(%data, %iv, %mac, aad);\n                    if (%meta)\n                        sd{%skey}{svalue}.meta = Qorus.deserializeDecryptSensitiveData(%meta, %miv, %mmac, aad);\n                }\n                # get aliases, if any\n                if (sd) {\n                    t = getSqlTableSystemTrans(dsname, \"sensitive_order_data_keys\");\n                    while (True) {\n                        try {\n                            on_error omqp.rollback();\n\n                            h = t.select((\"where\": wcond));\n                        } catch (hash<ExceptionInfo> ex) {\n                            # restart the transaction if necessary\n                            if (trans.restartTransaction(ex))\n                                continue;\n                            rethrow;\n                        }\n                        break;\n                    }\n                    trans.reset();\n\n                    context (h) {\n                        string svalue = Qorus.decodeDecryptSensitiveValue(%svalue);\n                        reference a = \\sd{%skey}{svalue}.aliases;\n                        a += a ? %alias : (%alias,);\n                    }\n                }\n                OrderInfo.sensitive_data = sd;\n                OrderInfo.has_sensitive_data = boolean(sd);\n            } else\n                OrderInfo.has_sensitive_data = boolean(t.findSingle(wcond));\n        }\n\n        # setup user keys\n        if (dsname == \"omq\") {\n            OrderInfo.\"keys\" = SM.getOrderKeysSQL(wfiid);\n        } else {\n            SqlUtil::AbstractTable t = getSqlTableSystemTrans(dsname, \"order_instance_keys\");\n            hash r;\n            while (True) {\n                try {\n                    # we can just release the lock because the query is read-only\n                    on_error omqp.rollback();\n\n                    r = t.select((\n                        \"columns\": (\"keyname\", \"value\"),\n                        \"where\": (\"workflow_instanceid\": wfiid),\n                        ));\n                } catch (hash<ExceptionInfo> ex) {\n                    # restart the transaction if necessary\n                    if (trans.restartTransaction(ex))\n                        continue;\n                    rethrow;\n                }\n                break;\n            }\n            trans.reset();\n\n            hash h;\n            context (r) {\n                if (exists h.%keyname) {\n                    if (h.%keyname.typeCode() != NT_LIST)\n                        h.%keyname = (h.%keyname, %value);\n                    else\n                        h.%keyname += %value;\n                }\n                else\n                    h.%keyname = %value;\n            }\n\n            OrderInfo.\"keys\" = h;\n        }\n\n        if (compat)\n            OrderInfo += (\"createdby\" : \"omq\", \"modifiedby\" : \"omq\");\n\n        return (\"OrderInfo\" : OrderInfo, \"LastModified\" : LastModified);\n    }\n\n    #! Retrieves workflow instances order info (params: wfiid, [last_modified]; output hash keys: OrderInfo, LastModified\n    /**\n        @throw SENSITIVE-DATA-ERROR this exception is thrown when \\a with_sensitive_data is @ref True \"True\" and the request is received over an insecure connection\n        @throw AUTHORIZATION-ERROR this exception is thrown when \\a with_sensitive_data is @ref True \"True\" and the user has neither @ref OMQ::QR_READ_SENSITIVE_DATA or @ref OMQ::QR_SENSITIVE_DATA_CONTROL\n\n        @since Qorus 3.1.1 this API supports retrieving sensitive data over internal and encrypted connections by authorized users\n    */\n    *hash getWFIOrderInfo(softint wfiid, *softdate last_modified, softbool compat = False, softbool with_sensitive_data = False) {\n        *hash ret = getWFIOrderInfoPriv(\"omq\", wfiid, last_modified, compat, with_sensitive_data);\n        if (ret)\n            return ret;\n        *string dsarch = Qorus.props.get(\"arch\").datasource;\n        if (!dsarch)\n            return ret;\n        return getWFIOrderInfoPriv(dsarch, wfiid, last_modified, compat, with_sensitive_data);\n    }\n\n    private *hash getWFIStepInstancesPriv(string dsname, softint wfiid, *softdate last_modified, softbool compat = False) {\n        if (!wfiid)\n            throw \"PARAMETER-ERROR\", \"Missing workflow instance id\";\n\n        checkWorkflowInstanceAccess(wfiid);\n\n        string sql = \"select si.workflow_instanceid, si.stepid, si.ind, s.name stepname, s.version stepversion, s.steptype,\n                                stepstatus, retries, skip, custom_status, started, completed,\n                                s.workflow_event_typeid, eventkey, s.stepfunction_instanceid function_instanceid,\n                                subworkflow_instanceid, s.user_interaction, s.queueid, q.name as \\\"queuename\\\"\n                            from step_instance si\n                                join steps s on (si.stepid = s.stepid)\n                                left join subworkflow_instance swi on (si.workflow_instanceid = swi.workflow_instanceid and si.stepid = swi.stepid and si.ind = swi.ind)\n                                left join step_instance_events se on (si.workflow_instanceid = se.workflow_instanceid and si.stepid = se.stepid and si.ind = se.ind)\n                                left join queues q on (s.queueid = q.queueid)\n                            where si.workflow_instanceid = %v\";\n        list sqlargs = ();\n        push sqlargs, wfiid;\n\n        if (exists last_modified) {\n            sql += \" and (si.started > %v or si.COMPLETED > %v)\";\n            push sqlargs, last_modified;\n            push sqlargs, last_modified;\n        }\n\n        # issue 1777: ensure that array steps are ordered by ind\n        sql += \" order by si.started, si.ind\";\n\n        AbstractDatasource ds = dsname == \"omq\" ? omqp : getDatasourcePool(dsname);\n        *hash sqlresult;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                on_error omqp.rollback();\n\n                sqlresult = ds.vselect(sql, sqlargs);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                if (Qorus.getDebugSystem())\n                    logDebug(\"SQL: %s\", sql);\n                rethrow;\n            }\n            break;\n        }\n\n        list StepInstances = ();\n        *date LastModified;\n        context (sqlresult) {\n            hash h = %%;\n            if (h.eventkey === NULL)\n                h -= (\"eventkey\", \"workflow_event_typeid\" );\n\n            h += (\"stepstatus\" : OMQ::SQLStatMap.%stepstatus);\n            if (compat) {\n                h.flow_instanceid = h.workflow_instanceid;\n                remove h{\"workflow_instanceid\", \"user_interaction\", \"queueid\", \"queuename\"};\n            } else {\n                h += {\n                    \"skip\": h.skip.toBool(),\n                    \"user_interaction\": h.user_interaction.toBool(),\n                };\n                if (!h.queueid) {\n                    remove h{\"queueid\", \"queuename\"};\n                }\n            }\n            if (h.retries == -1) {\n                h.business_error = True;\n                h.retries = compat ? \"0\" : 0;\n            } else {\n                h.business_error = False;\n            }\n\n            StepInstances += h;\n            LastModified  = LastModified > %started ? LastModified : %started;\n            LastModified  = LastModified > %completed ? LastModified : %completed;\n        }\n\n        if (StepInstances)\n            return (\"StepInstances\" : StepInstances, \"LastModified\" : LastModified);\n    }\n\n    #! Retrieves all step info for workflow instance (params: wfiid, [last_modified]; output hash keys: StepInstances, LastModified\n    *hash getWFIStepInstances(softint wfiid, *softdate last_modified, softbool compat = False) {\n        *hash ret = getWFIStepInstancesPriv(\"omq\", wfiid, last_modified, compat);\n        if (!ret) {\n            *string dsarch = Qorus.props.get(\"arch\").datasource;\n            if (dsarch)\n                ret = getWFIStepInstancesPriv(dsarch, wfiid, last_modified, compat);\n        }\n        return ret;\n    }\n\n    private *hash getWFIErrorInstancesPriv(string dsname, softint wfiid, *softdate last_modified, softbool compat = False) {\n        if (!wfiid)\n            throw \"PARAMETER-ERROR\", \"Missing workflow instance id\";\n\n        checkWorkflowInstanceAccess(wfiid);\n\n        string sql = \"select * from error_instance where WORKFLOW_INSTANCEID = %v\";\n        list sqlargs = ();\n        push sqlargs, wfiid;\n\n        if (exists last_modified) {\n            sql += \" and created > %v\";\n            push sqlargs, last_modified;\n        }\n\n        sql += \" order by error_instanceid\";\n\n        AbstractDatasource ds = dsname == \"omq\" ?  omqp : getDatasourcePool(dsname);\n        *hash sqlresult;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                sqlresult = ds.vselect(sql, sqlargs);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                if (Qorus.getDebugSystem())\n                    logDebug(\"SQL: %s\", sql);\n                rethrow;\n            }\n            break;\n        }\n\n        list ErrorInstances = ();\n        *date LastModified;\n        context (sqlresult) {\n            # issue #2208: the \"info\" key must be deserialized from YAML\n            ErrorInstances += (%% + (\"info\": (%info.val() ? deserializeQorusData(%info) : NOTHING), \"business_error\": boolean(%business_error)) + (compat ? (\"createdby\": \"omq\") : NOTHING));\n            LastModified  = LastModified > %created ? LastModified : %created;\n        }\n\n        if (ErrorInstances)\n            return (\"ErrorInstances\": ErrorInstances, \"LastModified\": LastModified);\n    }\n\n    #! gets workflow instance error info (params: wfiid, [last_modified]; output hash keys: ErrorInstances, LastModified\n    *hash getWFIErrorInstances(softint wfiid, *softdate last_modified, softbool compat = False) {\n        *hash ret = getWFIErrorInstancesPriv(\"omq\", wfiid, last_modified, compat);\n        if (!ret) {\n            *string dsarch = Qorus.props.get(\"arch\").datasource;\n            if (dsarch)\n                ret = getWFIErrorInstancesPriv(dsarch, wfiid, last_modified, compat);\n        }\n        return ret;\n    }\n\n    #! retrieves workflow instances from a workflow name and a key value, returns a list of workflow instance IDs\n    *list getWorkflowInstanceListFromWorkflowNameAndKeyValue(string name, softstring val) {\n        hash rv;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                rv = omqp.select(\"select distinct workflowid, workflow_instanceid from order_instance_keys where workflowid in (select workflowid from workflows where name = %v) and value = %v\", name, val);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        if (elements rv.workflowid) {\n            checkWorkflowAccess(rv.workflowid);\n        }\n\n        return rv.workflow_instanceid;\n    }\n\n    #! retrieves workflow instances from a workflow name, version, and key value, returns a list of workflow instance IDs\n    *list getWorkflowInstanceListFromWorkflowNameVersionAndKeyValue(string name, string version, softstring val) {\n        hash rv;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                rv = omqp.select(\"select distinct workflowid, workflow_instanceid from order_instance_keys where workflowid in (select workflowid from workflows where name = %v and version = %v) and value = %v\", name, version, val);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        if (rv.workflowid) {\n            checkWorkflowAccess(rv.workflowid);\n        }\n\n        return rv.workflow_instanceid;\n    }\n\n    #! retrieves workflow instances from a key value only, returns a list of workflow instance IDs\n    *list getWorkflowInstanceListFromKeyValue(softstring val) {\n        hash rv;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                rv = omqp.select(\"select distinct workflowid, workflow_instanceid from order_instance_keys where value = %v\", val);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        if (rv.workflowid) {\n            checkWorkflowAccess(rv.workflowid);\n        }\n\n        return rv.workflow_instanceid;\n    }\n\n    #! returns order info from a workflow name and an order key and value (params: workflowname, keyname, value)\n    list getOrderInfoList(string name, softstring key, softstring value) {\n        if (!Qorus.qmm.rLookupWorkflow(name))\n            throw \"UKNOWN-WORKFLOW\", sprintf(\"no workflow exists with name %y\", name);\n\n        # get workflow_instanceids\n        string sql = \"select workflow_instanceid\n                from order_instance_keys\n                where workflowid in (select workflowid from workflows where name = %v)\n                    and keyname = %v\n                    and value = %v\";\n        hash q;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                q = omqp.select(sql, name, key, value);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        # workflow access is checked in SegmentManager::getOrderInfoSummary()\n        return map SM.getOrderInfoSummary($1.workflow_instanceid), q.contextIterator();\n    }\n\n    #! Retrieves only order keys for workflow instance params: wfiid; output: hash\n    static *hash getWFIOrderKeysOnly(softint wfiid) {\n        # workflow access is checked in SegmentManager::getOrderKeysSQL()\n        return SM.getOrderKeysSQL(wfiid);\n    }\n\n    private *list<auto> searchOrderKeysPriv(string dsname, *hash params) {\n        AbstractTable workflows = getSqlTableSystemTrans(dsname, \"workflows\");\n        AbstractTable workflow_instance = getSqlTableSystemTrans(dsname, \"workflow_instance\");\n        AbstractTable order_instance_keys = getSqlTableSystemTrans(dsname, \"order_instance_keys\");\n\n        if (!params.limit)\n            params.limit = OptionHelper::getOption(\"row-limit\");\n\n        softlist val = params.orderby;\n        if (val) {\n            # process sort keys\n            hash kh;\n            foreach string k in (\\val) {\n                k = k.lwr();\n                kh{k} = True;\n                if (workflow_instance.describe().hasKey(k))\n                    continue;\n                if (workflows.describe().hasKey(k)) {\n                    k = \"w.\" + k;\n                    continue;\n                }\n                if (order_instance_keys.describe().hasKey(k)) {\n                    k = \"oik.\" + k;\n                    continue;\n                }\n\n                throw \"ORDER-SORT-ERROR\", sprintf(\"sort key %y is not valid; valid keys: %y\", k, (workflows.describe().getHash() + workflow_instance.describe().getHash() + order_instance_keys.describe().getHash()).keys());\n            }\n\n            # the sort key must also have a unique column set to ensure consistent sort order\n            if (!kh.workflow_instanceid)\n                val += \"workflow_instanceid\";\n            if (!kh.keyname)\n                val += \"oik.keyname\";\n            if (!kh.value)\n                val += \"oik.value\";\n\n            params.orderby = val;\n        }\n\n        if (params.desc) {\n            params.desc = parse_boolean(params.desc);\n            if (!params.orderby)\n                params.orderby = \"workflow_instanceid\";\n        }\n\n        # hash for where condition for SqlUtil\n        hash wcond;\n\n        *softdate d = params.mindate.val() ? params.mindate : NOTHING;\n        if (d)\n            wcond.\"oik.created\" = op_ge(d);\n        d = params.maxdate.val() ? params.maxdate : NOTHING;\n        if (d)\n            wcond.\"1:oik.created\" = op_lt(d);\n\n        val = params.workflowstatus;\n        if (val) {\n            # convert any long values to short codes\n            val = map StatMap.$1 ? StatMap.$1 : $1, val;\n            wcond.workflowstatus = val.size() > 1 ? op_in(val) : val[0];\n        }\n\n        # process workflow IDs & enforce workflow filter\n        process_workflow_id_and_name(\\wcond, params);\n\n        if (params.orderkeys) {\n            list ol = map (\"oik.keyname\": $1.key, \"oik.value\": do_cond_like_string($1.value)), params.orderkeys.pairIterator();\n            wcond += call_function_args(\\wop_or(), ol);\n        } else {\n            do_cond_like(\\wcond, \"oik.keyname\", params.keyname);\n            do_cond_like_string(\\wcond, \"oik.value\", params.value);\n        }\n\n        hash<auto> sh = (\n            \"comment\": \"qorus.info.searchOrderKeys\",\n            \"columns\": (\n                \"w.name\", \"w.version\", \"workflowid\", \"workflow_instanceid\", \"workflowstatus\",\n                \"status_sessionid\", \"started\", \"completed\", \"modified\", \"parent_workflow_instanceid\", \"synchronous\",\n                \"business_error\", \"operator_lock\", \"note_count\", cop_as(\"warnings\", \"warning_count\"),\n                cop_as(\"errors\", \"error_count\"), \"custom_status\", \"priority\", \"scheduled\", \"oik.keyname\", \"oik.value\",\n                \"oik.created\",\n            ),\n            \"join\": (join_inner(order_instance_keys, \"oik\") + join_inner(workflows, \"w\")),\n            \"where\": wcond,\n            \"limit\": params.limit,\n            \"offset\": params.offset,\n            \"orderby\": params.orderby,\n            \"desc\": params.desc,\n        );\n\n        #logDebug(\"params: %y wcond: %N\", params, wcond);\n\n        *list<auto> sqlresult;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                string sql;\n                sqlresult = workflow_instance.selectRows(sh, \\sql, SqlDataOpt);\n                logInfo(\"searchOrderKeys() sql: %s\", sql);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        if (sqlresult)\n            sqlresult = SM.processWorkflowResults(sqlresult);\n\n        return sqlresult;\n    }\n\n    #! returns a list of workflow instance info matching the input criteria\n    /** @param params a hash with one or more of the following keys:\n        - \\c keyname: one or more key names, in case a single value is given and it contains an '%%' character, the SQL like operator is used; this option cannot be used with the \\c orderkeys option\n        - \\c mindate: the minimum creation date for the key (inclusive: \">=\")\n        - \\c maxdate: the maximum creation date for the key (exclusive: \"<\")\n        - \\c limit: the maximum number of rows to return\n        - \\c offset: the offset row number to start returning values\n        - \\c orderby: one or more column names to order the return values by\n        - \\c orderkeys: a hash of key names to key values to be combined with \\c OR logic; this option cannot be used with the \\c keyname or \\c value options\n        - \\c value: the value of the key to find, in case a single value is given and it contains an '%%' character, the SQL like operator is used; this option cannot be used with the \\c orderkeys option\n        - \\c workflowid: one or more workflowids\n        - \\c workflowname: all accessible versions of the given workflow name\n        - \\c workflowstatus: one or more workflow order status values\n\n        @return @ref nothing if no rows match or a list of hashes with the following keys:\n        - \\c workflow_instanceid: the workflow order instance ID\n        - \\c workflowid: the workflow ID\n        - \\c name: the name of the workflow\n        - \\c version: the version of the workflow\n        - \\c workflowstatus: the status of the workflow order instance\n        - \\c started: the start date/time of the workflow order instance\n        - \\c completed: the completed date/time for the workflow order instance\n        - \\c modified: the last modified date/time of the workflow order instance\n        - \\c synchronous: the synchronous flag for the workflow order instance\n        - \\c business_error: the business error flag for the workflow order instance\n        - \\c archive: the archive flag for the workflow order instance (presented only if it goes from archive datasource)\n        - \\c operator_lock: the username of the user owning the lock on the workflow order instance data\n        - \\c note_count: the number of notes attached to the workflow order instance\n        - \\c warning_count: the warning count of the workflow order instance\n        - \\c error_count: the error count of the workflow order instance\n        - \\c custom_status: any custom status for the workflow order instance\n        - \\c priority: the priority of the workflow order instance\n        - \\c scheduled: the scheduled date for the workflow order instance\n        - \\c keyname: the order key name\n        - \\c value: the order key value\n        - \\c created: the date/time the order key was created\n\n        @throw SEARCH-ORDER-KEYS-ERROR thrown if the \\c orderkeys options and one of both of the \\c keyname or \\c value options are used in the same call\n\n        @since %Qorus 3.1.1 added support for the \\c orderkeys and \\c workflowname options\n    */\n    *list<auto> searchOrderKeys(hash params) {\n        if (params.orderkeys) {\n            if (params.hasKey(\"keyname\"))\n                throw \"SEARCH-ORDER-KEYS-ERROR\", \"info.searchOrderKeys() cannot have both \\\"orderkeys\\\" and \\\"keyname\\\" options in the same call\";\n            if (params.hasKey(\"value\"))\n                throw \"SEARCH-ORDER-KEYS-ERROR\", \"info.searchOrderKeys() cannot have both \\\"orderkeys\\\" and \\\"value\\\" options in the same call\";\n            if (params.orderkeys.typeCode() != NT_HASH)\n                throw \"SEARCH-ORDER-KEYS-ERROR\", sprintf(\"info.searchOrderKeys() argument \\\"orderkeys\\\" passed with type %y; expecting \\\"hash\\\"\", params.orderkeys.type());\n            if (params.orderkeys.size() == 1) {\n                params.keyname = params.orderkeys.firstKey();\n                params.value = params.orderkeys.firstValue();\n                delete params.orderkeys;\n            }\n        }\n\n        softint expected = params.limit ?? OptionHelper::getOption(\"row-limit\");\n\n        *list ret = searchOrderKeysPriv(\"omq\", params);\n        int lsize = ret.lsize();\n        if (lsize < expected && (*string dsarch = Qorus.props.get(\"arch\").datasource))\n            ret += map $1 + (\"archive\": True), searchOrderKeysPriv(dsarch, params + (\"limit\": expected - lsize));\n        return ret;\n    }\n\n    #! returns a summary of workflow processing for the given time period and optional workflow ID(s)\n    /** @param h a hash with the following keys:\n        - mindate: (required) the minimum date/time for the processing summary\n        - maxdate: (optional) the maximum date/time for the processing summary\n        - wfids: (optional) one or more workflowids for the processing summary\n        - seconds: (optional) if @ref True \"True\" then the performance values will be returned in integers representing seconds\n        - grouping: (optional) possible values for reporting performance statistics:\n        - \\c \"hourly\": hourly grouping\n        - \\c \"daily\": daily grouping\n        - \\c \"monthly\": monthly grouping\n        - \\c \"yearly\": yearly grouping\n        - global: (optional) if @ref True \"True\" then all workflows will be combined into an overall processing report, if @ref False \"False\" then each workflow gets a separate line in the output\n    */\n    static *list getWorkflowProcessingSummary(hash h) {\n        if (!h.mindate.val())\n            throw \"ARGUMENT-ERROR\", sprintf(\"missing 'mindate' key in argument hash in the call to info.getWorkflowProcessingSummary(); arg: %y\", h);\n\n        # time grouping SqlUtil column operator closure/call ref\n        *code tg;\n        if (h.grouping) {\n            tg = Grouping.(h.grouping);\n            if (!tg)\n                throw \"ARGUMENT-ERROR\", sprintf(\"invalid grouping argument %y; expecting one of: %y\", h.grouping, Grouping.keys());\n        }\n\n        # hash for where condition for SqlUtil\n        hash wcond;\n\n        # process workflow IDs & enforce workflow filter\n        h.wfids = get_accessible_workflows(h.wfids);\n        if (h.wfids)\n            wcond.workflowid = h.wfids;\n        #h.wfids.size() > 1 ? op_in(h.wfids) : h.wfids[0].toInt();\n\n        wcond += (\n            \"started\": op_ge(date(h.mindate)),\n            \"si.segmentid\": 0,\n            );\n\n        if (h.maxdate.val())\n            wcond.\"1:started\" = op_lt(date(h.maxdate));\n\n        bool global = parse_boolean(h.global);\n\n        # column list\n        list cols = ();\n        # group by list\n        list groupby = ();\n        # order by list\n        list orderby = ();\n\n        if (!global) {\n            cols += (\"workflowid\", \"w.name\", \"w.version\");\n            groupby += (\"workflowid\", \"w.name\", \"w.version\");\n            orderby += \"workflowid\";\n        }\n\n        if (tg) {\n            cols += cop_as(tg(\"started\"), \"grouping\");\n            groupby += tg(\"started\");\n            orderby += tg(\"started\");\n        }\n\n        cols += (\n                cop_as(cop_count(), \"count\"), cop_as(cop_min(\"started\"), \"minstarted\"),\n                cop_as(cop_max(\"completed\"), \"maxcompleted\"),\n                cop_as(cop_min(cop_minus(\"completed\", \"started\")), \"minduration\"),\n                cop_as(cop_avg(cop_minus(\"completed\", \"started\")), \"avgduration\"),\n                cop_as(cop_max(cop_minus(\"completed\", \"started\")), \"maxduration\"),\n                cop_as(cop_min(cop_minus(\"completed\", \"si.created\")), \"minprocessing\"),\n                cop_as(cop_avg(cop_minus(\"completed\", \"si.created\")), \"avgprocessing\"),\n                cop_as(cop_max(cop_minus(\"completed\", \"si.created\")), \"maxprocessing\"),\n            );\n\n        AbstractTable workflows = Qorus.dsmanager.getOmqTable(\"workflows\");\n        AbstractTable workflow_instance = Qorus.dsmanager.getOmqTable(\"workflow_instance\");\n        AbstractTable segment_instance = Qorus.dsmanager.getOmqTable(\"segment_instance\");\n\n        hash<auto> sh = {\n            \"comment\": \"qorus.info.getWorkflowProcessingSummary\",\n            \"columns\": cols,\n            \"join\": (join_inner(workflows, \"w\") + join_inner(segment_instance, \"si\")),\n            \"where\": wcond,\n            \"groupby\": groupby,\n            \"orderby\": orderby,\n        };\n\n        #logDebug(\"SH: %N\\n\", sh);\n\n        *list l;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                l = workflow_instance.selectRows(sh, SqlDataOpt);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        return QorusSystemInfoService::processIntervals(l, parse_boolean(h.seconds));\n    }\n\n    #! returns a summary of step processing for the given time period and optional step ID(s)\n    /** @param h a hash with the following keys:\n        - mindate: (required) the minimum date/time for the processing summary\n        - maxdate: (optional) the maximum date/time for the processing summary\n        - step: (optional) one or more step names\n        - stepids: (optional) one or more stepids for the processing summary\n        - seconds: (optional) if @ref True \"True\" then the performance values will be returned in integers representing seconds\n        - grouping: (optional) possible values for reporting performance statistics:\n        - \\c \"hourly\": hourly grouping\n        - \\c \"daily\": daily grouping\n        - \\c \"monthly\": monthly grouping\n        - \\c \"yearly\": yearly grouping\n        - global: (optional) if @ref True \"True\" then all workflows will be combined into an overall processing report, if @ref False \"False\" then each workflow gets a separate line in the output\n    */\n    static *list getStepProcessingSummary(hash h) {\n        if (!h.mindate.val())\n            throw \"ARGUMENT-ERROR\", sprintf(\"missing 'mindate' key in argument hash in the call to info.getWorkflowProcessingSummary(); arg: %y\", h);\n\n        # time grouping SqlUtil column operator closure/call ref\n        *code tg;\n        if (h.grouping) {\n            tg = Grouping.(h.grouping);\n            if (!tg)\n                throw \"ARGUMENT-ERROR\", sprintf(\"invalid grouping argument %y; expecting one of: %y\", h.grouping, Grouping.keys());\n        }\n\n        # hash for where condition for SqlUtil\n        hash wcond;\n\n        # process step IDs\n        if (h.stepids)\n            wcond.stepid = h.stepids;\n\n        if (h.step)\n            wcond.\"s.name\" = h.step;\n\n        wcond += (\n            \"started\": op_ge(date(h.mindate)),\n            );\n\n        if (h.maxdate.val())\n            wcond.\"1:started\" = op_lt(date(h.maxdate));\n\n        bool global = parse_boolean(h.global);\n\n        # column list\n        list cols = ();\n        # group by list\n        list groupby = ();\n        # order by list\n        list orderby = ();\n\n        if (!global) {\n            cols += (\"stepid\", \"s.name\", \"s.version\");\n            groupby += (\"stepid\", \"s.name\", \"s.version\");\n            orderby += \"stepid\";\n        }\n\n        if (tg) {\n            cols += cop_as(tg(\"started\"), \"grouping\");\n            groupby += tg(\"started\");\n            orderby += tg(\"started\");\n        }\n\n        cols += (\n                cop_as(cop_count(), \"count\"), cop_as(cop_min(\"started\"), \"minstarted\"),\n                cop_as(cop_max(\"completed\"), \"maxcompleted\"),\n                cop_as(cop_min(cop_minus(\"completed\", \"started\")), \"minduration\"),\n                cop_as(cop_avg(cop_minus(\"completed\", \"started\")), \"avgduration\"),\n                cop_as(cop_max(cop_minus(\"completed\", \"started\")), \"maxduration\"),\n            );\n\n        AbstractTable steps = Qorus.dsmanager.getOmqTable(\"steps\");\n        AbstractTable step_instance = Qorus.dsmanager.getOmqTable(\"step_instance\");\n\n        hash<auto> sh = {\n            \"comment\": \"qorus.info.getStepProcessingSummary\",\n            \"columns\": cols,\n            \"join\": (join_inner(steps, \"s\")),\n            \"where\": wcond,\n            \"groupby\": groupby,\n            \"orderby\": orderby,\n        };\n\n        #logDebug(\"SH: %N\\n\", sh);\n\n        *list l;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                l = step_instance.selectRows(sh, SqlDataOpt);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        return QorusSystemInfoService::processIntervals(l, parse_boolean(h.seconds));\n    }\n\n    private *list searchWorkflowErrorsPriv(string dsname, hash params) {\n        logDebug(\"searchWorkflowErrors(): h: %y\", params);\n\n        AbstractTable workflows = getSqlTableSystemTrans(dsname, \"workflows\");\n        AbstractTable workflow_instance = getSqlTableSystemTrans(dsname, \"workflow_instance\");\n        AbstractTable error_instance = getSqlTableSystemTrans(dsname, \"error_instance\");\n        AbstractTable steps = getSqlTableSystemTrans(dsname, \"steps\");\n\n        softlist val = params.orderby;\n        if (val) {\n            # process sort keys\n            hash kh;\n            foreach string k in (\\val) {\n                k = k.lwr();\n                kh{k} = True;\n                if (workflow_instance.describe().hasKey(k)) {\n                    k = \"wi.\" + k;\n                    continue;\n                }\n                if (workflows.describe().hasKey(k)) {\n                    k = \"w.\" + k;\n                    continue;\n                }\n                if (error_instance.describe().hasKey(k))\n                    continue;\n\n                throw \"ORDER-SORT-ERROR\", sprintf(\"sort key %y is not valid; valid keys: %y\", k, (workflows.describe().getHash() + workflow_instance.describe().getHash() + error_instance.describe().getHash()).keys());\n            }\n\n            # the sort key must also have a unique column set to ensure consistent sort order\n            if (!kh.error_instanceid)\n                val += \"error_instanceid\";\n\n            params.orderby = val;\n        }\n        else\n            params.orderby = \"error_instanceid\";\n\n        if (params.desc) {\n            params.desc = parse_boolean(params.desc);\n            if (!params.orderby)\n                params.orderby = \"workflow_instanceid\";\n        }\n\n        # hash for where condition for SqlUtil\n        hash wcond;\n\n        do_cond_like(\\wcond, \"error\", params.error);\n        do_cond_like(\\wcond, \"description\", params.description);\n        # bug 853: info.searchWorkflowErrors() fails on oracle if any value is given to the \"info\" key\n        do_cond_like(\\wcond, \"info\", params.info, qdriver == \"oracle\");\n\n        do_cond_int(\\wcond, \"stepid\", params.stepid);\n\n        do_cond(\\wcond, \"severity\", params.severity);\n\n        do_cond(\\wcond, \"s.name\", params.stepname);\n        do_cond(\\wcond, \"s.version\", params.stepversion);\n\n        do_cond_bool(\\wcond, \"retry\", params.retry);\n        do_cond_bool(\\wcond, \"business_error\", params.business_error, True);\n\n        do_cond_int(\\wcond, \"wi.workflow_instanceid\", params.workflow_instanceid);\n        do_cond_int(\\wcond, \"error_instanceid\", params.error_instanceid);\n\n        *softdate d = params.mindate.val() ? params.mindate : NOTHING;\n        if (d)\n            wcond.\"created\" = op_ge(d);\n        d = params.maxdate.val() ? params.maxdate : NOTHING;\n        if (d)\n            wcond.\"1:created\" = op_lt(d);\n\n        val = params.workflowstatus;\n        if (val) {\n            # convert any long values to short codes\n            val = map StatMap.$1 ? StatMap.$1 : $1, val;\n            wcond.\"wi.workflowstatus\" = val.size() > 1 ? op_in(val) : val[0];\n        }\n\n        # process workflow IDs & enforce workflow filter\n        params.workflowid = get_accessible_workflows(params.workflowid);\n        if (params.workflowid)\n            wcond.\"wi.workflowid\" = params.workflowid;\n\n        if (!params.limit)\n            params.limit = OptionHelper::getOption(\"row-limit\");\n\n        hash sh = (\n            \"comment\": \"qorus.info.searchWorkflowErrors\",\n            \"columns\": (\"w.name\", \"w.version\", \"wi.workflow_instanceid\", \"wi.workflowid\", \"stepid\", cop_as(\"s.name\", \"stepname\"), cop_as(\"s.version\", \"stepversion\"), \"ind\", \"wi.workflowstatus\", \"wi.started\", \"wi.completed\", \"wi.parent_workflow_instanceid\", \"wi.custom_status\", \"wi.priority\", \"wi.scheduled\", \"error_instanceid\", \"error\", \"description\", \"info\", \"severity\", \"created\", \"retry\", \"business_error\"),\n            \"join\": (join_inner(workflow_instance, \"wi\") + join_inner(\"wi\", workflows, \"w\", (\"workflowid\": \"workflowid\")) + join_inner(steps, \"s\", (\"stepid\": \"stepid\"))),\n            \"where\": wcond,\n            \"limit\": params.limit,\n            \"offset\": params.offset,\n            \"orderby\": params.orderby,\n            \"desc\": params.desc,\n        );\n\n        #logDebug(\"SH: %N\", sh - \"join\");\n\n        *list sqlresult;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                sqlresult = error_instance.selectRows(sh, SqlDataOpt);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        if (sqlresult) {\n            sqlresult = SM.processWorkflowResults(sqlresult);\n            sqlresult = map $1 + (\"info\": deserializeQorusData($1.info)), sqlresult;\n        }\n\n        return sqlresult;\n    }\n\n    #! returns a list of matching errors for the input criteria\n    /** @param h a hash with the following keys:\n        - orderby: one or more field names for sorting the output\n        - error: the error text to search (can also include '%%' characters for use with the LIKE operator; in this case only 1 value can be given)\n        - description: the description text to search (can also include '%%' characters for use with the LIKE operator; in this case only 1 value can be given)\n        - info: the info text to search (can also include '%%' characters for use with the LIKE operator; in this case only 1 value can be given\n        - stepid: limit the search to one or more stepids\n        - severity: limit the search to one or more severity values\n        - name: limit the search to one or more step names\n        - version: limit the search to one or more step versions\n        - retry: limit the search to errors with or without the retry flag\n        - business_error: limit the search to errors with or without the business_error flag\n        - workflow_instanceid:  limit the search to one or more workflow_instanceids\n        - error_instanceid: mit the search to one or more error_instanceids\n        - mindate: give the lower date range for the error search\n        - maxdate: give the upper date range for the error search\n        - workflowid: limit the search to one or more workflowids\n        - workflowstatus: limit the search to workflow instances with the given status value(s)\n        - limit: the maximum number of errors to return; note that if this parameter is not given then the \\c row-limit option is assumed\n        - offset: the starting error to return (use when paging for example)\n\n        @return @ref nothing if no rows match or a list of hashes with the following keys:\n        - \\c name: the workflow name\n        - \\c version: the workflow version\n        - \\c workflow_instanceid: the workflow order instance ID\n        - \\c workflowid: the workflow ID\n        - \\c stepid: the stepid of the step where the error was raised (could be @ref null if the error was not raised in a workflow step)\n        - \\c stepname: the step name of the step where the error was raised (could be @ref null if the error was not raised in a workflow step)\n        - \\c stepversion: the step version of the step where the error was raised (could be @ref null if the error was not raised in a workflow step)\n        - \\c ind: the step array index (starting from 0) of the step where the error was raised (could be @ref null if the error was not raised in a workflow step)\n        - \\c workflowstatus: the status of the workflow order instance\n        - \\c started: the start date/time of the workflow order instance\n        - \\c completed: the completed date/time for the workflow order instance\n        - \\c parent_workflow_instanceid: the parent workflow_instanceid if the workflow is a child workflow order\n        - \\c custom_status: any custom status for the workflow order instance\n        - \\c priority: the priority of the workflow order instance\n        - \\c scheduled: the scheduled date for the workflow order instance\n        - \\c error_instanceid: the error ID\n        - \\c error: the error name\n        - \\c description: the error description\n        - \\c info: the error info string\n        - \\c severity: the severity of the error\n        - \\c created: the created date and time of the error\n        - \\c retry: indicates if the error will get a retry status\n        - \\c business_error: indicates if the error is a business error\n        - \\c archive: if retrieved from the archive datasource\n    */\n    softlist searchWorkflowErrors(hash h) {\n        logDebug(\"searchWorkflowErrors(): h: %y\", h);\n\n        softint expected = h.limit ?? OptionHelper::getOption(\"row-limit\");\n        softlist ret = searchWorkflowErrorsPriv(\"omq\", h);\n        int lsize = ret.lsize();\n        if (lsize < expected && (*string dsarch = Qorus.props.get(\"arch\").datasource))\n            ret += map $1 + (\"archive\": True), searchWorkflowErrorsPriv(dsarch, h + (\"limit\": expected - lsize));\n        return ret;\n    }\n\n    private *list searchReleasesPriv(string dsname, *hash params) {\n        logDebug(\"searchReleases(): h: %y\", params);\n\n        AbstractTable releases = getSqlTableSystemTrans(dsname, \"releases\");\n        AbstractTable release_files = getSqlTableSystemTrans(dsname, \"release_files\");\n        AbstractTable release_file_contents = getSqlTableSystemTrans(dsname, \"release_file_contents\");\n\n        params.with_files = parse_boolean(params.with_files);\n        params.with_components = parse_boolean(params.with_components);\n\n        if (!params.limit)\n            params.limit = OptionHelper::getOption(\"row-limit\");\n\n        softlist val = params.orderby;\n        if (val) {\n            # process sort keys\n            hash kh;\n            foreach string k in (\\val) {\n                k = k.lwr();\n                kh{k} = True;\n                if (releases.describe().hasKey(k))\n                    continue;\n\n                if (release_files.describe().hasKey(k)) {\n                    params.with_files = True;\n\n                    k = \"rf.\" + k;\n                    continue;\n                }\n                if (release_file_contents.describe().hasKey(k)) {\n                    params.with_files = True;\n                    params.with_components = True;\n                    k = \"rfc.\" + k;\n                    continue;\n                }\n\n                hash vkh = releases.describe().getHash();\n                if (params.with_files) {\n                    vkh += release_files.describe().getHash();\n                    if (params.with_components)\n                        vkh += release_file_contents.describe().getHash();\n                }\n                throw \"ORDER-SORT-ERROR\", sprintf(\"sort key %y is not valid; valid keys: %y\", k, vkh.keys());\n            }\n\n            # the sort key must also have a unique column set to ensure consistent sort order\n            if (!kh.release_name)\n                val += \"release_name\";\n\n            params.orderby = val;\n        }\n        else\n            params.orderby = \"release_name\";\n\n        # columns for select\n        list cols = (\"release_name\", \"description\", \"os_user\", \"os_host\", \"created\", \"modified\");\n\n        # hash for where condition for SqlUtil\n        hash wcond;\n\n        do_cond(\\wcond, \"release_name\", params.name);\n\n        if (params.file_name) {\n            params.with_files = True;\n            do_cond_like(\\wcond, \"rf.file_name\", '%' + params.file_name + '%');\n        }\n\n        {\n            *softdate d = params.mindate.val() ? params.mindate : NOTHING;\n            if (d)\n                wcond.created = op_ge(d);\n            d = params.maxdate.val() ? params.maxdate : NOTHING;\n            if (d)\n                wcond.\"1:created\" = op_lt(d);\n\n            d = params.file_mindate.val() ? params.file_mindate : NOTHING;\n            if (d) {\n                params.with_files = True;\n                wcond.\"rf.created\" = op_ge(d);\n            }\n            d = params.file_maxdate.val() ? params.file_maxdate : NOTHING;\n            if (d) {\n                params.with_files = True;\n                wcond.\"1:rf.created\" = op_lt(d);\n            }\n\n            d = params.content_mindate.val() ? params.content_mindate : NOTHING;\n            if (d) {\n                params.with_files = True;\n                params.with_components = True;\n                wcond.\"rfc.created\" = op_ge(d);\n            }\n            d = params.content_maxdate.val() ? params.content_maxdate : NOTHING;\n            if (d) {\n                params.with_files = True;\n                params.with_components = True;\n                wcond.\"1:rfc.created\" = op_lt(d);\n            }\n        }\n\n        if (params.component) {\n            params.with_files = True;\n            params.with_components = True;\n            do_cond_like(\\wcond, \"rfc.component\", '%' + params.component + '%');\n        }\n\n        if (params.with_components)\n            params.with_files = True;\n\n        hash jh;\n        if (params.with_files) {\n            cols += (\"rf.file_name\", \"rf.file_type\", \"rf.in_db\",\n                    cop_as(\"rf.hash_type\", \"file_hash_type\"), cop_as(\"rf.hash\", \"file_hash\"),\n                    cop_as(\"rf.created\", \"file_created\"), cop_as(\"rf.modified\", \"file_modified\"),\n                );\n\n            jh = join_inner(release_files, \"rf\");\n            if (params.with_components) {\n                cols += (cop_as(\"rfc.id\", \"content_id\"), \"rfc.component\", \"rfc.component_version\", \"rfc.component_id\",\n                        cop_as(\"rfc.hash_type\", \"component_hash_type\"), cop_as(\"rfc.hash\", \"component_hash\"),\n                        cop_as(\"rfc.created\", \"component_created\"), cop_as(\"rfc.modified\", \"component_modified\"),\n                    );\n                do_cond(\\wcond, \"rfc.component\", params.component);\n                jh += join_inner(\"rf\", release_file_contents, \"rfc\");\n            }\n        }\n\n        QorusRestartableTransaction trans();\n\n        # issue #1931: first get release names to ensure that \"limit\" and \"offset\" apply only to the releases table\n        {\n            list c = (\"release_name\",);\n            list groupby = c;\n\n            c += cop_count();\n\n            hash sh = (\n                \"comment\": \"qorus.info.searchReleases-1\",\n                \"columns\": c,\n                \"where\": wcond,\n                \"join\": jh,\n                \"limit\": params.limit,\n                \"offset\": params.offset,\n                \"groupby\": groupby,\n            );\n            string sql;\n            hash h;\n            while (True) {\n                try {\n                    # we can just release the lock because the query is read-only\n                    on_error omqp.rollback();\n\n                    h = releases.select(sh, \\sql);\n                } catch (hash<ExceptionInfo> ex) {\n                    # restart the transaction if necessary\n                    if (trans.restartTransaction(ex))\n                        continue;\n                    rethrow;\n                }\n                break;\n            }\n            trans.reset();\n            wcond.release_name = op_in(h.release_name);\n            #logDebug(\"searchReleases SQL 0: %s; releases: %y\", sql, wcond.release_name);\n        }\n\n        hash sh = (\n            \"comment\": \"qorus.info.searchReleases-2\",\n            \"columns\": cols,\n            \"where\": wcond,\n            \"join\": jh,\n        );\n\n        string sql;\n        *list l;\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                l = releases.selectRows(sh, \\sql, SqlDataOpt);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n        #logDebug(\"searchReleases sh: %y SQL 1: %s\", sh, sql);\n        return l[0].hasKey(\"in_db\") ? (map $1 + (\"in_db\": boolean($1.in_db)), l) : l;\n    }\n\n    #! returns release info\n    /** @param params search parameters with the following optional keys:\n        - \\c component: the component name to search for (implies <tt>with_files = True</tt> and <tt>with_components = True</tt>)\n        - \\c component_maxdate: give the upper date range for the release search for component (implies <tt>with_files = True</tt> and <tt>with_components = True</tt>)\n        - \\c component_mindate: give the lower date range for the release search for component (implies <tt>with_files = True</tt> and <tt>with_components = True</tt>)\n        - \\c file_maxdate: give the upper date range for the release search for files (implies <tt>with_files = True</tt>)\n        - \\c file_mindate: give the lower date range for the release search for files (implies <tt>with_files = True</tt>)\n        - \\c file_name: the file name to search for; note that this is used with the SQL like operator (implies <tt>with_files = True</tt>)\n        - \\c limit: the maximum number of releases to return\n        - \\c maxdate: give the upper date range for the release search\n        - \\c mindate: give the lower date range for the release search\n        - \\c offset: the starting release to return (use when paging for example)\n        - \\c with_components: if @ref True then file components are included (implies <tt>with_files = True</tt>)\n        - \\c with_files: if @ref True then release files are included\n        */\n    *list searchReleases(*hash params) {\n        softint expected = params.limit ?? OptionHelper::getOption(\"row-limit\");\n\n        *list ret = searchReleasesPriv(\"omq\", params);\n        int lsize = ret.lsize();\n        if (lsize < expected && (*string dsarch = Qorus.props.get(\"arch\").datasource))\n            ret += map $1 + (\"archive\": True), searchReleasesPriv(dsarch, params + (\"limit\": expected - lsize));\n        return ret;\n    }\n\n    private *list searchSessionsPriv(string dsname, *hash params) {\n        logDebug(\"searchSessions(): h: %y\", params);\n\n        AbstractTable sessions = getSqlTableSystemTrans(dsname, \"sessions\");\n\n        if (!params.limit)\n            params.limit = OptionHelper::getOption(\"row-limit\");\n\n        softlist val = params.orderby;\n        if (val) {\n            Columns c = sessions.describe();\n            # process sort keys\n            hash kh;\n            foreach string k in (\\val) {\n                k = k.lwr();\n                bool desc;\n                if (k[0] == \"-\") {\n                    k = k.substr(1);\n                    desc = True;\n                }\n                string key = SessionColumnMap{k} ?? k;\n                if (desc)\n                    kh{\"-\" + key} = True;\n                else\n                    kh{key} = True;\n                if (c.hasKey(key))\n                    continue;\n\n                throw \"ORDER-SORT-ERROR\", sprintf(\"sort key %y is not valid; valid keys: %y\", k, c.keys());\n            }\n\n            # the sort key must also have a unique column set to ensure consistent sort order\n            if (!kh.sessionid)\n                kh.sessionid = True;\n\n            params.orderby = kh.keys();\n        }\n        else\n            params.orderby = \"sessionid\";\n\n        # columns for select\n        list cols = (cop_as(\"sessionid\", \"id\"), cop_as(\"instancekey\", \"key\"), cop_as(\"sessionstatus\", \"status\"),\n            \"hostname\", cop_as(\"xmlrpc_server\", \"url\"), \"version\", \"started\", \"ended\");\n\n        # hash for where condition for SqlUtil\n        hash wcond;\n\n        if (params.hasKey(\"id\"))\n            do_cond(\\wcond, \"sessionid\", params.id.toInt());\n        do_cond(\\wcond, \"instancekey\", params.key);\n        do_cond(\\wcond, \"version\", params.version);\n        do_cond(\\wcond, \"hostname\", params.hostname);\n        do_cond(\\wcond, \"status\", params.sessionstatus);\n        do_cond(\\wcond, \"xmlrpc_server\", params.url);\n\n        {\n            *softdate d = params.started_mindate.val() ? params.started_mindate : NOTHING;\n            if (d)\n                wcond.\"started\" = op_ge(d);\n            d = params.started_maxdate.val() ? params.started_maxdate : NOTHING;\n            if (d)\n                wcond.\"1:started\" = op_lt(d);\n            d = params.ended_mindate.val() ? params.ended_mindate : NOTHING;\n            if (d)\n                wcond.\"ended\" = op_ge(d);\n            d = params.ended_maxdate.val() ? params.ended_maxdate : NOTHING;\n            if (d)\n                wcond.\"1:ended\" = op_lt(d);\n        }\n\n        hash sh = (\n            \"comment\": \"qorus.info.searchSessions\",\n            \"columns\": cols,\n            \"where\": wcond,\n            \"limit\": params.limit,\n            \"offset\": params.offset,\n            \"orderby\": params.orderby,\n            \"desc\": params.desc,\n        );\n\n        #logDebug(\"sh: %N\", sh);\n        *list l;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                l = sessions.selectRows(sh, SqlDataOpt);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        return l;\n    }\n\n    #! returns information about application sessions\n    /** @param params search parameters with the following optional keys:\n        - \\c ended_maxdate: give the upper date range for the session end date\n        - \\c ended_mindate: give the lower date range for the session end date\n        - \\c hostname: the hostname to search for\n        - \\c id: the session ID\n        - \\c key: the instance key name\n        - \\c limit: the maximum number of releases to return\n        - \\c started_maxdate: give the upper date range for the session start date\n        - \\c started_mindate: give the lower date range for the session start date\n        - \\c offset: the starting release to return (use when paging for example)\n        - \\c status: one or more session status values\n        - \\c url: the HTTP URL for the instance\n        - \\c version: the Qorus version string\n        */\n    *list searchSessions(*hash params) {\n        softint expected = params.limit ?? OptionHelper::getOption(\"row-limit\");\n\n        *list ret = searchSessionsPriv(\"omq\", params);\n        int lsize = ret.lsize();\n        if (lsize < expected && (*string dsarch = Qorus.props.get(\"arch\").datasource))\n            ret += map $1 + (\"archive\": True), searchSessionsPriv(dsarch, params + (\"limit\": expected - lsize));\n        return ret;\n    }\n\n    #! returns a hash of event type names with lists of unposted events for each, params: event ID(s), [last modified date]\n    /** @param ids NOTHING or one or more event type IDs to check\n        @param lastmod an optional last modified date; if present, then only records modified after the given date will be returned\n        @param rownum maximum rowz returned\n        @param offset row offset for return values\n        @return NOTHING if no events are available, or a hash keyed by the event type name where each value is a list of event keys\n    */\n    *hash getUnpostedEvents(*softlist ids, *softdate lastmod = now() - 6M, softint rownum = OptionHelper::getOption(\"row-limit\"), *int offset) {\n        AbstractTable workflow_events = getSqlTableSystemTrans(\"omq\", \"workflow_events\");\n        AbstractTable workflow_event_types = getSqlTableSystemTrans(\"omq\", \"workflow_event_types\");\n\n        hash wcond = (\n            \"modified\": op_gt(lastmod),\n            \"event_posted\": 0,\n        );\n\n        if (ids)\n            wcond.workflow_event_typeid = op_in(ids);\n\n        hash sh = (\n            \"comment\": \"qorus.info.getUnpostedEvents\",\n            \"columns\": (\"t.name\", \"eventkey\"),\n            \"where\": wcond,\n            \"join\": join_inner(workflow_event_types, \"t\"),\n            \"limit\": rownum,\n            \"offset\": offset,\n        );\n\n        hash q;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                q = workflow_events.select(sh);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        hash h;\n        context (q) {\n            if (!exists h.%name)\n                h.%name = ();\n            h.%name += %eventkey;\n        }\n\n        return h;\n    }\n\n    #! returns a hash of event type names with lists of unposted events for each, params: event type name, [last modified date]\n    /** @param eventname the event type name to query\n        @param lastmod an optional last modified date; if present, then only records modified after the given date will be returned\n        @return NOTHING if no events are available, or a hash keyed by the event type name where each value is a list of event keys\n\n        @throw UNKNOWN-EVENT the event name passed is invalid\n    */\n    *hash getUnpostedEventsFromName(string eventname, *softdate lastmod) {\n        # get event type id\n\n        *softint id = Qorus.qmm.rLookupEvent(eventname).workflow_event_typeid;\n        if (!id)\n            throw \"UNKNOWN-EVENT\", sprintf(\"event %y cannot be mapped to an event type ID\", eventname);\n\n        return getUnpostedEvents(id, lastmod);\n    }\n\n    private list searchEventsPriv(string dsname, *hash h) {\n        AbstractTable workflow_events = getSqlTableSystemTrans(dsname, \"workflow_events\");\n        AbstractTable workflow_event_types = getSqlTableSystemTrans(dsname, \"workflow_event_types\");\n\n        if (!h.limit)\n            h.limit = OptionHelper::getOption(\"row-limit\");\n\n        if (h.desc)\n            h.desc = parse_boolean(h.desc);\n\n        if (h.sort) {\n            if (h.sort && h.sort =~ /,/)\n                h.sort = h.sort.split(\",\");\n\n            # process sort keys\n            bool he;\n            foreach string k in (\\h.sort) {\n                k = k.lwr();\n                if (!workflow_event_types.describe().hasKey(k) && !workflow_events.describe().hasKey(k))\n                    throw \"ORDER-SORT-ERROR\", sprintf(\"sort key %y is not valid; valid keys: %y\", k, (workflow_event_types.describe().getHash() + workflow_events.describe().getHash()).keys());\n                if (k == \"eventkey\")\n                    he = True;\n            }\n\n            # the sort key must also have a unique column to ensure consistent sort order\n            if (!he) {\n                if (h.sort.typeCode() != NT_LIST)\n                    h.sort = (h.sort,);\n                h.sort += \"eventkey\";\n            }\n        } else if (h.desc)\n            h.sort = \"eventkey\";\n\n        hash wcond;\n\n        if (h.posted.val())\n            wcond.event_posted = h.posted.toInt();\n\n        if (h.modified.val())\n            wcond.modified = op_ge(date(h.modified));\n        if (h.maxmodified.val())\n            wcond.\"1:modified\" = op_lt(date(h.maxmodified));\n\n        if (h.eventkey)\n            wcond.eventkey = h.eventkey;\n        if (h.eventname)\n            wcond.\"t.name\" = h.eventname;\n\n        if (h.id && h.id =~ /,/)\n            h.id = h.id.split(\",\");\n\n        if (h.id) {\n            if (h.id.lsize() > 1)\n                wcond.workflow_event_typeid = op_in(map $1.toInt(), h.id);\n            else if (h.id.typeCode() == NT_LIST)\n                wcond.workflow_event_typeid = h.id[0].toInt();\n            else\n                wcond.workflow_event_typeid = h.id.toInt();\n        }\n\n        # do not return the default system event\n        wcond.\"1:workflow_event_typeid\" = op_ne(0);\n\n        hash sh = {\n            \"comment\": \"qorus.info.getEvents\",\n            \"columns\": (cop_as(\"workflow_event_typeid\", \"id\"), cop_as(\"t.name\", \"eventname\"), \"eventkey\", cop_as(\"event_posted\", \"posted\"), \"created\", \"modified\"),\n            \"where\": wcond,\n            \"join\": join_inner(workflow_event_types, \"t\"),\n            \"limit\": h.limit,\n            \"offset\": h.offset,\n        };\n\n        string sql;\n        *list l;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                l = map ($1 + (\"posted\": $1.posted.toBool())), workflow_events.selectRows(sh, \\sql);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        #logDebug(\"searchEvents: sql: %s\", sql);\n        return l;\n    }\n\n    #! returns workflow synchronization event information\n    /** @param h a hash with the following optional keys:\n        - \\c \"desc\": return in descending order\n        - \\c \"eventkey\": the event key name\n        - \\c \"eventname\": the event type name\n        - \\c \"id\": one or more event type IDs\n        - \\c \"limit\": max number of rows to return, if not given, then the value of the \\a \"row-limit\" option is used (default: 100)\n        - \\c \"maxmodified\": maximum modified date\n        - \\c \"modified\": minimum modified date\n        - \\c \"offset\": row offset\n        - \\c \"posted\": the event posted status\n        - \\c \"sort\": columns for sorting the results\n\n        @since Qorus 3.1.0\n    */\n    list searchEvents(*hash h) {\n        #logDebug(\"searchEvents(): h: %y\", h);\n        softint expected = h.limit ?? OptionHelper::getOption(\"row-limit\");\n\n        *list ret = searchEventsPriv(\"omq\", h);\n        int lsize = ret.lsize();\n        if (lsize < expected && (*string dsarch = Qorus.props.get(\"arch\").datasource))\n            ret += map $1 + (\"archive\": True), searchEventsPriv(dsarch, h + (\"limit\": expected - lsize));\n        return ret;\n    }\n\n    #! gets job overview, params: [date, [jobids]]: If no date is given, default = last 24 hours\n    /** @param date the minimum date to check for changes; job_instance rows with a modified date before this date will not be reported; the default value is 24 hours from the current date and time\n        @param jobids the jobs IDs to query\n        @param useSqlCache if the sql cache should be used\n\n        @return NOTHING if no information is available, otherwise a hash where the keys are job names and the values are hashes with the following keys:\n        - \\c jobid: the jobid of the job\n        - \\c version: the version of the job\n        - [\\c COMPLETE]: the number of job instances with status @ref OMQ::JS_Complete in the given time frame\n        - [\\c ERROR]: the number of job instances with status @ref OMQ::JS_Complete in the given time frame\n        - [\\c IN-PROGRESS]: the number of job instances with status @ref OMQ::JS_InProgress in the given time frame (should never be > 1 for a given job)\n        - [\\c CRASH]: the number of job instances with status @ref OMQ::JS_Crash in the given time frame\n\n        @throw PARAMETER-ERROR the date passed was not valid\n        @throw JOB-ACCESS-ERROR @ref RBAC is enabled and the user does not have access to the given job\n\n        @note if this method is called externally, and the user has a limited list of accessible jobs, then only information about the jobs the user can access is returned; if the user requests a particular job and does not have access to that job, then a \\c JOB-ACCESS-ERROR exception is raised\n    */\n    static *hash getJobOverview(softdate date = now() - 1D, auto jobids, bool useSqlCache = True) {\n        # check parameters\n        if (date < 1000-01-01)\n            throw \"PARAMETER-ERROR\", sprintf(\"first parameter must be a valid date or NOTHING (given: %y)\", date);\n\n        hash rv;\n        context (sqlHandler.getJobOverview(date, jobids, useSqlCache)) sortBy (%name) {\n            rv.%name.(OMQ::SQLJSMap.%jobstatus) = int(%total);\n            rv.%name += (\n                \"jobid\": int(%jobid),\n                \"version\": %version,\n            );\n        }\n\n        return rv;\n    }\n\n    #! gets job overview, params: [date, [name]]: If no date is given, default = last 24 hours\n    /** @param date the minimum date to check for changes; job_instance rows with a modified date before this date will not be reported; the default value is 24 hours from the current date and time\n        @param name the optional name of the job to check; if no name is passed, then all accessible jobs will be reported\n        @param useSqlCache if the sql cache should be used\n\n        @return see getJobOverview() for the return value\n\n        @throw UNKNOWN-JOB the job name given does not exist\n        @throw PARAMETER-ERROR the date passed was not valid\n        @throw JOB-ACCESS-ERROR @ref RBAC is enabled and the user does not have access to the given job\n\n        @note if this method is called externally, and the user has a limited list of accessible jobs, then only information about the jobs the user can access is returned; if the user requests a particular job and does not have access to that job, then a \\c JOB-ACCESS-ERROR exception is raised\n    */\n    static *hash getJobOverviewFromName(softdate date = now() - 1D, *string name, bool useSqlCache = True) {\n        *int jobid;\n        if (exists name) {\n            jobid = Qorus.qmm.rLookupJob(name).jobid;\n            if (!exists jobid)\n                throw \"UNKNOWN-JOB\", sprintf(\"job %y does not exist\", name);\n        }\n\n        return QorusSystemInfoService::getJobOverview(date, jobid, useSqlCache);\n    }\n\n    #! retrieves job metadata (optional params: list of job ids), returns: job info keyed by name\n    /** @return NOTHING if no job can be matched to any of the given ids (or no jobs are in the system if no id is passed), or a hash keyed by job name where the value is a hash of job information with the following keys:\n        - \\c name: the unique name of the job\n        - \\c jobid: the unique job ID\n        - \\c description: job description\n        - \\c version: version number of the job\n        - \\c sessionid: session where the job is running\n        - \\c active: \\c True if active, \\c False if not\n        - \\c run_skipped: \\c True if the job should be executed immediately if a trigger time was missed due to down time, \\c False if not\n        - \\c code: the source code of the job\n        - [\\c recurring]: if this field is present, this gives the number of seconds between job executions, and the cron fields will not be present\n        - [\\c minute]: cron field: minutes when the job can be executed\n        - [\\c hour]: cron field: hours when the job can be executed\n        - [\\c day]: cron field: days when the job can be executed\n        - [\\c month]: cron field: months when the job can be executed\n        - [\\c wday]: cron field: week days (0 = Sunday) when the job can be executed\n        - [\\c last_executed]: the date/time the job was last executed (if not present, the job has not yet been executed)\n        - [\\c last_executed_job_instanceid]: the last executed instance id of the job\n        - [\\c expiry_date]: the date/time the job will expire; if this date is present, the job will not run automatically after this date\n        - \\c created: the date/time the job was loaded into the database\n        - \\c modified: the date/time the job was modified in the database\n        - \\c lib: a hash keyed by library object type (key values: \\c \"functions\", \\c \"classes\", \\c \"constants\"); the\n          value of each key will be a list of hashes with the following keys (empty lists mean no objects of that type\n          are listed as library objects of the workflow):\n          - \\c name: the name of the library object\n          - \\c version: the version of the library object\n          - \\c id: the ID of the library object (referencing the tables, \\c FUNCTION_INSTANCE, \\c CLASSES, or \\c CONSTANTS)\n        - \\c groups: a list of RBAC group names that this job is a member of\n\n        @throw JOB-ACCESS-ERROR @ref RBAC is enabled and the user does not have access to the given job\n    */\n    *hash getJobMetadata() {\n        if (exists argv && exists argv[0]) {\n            checkJobAccess(argv);\n        } else {\n            argv = getJobAccessList();\n        }\n\n        hash sql = (\n            \"orderby\" : \"name\",\n        );\n\n        if (exists argv && exists argv[0]) {\n            sql.where = {\"jobid\": op_in(argv)};\n        }\n\n        SqlUtil::AbstractTable jobs = getSqlTableSystemTrans(\"omq\", \"jobs\");\n        hash job_metadata;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                job_metadata = jobs.select(sql);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        return processJobMetadata(job_metadata);\n    }\n\n    #! retrieves job metadata from the name, returns: job info keyed by name\n    /** @param name the name of the job to query\n        @return see getJobMetadata() for information about the return value\n\n        @throw JOB-ACCESS-ERROR @ref RBAC is enabled and the user does not have access to the given job\n    */\n    *hash getJobMetadataFromName(string name) {\n        if (!strlen(name))\n            throw \"PARAMETER-ERROR\", \"name is a required parameter for info.getJobMetadataFromName()\";\n\n        hash sql = (\n            \"where\"   : (\n                \"name\" : name,\n            ),\n        );\n        SqlUtil::AbstractTable jobs = getSqlTableSystemTrans(\"omq\", \"jobs\");\n        hash rv;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                rv = jobs.select(sql);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        if (rv.jobid) {\n            checkJobAccess(rv.jobid);\n        }\n\n        return processJobMetadata(rv);\n    }\n\n    #! retrieves a list of all jobs without the code field\n    /** @return a list of hashes with the following keys for all jobs in the database:\n        - \\c name: the unique name of the job\n        - \\c jobid: the unique job ID\n        - \\c description: job description\n        - \\c version: version number of the job\n        - \\c sessionid: session where the job is running\n        - \\c active: \\c True if active, \\c False if not\n        - \\c run_skipped: \\c True if the job should be executed immediately if a trigger time was missed due to down\n          time, \\c False if not\n        - [\\c recurring]: if this field is present, this gives the number of seconds between job executions, and the\n          cron fields will not be present\n        - [\\c minute]: cron field: minutes when the job can be executed\n        - [\\c hour]: cron field: hours when the job can be executed\n        - [\\c day]: cron field: days when the job can be executed\n        - [\\c month]: cron field: months when the job can be executed\n        - [\\c wday]: cron field: week days (0 = Sunday) when the job can be executed\n        - [\\c last_executed]: the date/time the job was last executed (if not present, the job has not yet been\n          executed)\n        - [\\c last_executed_job_instanceid]: the last executed instance id of the job\n        - [\\c expiry_date]: the date/time the job will expire; if this date is present, the job will not run\n          automatically after this date\n        - \\c created: the date/time the job was loaded into the database\n        - \\c modified: the date/time the job was modified in the database\n        - \\c groups: a list of RBAC group names that this job is a member of\n\n        @note if this method is called externally, and the user has a limited list of accessible jobs, then only\n        information about the jobs the user can access is returned\n    */\n    list getJobList() {\n        # get jobid filter if necessary\n        *list l = getJobAccessList();\n\n        hash sh = {\n            \"columns\" : (\"name\", \"jobid\", \"description\", \"version\",\n                        \"sessionid\", \"active\", \"run_skipped\",\n                        \"recurring\", \"minute\", \"hour\",\n                        \"day\", \"month\", \"wday\", \"last_executed\", \"last_executed_job_instanceid\",\n                        \"created\", \"modified\",),\n        };\n\n        if (exists l && l.size()) {\n            sh.where = {\"jobid\": op_in(l),};\n        }\n\n        # get metadata for all jobs\n        hash q;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                AbstractTable t = getSqlTableSystem(\"omq\", \"jobs\");\n                q = t.select(sh);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        return map processJobMetadataRow($1), q.contextIterator();\n    }\n\n    #! returns NOTHING if the job instance ID is not valid or a hash giving job instance status corresponding to the job instance ID passed as an argument\n    /** @param jiid the job instance ID to query\n        @return NOTHING if the job instance ID is not valid or a hash giving job instance status corresponding to the job instance ID passed as an argument with the following keys:\n        - \\c job_instanceid: the job instance ID being queried\n        - \\c jobid: the jobid (metadata ID)\n        - \\c sessionid: the application session currently running the job, otherwise 0\n        - \\c jobstatus: the current status of the job (see @ref JobStatusDescriptions for possible values)\n        - [\\c info]: the information saved against the job (if any)\n        - \\c started: the time the job instance was started\n        - \\c completed: the time the job instance completed (with any status)\n        - \\c modified: the time the job instance was last modified\n        - \\c errors: if any errors were raised against the job instance, they will appear as hashes in a list assigned to this key; the hashes will have the following keys:\n        - \\c job_errorid: the unique ID of the error in the \\c job_errors table\n        - \\c severity: the severity of the error (see @ref ErrorSeverityCodes for possible values)\n        - \\c error: the error code\n        - \\c description: description of the error\n        - [\\c info]: any additional data saved against the error\n        - \\c business_error: True if the error is a business error, False if not\n        - \\c created: the date/time the error was created\n        - \\c audit: if any audit events were created for the given job instance, they will appear as hashes in a list assigned to this key; the hashes will have the following keys:\n        - \\c audit_eventid: the audit event ID (unique key in the \\c AUDIT_EVENTS table)\n        - [\\c related_audit_eventid]: related audit event ID\n        - \\c audit_event_code: the audit event code (see @ref AuditEventCodes for possible values)\n        - [\\c audit_user_event]: the user audit event code string (present only when \\c audit_event_code is @ref OMQ::AE_USER_EVENT)\n        - [\\c reason]: the reason for the event\n        - \\c who: the initiator of the event\n        - \\c source: a string describing the source of the event\n        - [\\c info1]: an informational string about the event\n        - [\\c info2]: an informational string about the event\n        - \\c created: the date/time the audit event was created\n        - \\c event: the string description corresponding to the \\c audit_event_code (see @ref AuditEventStrings for possible values)\n\n        @throw JOB-ACCESS-ERROR @ref RBAC is enabled and the user does not have access to the given job instance ID\n    */\n    *hash getJobStatus(softint jiid) {\n        checkJobInstanceAccess(jiid);\n        *hash ji = omqp.selectRow(\"select name, version, ji.jobid, job_instanceid, ji.sessionid, jobstatus, info, started, completed, ji.modified from job_instance ji, jobs j where ji.jobid = j.jobid and job_instanceid = %v\", jiid);\n        if (!exists ji)\n            return;\n\n        ji = postProcessJobInstance(ji);\n\n        # add job instance errors\n        ji.errors = ();\n\n        *hash q;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                q = omqp.select(\"select job_errorid, severity, error, description, info, business_error, created from job_errors where job_instanceid = %v\", jiid);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n        trans.reset();\n\n        context (q) {\n            hash h = %%;\n            # delete NULL values\n            map delete h.$1, keys h, h.$1 === NULL;\n\n            # deserialize info, if any\n            if (exists h.info)\n                h.info = deserializeQorusData(h.info);\n\n            h.business_error = boolean(h.business_error);\n\n            ji.errors += h;\n        }\n\n        # add job instance audit events\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                q = omqp.select(\"select audit_eventid, related_audit_eventid, audit_event_code, audit_user_event, \"\n                    \"reason, who, source, info1, info2, created from audit_events where job_instanceid = %v \"\n                    \"order by created\", jiid);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        ji.audit = processAuditEvents(q);\n\n        return ji;\n    }\n\n    #! gets a list of job instance ids (not more than 100 by default, can be overridden with the 4th argument), params: jobid (single value or list), date, [statuses, num rows]\n    /** @param jobid a single jobid or a list of jobids to query\n        @param date an optional cutoff date, if the date parameter is not passed, then the cutoff date is set to 24 hours in the past; the cutoff date is used with the \\c job_instance.modified column; only rows with a \\c modified date greater than or equal to the date passed will be returned\n        @param stati a single job status or a list of job statuses to check; see @ref JobStatusDescriptions for possible values\n        @param rownum the maximum number of rows to return\n        @return a list of integer job instance IDs\n        @note if more than one jobid is given, there is no way to differentiate the jobid from the list returned because only a flat list of job_instanceid values is returned\n        @throw PARAMETER-ERROR missing jobid parameter, invalid date passed, or invalid job status passed\n        @throw JOB-ACCESS-ERROR @ref RBAC is enabled and the calling user does not have the right to access one or more of the given jobids\n    */\n    *list getJobInstanceList(auto jobid, *softdate date = now() - 1D, auto stati, softint rownum = OptionHelper::getOption(\"row-limit\")) {\n        # check parameters\n        if (!jobid && type(jobid) != Type::List)\n            throw \"PARAMETER-ERROR\", \"missing jobid parameter\";\n\n        if (!exists date)\n            date = now() - 1D;\n\n        if (!rownum)\n            rownum = OptionHelper::getOption(\"row-limit\");\n\n        if (date < 1000-01-01)\n            throw \"PARAMETER-ERROR\", sprintf(\"the second parameter must be a valid date (given: %y)\", date);\n\n        foreach auto status in (stati) {\n            if (!OMQ::JSMap{status})\n                throw \"PARAMETER-ERROR\", sprintf(\"%y is not a valid job status (valid statuses: %y)\", status, OMQ::JSMap.keys());\n        }\n\n        checkJobAccess(jobid);\n\n        # map job statuses to SQL statuses\n        stati = map OMQ::StatMap.$1, stati;\n\n        hash sh = {\n            \"columns\": \"job_instanceid\",\n            \"where\": {\n                \"jobid\": op_in(jobid),\n                \"modified\": op_ge(date),\n            },\n            \"limit\": rownum,\n        };\n\n        if (exists stati) {\n            sh.where.jobstatus = op_in(stati);\n        }\n\n        hash q;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                AbstractTable t = getSqlTableSystem(\"omq\", \"job_instance\");\n                q = t.select(sh);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        return map int($1), q.job_instanceid;\n    }\n\n    #! gets a list of job instance ids, params: jobid, condition, number of rows (100 default)\n    /** @param jobids one or more jobids to query\n        @param statuses a list with requested statuses in expanded form ('ERROR') or @ref nothing\n        @param modified a limit (>=) for the \\c modified column or @ref nothing\n        @param rownum the maximum number of rows to return\n        @param offset the row offset (for paging results)\n        @param sort a list of column names for sorting\n        @param jiids an optional list of job_instanceids for the search\n        @param desc if @ref True \"True\", then a descending sort is used\n        @param full if @ref True \"True\", then errors and audit events are also returned\n\n        @return NOTHING if no rows match the criteria, or a list of hashes with the following keys:\n        - \\c job_instanceid: the job instance ID being queried\n        - \\c jobid: the jobid (metadata ID)\n        - \\c jobstatus: the current status of the job (see @ref JobStatusDescriptions for possible values)\n        - \\c sessionid: the application session currently running the job, otherwise 0\n        - \\c started: the time the job instance was started\n        - \\c completed: the time the job instance completed (with any status)\n        - \\c modified: the time the job instance was last modified\n        - \\c errors: a list of error hashes (included only if \\c full = @ref True \"True\")\n        - \\c audit: a list of audit event hashes (included only if \\c full = @ref True \"True\")\n\n        @throw JOB-ACCESS-ERROR @ref RBAC is enabled and the calling user does not have the right to access one or more of the given jobids\n    */\n    *list getJobInstances(*softlist jobids, *softlist statuses, *softdate modified, softint rownum = OptionHelper::getOption(\"row-limit\"), *softint offset, *softlist sort, *softlist jiids, *softbool desc, *softbool full) {\n        logDebug(\"getJobInstances: jobids: %y statuses: %y mod: %y rownum: %y sort: %y offset: %y jiids: %y desc: %y full: %y\", jobids, statuses, modified, rownum, sort, offset, jiids, desc, full);\n\n        AbstractTable jobs = Qorus.dsmanager.getOmqTable(\"jobs\");\n        AbstractTable job_instance = Qorus.dsmanager.getOmqTable(\"job_instance\");\n\n        if (sort) {\n            # process sort keys\n            bool hk;\n            foreach string k in (\\sort) {\n                k = k.lwr();\n                if (!jobs.describe().hasKey(k) && !job_instance.describe().hasKey(k))\n                    throw \"JOB-SORT-ERROR\", sprintf(\"sort key %y is not valid; valid keys: %y\", k, (hash(jobs.describe()) + hash(job_instance.describe())).keys());\n                if (k == \"job_instanceid\")\n                    hk = True;\n            }\n\n            # the sort key must also have a unique column to ensure consistent sort order\n            if (!hk)\n                sort += \"job_instanceid\";\n        }\n\n        if (desc && !sort)\n            sort = \"job_instanceid\";\n\n        hash wcond;\n\n        if (jiids)\n            wcond.job_instanceid = op_in(jiids);\n\n        if (statuses)\n            wcond.jobstatus = op_in(map OMQ::JSMap.$1, statuses);\n\n        if (exists modified)\n            wcond.modified = op_ge(modified);\n\n        *hash jah = getWorkflowAccessHash();\n        list jl = ();\n        if (exists jah) {\n            if (!jah)\n                throw \"JOB-ACCESS-ERROR\", \"user cannot access any jobs\";\n\n            if (jobids) {\n                foreach auto e in (jobids) {\n                    softint id;\n                    if (e =~ /[a-z]/i)\n                        id = Qorus.qmm.getJobId(e);\n                    else\n                        id = e;\n                    if (jah{id})\n                        jl += id;\n                }\n            }\n            else\n                jl = jah.keys();\n        } else if (jobids)\n            jl = jobids;\n\n        if (jl) {\n            list jnl = ();\n            list jil = ();\n            foreach auto e in (jl) {\n                if (e =~ /[a-z]/i)\n                    jnl += e;\n                else\n                    jil += e;\n            }\n            if (jil)\n                wcond.jobid = op_in(jil);\n            if (jnl)\n                wcond.\"j.name\" = op_in(jnl);\n        }\n\n        hash sh = (\n            \"comment\": \"qorus.info.getJobInstances\",\n            \"columns\": (\"j.name\", \"j.version\", \"job_instanceid\", \"jobid\", \"jobstatus\", \"info\", \"sessionid\", \"started\", \"completed\", \"modified\"),\n            \"where\": wcond,\n            \"join\": join_inner(jobs, \"j\"),\n            \"limit\": rownum,\n            \"offset\": offset,\n            \"orderby\": sort,\n            \"desc\": desc,\n        );\n\n        #logDebug(\"SH: %N\", sh);\n\n        *list sqlresult;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                sqlresult = job_instance.selectRows(sh, SqlDataOpt);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n        trans.reset();\n        #string sql;\n        #*list sqlresult = ji.selectRows(sh, \\sql);\n        #logDebug(\"sql: %s\", sql);\n\n        # post-process results\n        foreach hash row in (\\sqlresult)\n            row = postProcessJobInstance(row);\n\n        if (sqlresult && full) {\n            AbstractTable job_errors = Qorus.dsmanager.getOmqTable(\"job_errors\");\n            AbstractTable audit_events = Qorus.dsmanager.getOmqTable(\"audit_events\");\n\n            # get job instance ID list\n            if (!jiids)\n                jiids = map $1.job_instanceid, sqlresult;\n\n            *list el;\n            while (True) {\n                try {\n                    # we can just release the lock because the query is read-only\n                    on_error omqp.rollback();\n\n                    el = job_errors.selectRows((\n                        \"comment\": \"qorus.info.getJobInstances\",\n                        \"columns\": (\"job_instanceid\", \"job_errorid\", \"severity\", \"error\", \"description\", \"info\",\n                            \"business_error\", \"created\"),\n                        \"where\": (\"job_instanceid\": op_in(jiids)),\n                    ), SqlDataOpt);\n                } catch (hash<ExceptionInfo> ex) {\n                    # restart the transaction if necessary\n                    if (trans.restartTransaction(ex))\n                        continue;\n                    rethrow;\n                }\n                break;\n            }\n            trans.reset();\n\n            # make into a hash\n            hash eh;\n            map eh.($1.job_instanceid) += list($1), el;\n\n            logInfo(\"eh: %y\\n\", eh);\n\n            *list al;\n            while (True) {\n                try {\n                    # we can just release the lock because the query is read-only\n                    on_error omqp.rollback();\n\n                    al = audit_events.selectRows({\n                        \"comment\": \"qorus.info.getJobInstances\",\n                        \"columns\": (\"job_instanceid\", \"audit_eventid\", \"related_audit_eventid\", \"audit_event_code\",\n                            \"audit_user_event\", \"reason\", \"who\", \"source\", \"info1\", \"info2\", \"created\"),\n                        \"where\": (\"job_instanceid\": op_in(jiids)),\n                }, SqlDataOpt);\n                } catch (hash<ExceptionInfo> ex) {\n                    # restart the transaction if necessary\n                    if (trans.restartTransaction(ex))\n                        continue;\n                    rethrow;\n                }\n                break;\n            }\n\n            # make into a hash\n            hash ah;\n            map ah.($1.job_instanceid) += list($1), al;\n\n            foreach hash row in (\\sqlresult) {\n                row.errors = (map ($1 + (\n                    \"business_error\": boolean($1.business_error),\n                    \"info\": deserializeQorusData($1.info),\n                )) - \"job_instanceid\", eh.(row.job_instanceid));\n                row.audit = (map $1 - \"job_instanceid\", ah.(row.job_instanceid));\n            }\n        }\n\n        return sqlresult;\n    }\n\n    #! gets a list of order instance notes\n    /** @param wfiid the wfiid to query\n        @param count an optional \"limit count\n    */\n    softlist getOrderInstanceNotes(softint wfiid, *int count) {\n        try {\n            return SM.getOrderInstanceNotes(wfiid, count);\n        } catch (hash<ExceptionInfo> ex) {\n            if (ex.err != \"INVALID-WORKFLOW-ORDER-DATA-INSTANCE\")\n                rethrow;\n        }\n\n        *string dsarch = Qorus.props.get(\"arch\").datasource;\n        if (dsarch) {\n            SqlUtil::AbstractTable t = getSqlTableSystemTrans(dsarch, \"order_instance_notes\");\n            QorusRestartableTransaction trans();\n            while (True) {\n                try {\n                    # we can just release the lock because the query is read-only\n                    on_error omqp.rollback();\n\n                    return t.selectRows((\"where\": (\"workflow_instanceid\": wfiid ), \"orderby\": \"created\"));\n                } catch (hash<ExceptionInfo> ex) {\n                    # restart the transaction if necessary\n                    if (trans.restartTransaction(ex))\n                        continue;\n                    rethrow;\n                }\n                break;\n            }\n        }\n\n        return ();\n    }\n\n    private softlist<hash<SlaEventInfo>> searchSlaEventsPriv(string dsname, *hash h) {\n        AbstractTable sla = getSqlTableSystemTrans(dsname, \"sla\");\n        AbstractTable sla_events = getSqlTableSystemTrans(dsname, \"sla_events\");\n\n        if (!h.limit)\n            h.limit = OptionHelper::getOption(\"row-limit\");\n\n        if (h.desc)\n            h.desc = parse_boolean(h.desc);\n\n        if (h.sort) {\n            if (h.sort && h.sort =~ /,/)\n                h.sort = h.sort.split(\",\");\n\n            # process sort keys\n            bool has_pk;\n            foreach string k in (\\h.sort) {\n                k = k.lwr();\n                if (!sla.describe().hasKey(k) && !sla_events.describe().hasKey(k))\n                    throw \"ORDER-SORT-ERROR\", sprintf(\"sort key %y is not valid; valid keys: %y\", k,\n                        (sla.describe().getHash() + sla_events.describe().getHash()).keys());\n                if (k == \"sla_eventid\")\n                    has_pk = True;\n            }\n\n            # the sort key must also have a unique column to ensure consistent sort order\n            if (!has_pk) {\n                if (h.sort.typeCode() != NT_LIST)\n                    h.sort = list(h.sort);\n                h.sort += \"sla_eventid\";\n            }\n        } else if (h.desc)\n            h.sort = \"sla_eventid\";\n\n        hash wcond;\n\n        do_cond_string_like_list(\\wcond, \"s.name\", h.name);\n        do_cond_int_list(\\wcond, \"s.slaid\", h.slaid);\n        do_cond_string_like_list(\\wcond, \"producer\", h.producer);\n        do_cond_string_like_list(\\wcond, \"err\", h.err);\n        do_cond_string_like_list(\\wcond, \"errdesc\", h.errdesc);\n\n        if (h.mindate.val())\n            wcond.created = op_ge(date(h.mindate));\n\n        if (h.maxdate.val())\n            wcond.\"1:created\" = op_lt(date(h.maxdate));\n\n        if (h.success.val())\n            wcond.success = h.success ? 1 : 0;\n\n        hash sh = (\n            \"comment\": \"qorus.info.searchSlaEvents\",\n            \"columns\": (\"s.name\", \"s.slaid\", \"sla_eventid\", \"value\", \"producer\", \"success\", \"err\", \"errdesc\",\n                 \"created\"),\n            \"join\": join_inner(sla, \"s\"),\n            \"where\": wcond,\n            \"limit\": h.limit,\n            \"offset\": h.offset,\n            \"orderby\": h.sort,\n            \"desc\": h.desc,\n        );\n\n        *list rv;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                rv = sla_events.selectRows(sh, SqlDataOpt);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        return map cast<hash<SlaEventInfo>>($1), rv;\n    }\n\n    #! searches for SLA events according to the given criteria and returns a list of results\n    /** @param h a hash of search criteria with the following optional keys:\n        - \\c desc: return the results in descending order\n        - \\c err: the error string of unsucessful SLA events; can be a list of strings or a string with \\c \"%\" characters for SQL like matching\n        - \\c errdesc: the error description string of unsucessful SLA events; can be a list of strings or a string with \\c \"%\" characters for SQL like matching\n        - \\c name: the name of the SLA; can be a list of names or a string with \\c \"%\" characters for SQL like matching\n        - \\c limit: max number of rows to return, if not given, then the value of the \\a \"row-limit\" option is used (default: 100)\n        - \\c mindate: minimum SLA event timestamp (inclusive, meaning \\c \">=\" comparisons used)\n        - \\c maxdate: maximum SLA event timestamp (exclusive, meaning \\c \"<\" comparisons used)\n        - \\c offset: row offset\n        - \\c producer: the producer string of SLA events; can be a list of strings or a string with \\c \"%\" characters for SQL like matching\n        - \\c slaid: the SLA ID, can be a list of IDs\n        - \\c sort: columns for sorting the results\n        - \\c success: filter for sucessful calls (1) or errored calls (0)\n\n        @return an empty list if no events are matched, otherwise a list of @ref OMQ::SlaEventInfo hashes\n\n        @since Qorus 3.1.1\n    */\n    list<hash<SlaEventInfo>> searchSlaEvents(*hash h) {\n        logDebug(\"searchSlaEvents(): h: %y\", h);\n        softint expected = h.limit ?? OptionHelper::getOption(\"row-limit\");\n\n        list<hash<SlaEventInfo>> ret = searchSlaEventsPriv(\"omq\", h);\n        int lsize = ret.lsize();\n        if (lsize < expected && (*string dsarch = Qorus.props.get(\"arch\").datasource))\n            ret += map $1 + (\"archive\": True), searchSlaEventsPriv(dsarch, h + (\"limit\": expected - lsize));\n        return ret;\n    }\n\n    #! searches for SLA events according to the given criteria and returns a list of results\n    /** @param h a hash of search criteria with the following optional keys:\n        - \\c err: the error string of unsucessful SLA events; can be a list of strings or a string with \\c \"%\" characters for SQL like matching\n        - \\c errdesc: the error description string of unsucessful SLA events; can be a list of strings or a string with \\c \"%\" characters for SQL like matching\n        - \\c grouping: (optional) possible values for reporting performance statistics:\n        - \\c \"hourly\": hourly grouping\n        - \\c \"daily\": daily grouping\n        - \\c \"monthly\": monthly grouping\n        - \\c \"yearly\": yearly grouping\n        - \\c name: the name of the SLA; can be a list of names or a string with \\c \"%\" characters for SQL like matching\n        - \\c maxdate: maximum SLA event timestamp (exclusive, meaning \\c \"<\" comparisons used)\n        - \\c mindate: minimum SLA event timestamp (inclusive, meaning \\c \">=\" comparisons used)\n        - \\c producer: the producer string of SLA events; can be a list of strings or a string with \\c \"%\" characters for SQL like matching\n        - \\c slaid: the SLA ID, can be a list of IDs\n        - \\c success: filter for sucessful calls (1) or errored calls (0)\n\n        @return an empty list if no events are matched, otherwise a list of @ref OMQ::SlaPerformanceInfo hashes\n\n        @since Qorus 3.1.1\n    */\n    softlist<hash<SlaPerformanceInfo>> getSlaPerformance(*hash h) {\n        logDebug(\"getSlaPerformance(): h: %y\", h);\n\n        # time grouping SqlUtil column operator closure/call ref\n        *code tg;\n        if (h.grouping) {\n            tg = Grouping.(h.grouping);\n            if (!tg)\n                throw \"ARGUMENT-ERROR\", sprintf(\"invalid grouping argument %y; expecting one of: %y\", h.grouping, Grouping.keys());\n        }\n\n        AbstractTable sla = Qorus.dsmanager.getOmqTable(\"sla\");\n        AbstractTable sla_events = Qorus.dsmanager.getOmqTable(\"sla_events\");\n\n        hash wcond;\n\n        do_cond_string_like_list(\\wcond, \"s.name\", h.name);\n        do_cond_int_list(\\wcond, \"s.slaid\", h.slaid);\n        do_cond_string_like_list(\\wcond, \"producer\", h.producer);\n\n        if (h.mindate.val())\n            wcond.created = op_ge(date(h.mindate));\n\n        if (h.maxdate.val())\n            wcond.\"1:created\" = op_lt(date(h.maxdate));\n\n        if (h.success.val())\n            wcond.success = h.success ? 1 : 0;\n\n        # column list\n        list cols = ();\n        # group by list\n        list groupby = ();\n        # order by list\n        list orderby = ();\n\n        if (tg) {\n            cols += cop_as(tg(\"created\"), \"grouping\");\n            groupby += tg(\"created\");\n            orderby += tg(\"created\");\n        }\n\n        cols += (\n            cop_as(cop_count(), \"count\"),\n            cop_as(cop_min(\"created\"), \"mindate\"),\n            cop_as(cop_max(\"created\"), \"maxdate\"),\n            cop_as(cop_min(\"value\"), \"minprocessing\"),\n            cop_as(cop_avg(\"value\"), \"avgprocessing\"),\n            cop_as(cop_max(\"value\"), \"maxprocessing\"),\n            cop_as(cop_avg(\"success\"), \"successratio\"),\n        );\n\n        hash sh = (\n            \"comment\": \"qorus.info.getSlaPerformance\",\n            \"columns\": cols,\n            \"join\": join_inner(sla, \"s\"),\n            \"where\": wcond,\n            \"groupby\": groupby,\n            \"orderby\": orderby,\n        );\n\n        *list rv;\n        QorusRestartableTransaction trans();\n        while (True) {\n            try {\n                # we can just release the lock because the query is read-only\n                on_error omqp.rollback();\n\n                rv = sla_events.selectRows(sh, SqlDataOpt);\n            } catch (hash<ExceptionInfo> ex) {\n                # restart the transaction if necessary\n                if (trans.restartTransaction(ex))\n                    continue;\n                rethrow;\n            }\n            break;\n        }\n\n        return map cast<hash<SlaPerformanceInfo>>($1), rv;\n    }\n\n    static private *list processIntervals(*list l, bool return_seconds) {\n        if (return_seconds) {\n            switch (qdriver) {\n                case \"oracle\": {\n                    foreach hash row in (\\l)\n                        map row.$1 = row.$1 * 86400n, ProcIntervalCols, exists row.$1;\n                    break;\n                }\n                case \"pgsql\": {\n                    foreach hash row in (\\l)\n                        map row.$1 = row.$1 ? (row.$1.durationMicroseconds() / 1000000n) : 0, ProcIntervalCols, exists row.$1;\n                    break;\n                }\n            }\n        } else {\n            switch (qdriver) {\n                case \"oracle\": {\n                    foreach hash row in (\\l)\n                        map row.$1 = seconds(row.$1 * 86400n), ProcIntervalCols, exists row.$1;\n                    break;\n                }\n                case \"mysql\": {\n                    foreach hash row in (\\l)\n                        map row.$1 = seconds(row.$1), ProcIntervalCols, exists row.$1;\n                    break;\n                }\n            }\n        }\n\n        return l;\n    }\n\n    private hash processCondition(reference condition) {\n        # check for illegal values (first attempt at detecting sql-injections)\n        if (condition =~ /(\\bwhere\\b|\\bselect\\b|\\bupdate\\b|\\binsert\\b|\\bcreate\\b|\\bdrop\\b|\\bbegin\\b|\\bfrom\\b|\\binto\\b)/i)\n            throw \"CONDITION-ERROR\", sprintf(\"condition %y is invalid\", condition);\n\n        # check for function calls; copy string for destructive tests\n        *string c = condition;\n        c = tolower(c);\n        while (True) {\n            *string c1 = (c =~ x/(\\w+)\\s*\\(.*\\)/)[0];\n            if (!exists c1)\n                break;\n            if (!inlist(c1, SQLWhiteList))\n                throw \"CONDITION-ERROR\", sprintf(\"condition %y is invalid\", condition);\n            # remove call from string to test again\n            int i = index(c, c1);\n            # get closing parenthesis\n            int t = index(c, \")\", i + strlen(c1));\n            #printf(\"i=%d cond: %y\\nc=%y\\nc1=%y\\n\", i, condition, c, c1);\n            splice c, i, t - i + 1;\n            #printf(\"c=%y\\n\", c);\n        }\n\n        # substitute SQL status values\n        condition =~ s/'READY'/'Y'/g;\n        condition =~ s/'SCHEDULED'/'S'/g;\n        condition =~ s/'COMPLETE'/'C'/g;\n        condition =~ s/'INCOMPLETE'/'N'/g;\n        condition =~ s/'ERROR'/'E'/g;\n        condition =~ s/'CANCELED'/'X'/g;\n        condition =~ s/'RETRY'/'R'/g;\n        condition =~ s/'WAITING'/'W'/g;\n        condition =~ s/'ASYNC-WAITING'/'A'/g;\n        condition =~ s/'EVENT-WAITING'/'V'/g;\n        condition =~ s/'IN-PROGRESS'/'I'/g;\n        condition =~ s/'BLOCKED'/'B'/g;\n        condition =~ s/'CRASH'/'Z'/g;\n\n        condition =~ s/\\$\\{WORKFLOW_ID\\}/wi.workflowid/g;\n        condition =~ s/\\$\\{WORKFLOW_INSTANCEID\\}/wi.workflow_instanceid/g;\n        condition =~ s/\\$\\{JOB_ID\\}/wi.jobid/g;\n        condition =~ s/\\$\\{JOB_INSTANCEID\\}/wi.job_instanceid/g;\n        condition =~ s/\\$\\{STARTED\\}/wi.started/g;\n        condition =~ s/\\$\\{MODIFIED\\}/wi.modified/g;\n        condition =~ s/\\$\\{COMPLETED\\}/wi.completed/g;\n        condition =~ s/\\$\\{PARENT_WORKFLOW_INSTANCEID\\}/wi.parent_workflow_instanceid/g;\n        condition =~ s/\\$\\{WORKFLOW_STATUS\\}/wi.workflowstatus/g;\n        condition =~ s/\\$\\{JOB_STATUS\\}/wi.jobstatus/g;\n        bool join_oik = condition =~ /\\$\\{KEYVALUE\\}/;\n        condition = replace(condition, \"${KEYVALUE}\", \"oik.VALUE\");\n        bool join_oi = (condition =~ /\\$\\{STATICDATA\\}/) || (condition =~ /\\$\\{DYNAMICDATA\\}/);\n        condition =~ s/\\$\\{STATICDATA\\}/oi.staticdata/g;\n        condition =~ s/\\$\\{DYNAMICDATA\\}/oi.dynamicdata/g;\n\n        # process and substitute dates\n        *string date;\n        while (exists (date = (condition =~ x/\\$\\{DATE\\}\\(([^\\)]+)\\)/)[0])) {\n            date = compatDeprecatedDbDate(qdriver, Qore::date(date));\n            condition = regex_subst(condition, \"\\\\${DATE}\\\\([^)]+\\\\)\", date);\n        }\n\n        return (\"join_oik\" : join_oik, \"join_oi\" : join_oi);\n    }\n}\n",
          "base-class-name": "QorusSystemService",
          "class-name": "QorusSystemInfoService",
          "servicetype": "SYSTEM",
          "name": "info",
          "display_name": "Info",
          "short_desc": "Qorus status information service",
          "version": "6.1",
          "autostart": false,
          "remote": false,
          "methods": [
            {
              "name": "getWorkflowStatus"
            },
            {
              "name": "getWorkflowStatus2"
            },
            {
              "name": "getOrderInfo"
            },
            {
              "name": "getOrderInfoFromExternalID"
            },
            {
              "name": "getOrderInfoFromKey"
            },
            {
              "name": "getOrdersFromKey"
            },
            {
              "name": "getWorkflowListFromWorkflowKey"
            },
            {
              "name": "getAllInfoFromOrderKey"
            },
            {
              "name": "getWorkflowOverview"
            },
            {
              "name": "getWorkflowOverviewFromName"
            },
            {
              "name": "getWorkflowSummaryOverview"
            },
            {
              "name": "getWorkflowMetadata"
            },
            {
              "name": "getWorkflowMetadata2"
            },
            {
              "name": "getWorkflowMetadataFromName"
            },
            {
              "name": "getWorkflowMetadataFromName2"
            },
            {
              "name": "getFunctionInstance"
            },
            {
              "name": "getFunctionInstanceFromName"
            },
            {
              "name": "getServiceMethod2"
            },
            {
              "name": "getServiceMethod"
            },
            {
              "name": "getServiceMetadata"
            },
            {
              "name": "getServiceMetadataFromName"
            },
            {
              "name": "getLibraryMetadata"
            },
            {
              "name": "getWorkflowInstanceList"
            },
            {
              "name": "getWorkflowInstances"
            },
            {
              "name": "getWorkflowInstancesByKeyValue"
            },
            {
              "name": "searchWorkflowInstances"
            },
            {
              "name": "getWorkflowInstanceOverview"
            },
            {
              "name": "getStepInstanceList"
            },
            {
              "name": "getErrorInstanceList"
            },
            {
              "name": "getErrorInstanceListByWFIID"
            },
            {
              "name": "getClass"
            },
            {
              "name": "getClassFromName"
            },
            {
              "name": "getConstant"
            },
            {
              "name": "getConstantFromName"
            },
            {
              "name": "getStepMetadata"
            },
            {
              "name": "getTreeWithWorkflowInstance"
            },
            {
              "name": "getWFIAllInfo"
            },
            {
              "name": "getWFIInstanceInfo"
            },
            {
              "name": "getWFIOrderInfo"
            },
            {
              "name": "getWFIStepInstances"
            },
            {
              "name": "getWFIErrorInstances"
            },
            {
              "name": "getWorkflowInstanceListFromWorkflowNameAndKeyValue"
            },
            {
              "name": "getWorkflowInstanceListFromWorkflowNameVersionAndKeyValue"
            },
            {
              "name": "getWorkflowInstanceListFromKeyValue"
            },
            {
              "name": "getOrderInfoList"
            },
            {
              "name": "getWFIOrderKeysOnly"
            },
            {
              "name": "searchOrderKeys"
            },
            {
              "name": "getWorkflowProcessingSummary"
            },
            {
              "name": "getStepProcessingSummary"
            },
            {
              "name": "searchWorkflowErrors"
            },
            {
              "name": "searchReleases"
            },
            {
              "name": "searchSessions"
            },
            {
              "name": "getUnpostedEvents"
            },
            {
              "name": "getUnpostedEventsFromName"
            },
            {
              "name": "searchEvents"
            },
            {
              "name": "getJobOverview"
            },
            {
              "name": "getJobOverviewFromName"
            },
            {
              "name": "getJobMetadata"
            },
            {
              "name": "getJobMetadataFromName"
            },
            {
              "name": "getJobList"
            },
            {
              "name": "getJobStatus"
            },
            {
              "name": "getJobInstanceList"
            },
            {
              "name": "getJobInstances"
            },
            {
              "name": "getOrderInstanceNotes"
            },
            {
              "name": "searchSlaEvents"
            },
            {
              "name": "getSlaPerformance"
            }
          ],
          "author": ["Qore Technologies, s.r.o."]
        },
        "supports_enable": true,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got service 620"
    },
    {
      "request_id": "didkcW5WdnGFiya",
      "tab_token": "none",
      "data": {
        "iface_kind": "service",
        "service": {
          "id": 152,
          "type": "service",
          "desc": "Google Calendar API Event Helper / Watch Service",
          "lang": "qore",
          "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\n%requires GoogleRestClient\n\n# TODO:\n# make it thread-safe\n# respect the TTL value and refresh the watch\n\nclass GoogleCalendar inherits BBM_RestServiceBase {\n    private {\n        GoogleCalendarWebSocketApiDataEventSource ws;\n    }\n\n    init() {\n        BBM_RestServiceBase::init();\n\n        ws = new GoogleCalendarWebSocketApiDataEventSource();\n    }\n\n    private AbstractServiceHttpHandler getHandlerImpl() {\n        return new GoogleCalendarRestHandler();\n    }\n\n    hash<auto> info() {\n        return {\n            \"callback_url\": ws.getCallbackUrl(),\n        };\n    }\n}\n\nclass GoogleCalendarWebSocketConnection inherits BBM_WebSocketServiceDataEventSourceConnection {\n    constructor(hash<auto> cx, GoogleCalendarWebSocketHandler handler)\n            : BBM_WebSocketServiceDataEventSourceConnection(cx, handler) {\n    }\n\n    softstring getId() {\n        return cx.id;\n    }\n}\n\nclass GoogleCalendarWebSocketHandler inherits BBM_WebSocketServiceDataEventSourceHandler {\n    constructor(GoogleCalendarWebSocketApiDataEventSource service)\n            : BBM_WebSocketServiceDataEventSourceHandler(service) {\n    }\n\n    #! called when a connection is established\n    GoogleCalendarWebSocketConnection getConnectionImpl(hash<auto> cx, hash<auto> hdr, string cid) {\n        return new GoogleCalendarWebSocketConnection(cx, self);\n    }\n\n    #! called when the connection terminates\n    private deregisterConnectionImpl(GoogleCalendarWebSocketConnection wsc) {\n        # unsubscribe from all active channels\n        GoogleCalendarWebSocketApiDataEventSource::ws.unsubscribeConnection(wsc.getId());\n        BBM_WebSocketServiceDataEventSourceHandler::deregisterConnectionImpl(wsc);\n    }\n}\n\nclass GoogleCalendarWebSocketApiDataEventSource inherits BBM_WebSocketServiceDataEventSource {\n    public {\n        # connection map: connection ID -> type -> connection info\n        hash<string, hash<string, hash<ConnInfo>>> connmap;\n\n        # google connection ID -> {conn, type}\n        hash<string, hash<auto>> gconnmap;\n\n        static GoogleCalendarWebSocketApiDataEventSource ws;\n\n        const RetrySet = {\n            \"SOCKET-SSL-ERROR\": True,\n        };\n\n        const MaxIoRetries = 5;\n    }\n\n    private {\n        # public URL for Google callbacks\n        string callback_url = UserApi::getConfigItemValue(\"google-calendar-public-url\");\n    }\n\n    constructor() {\n        if (callback_url !~ /\\/$/) {\n            callback_url += \"/\";\n        }\n        string rest_root_uri = UserApi::getConfigItemValue(\"rest-root-uri\");\n        if (rest_root_uri =~ /^\\//) {\n            splice rest_root_uri, 0, 1;\n        }\n        if (rest_root_uri !~ /\\/$/) {\n            rest_root_uri += \"/\";\n        }\n        callback_url += rest_root_uri + \"callback\";\n\n        GoogleCalendarWebSocketApiDataEventSource::ws := self;\n\n        registerObserver(new WebSocketApiObserver(self));\n    }\n\n    #! Returns the HTTP handler for the service\n    private AbstractServiceHttpHandler getHandlerImpl() {\n        return new GoogleCalendarWebSocketHandler(self);\n    }\n\n    string getCallbackUrl() {\n        return callback_url;\n    }\n\n    hash<HttpHandlerResponseInfo> processNotification(hash<auto> cx, string id, string url) {\n        *hash<auto> h = gconnmap{id};\n        if (!h) {\n            return RestHandler::makeResponse(400, sprintf(\"%y: no such active channel\", id));\n        }\n        *hash<ConnInfo> conninfo = connmap{h.conn}{h.type};\n        if (!conninfo) {\n            return RestHandler::makeResponse(400, sprintf(\"%y: no connection for channel\", id));\n        }\n        # get new events\n        string curl = conninfo.rest.getURL();\n        curl =~ s/\\/$//;\n        if (url.equalPartialPath(curl)) {\n            splice url, 0, curl.length();\n        } else {\n            throw \"CALLBACK-ERROR\", sprintf(\"URL %y is not served by the Google API root URL %y\", url, curl);\n        }\n        if (conninfo.sync_token) {\n            url += sprintf(\"?syncToken=%s\", conninfo.sync_token);\n        } else {\n            url += sprintf(\"?updatedMin=%s\", conninfo.last_check.format(\"IF\"));\n        }\n        hash<auto> info;\n        hash<auto> res;\n        date now = now_us();\n        string current_url = url;\n        while (True) {\n            res = doRestCommand(conninfo.rest, \"GET\", current_url, NOTHING, \\info);\n            UserApi::logInfo(\"got events: %N\", res.body);\n\n            connmap{h.conn}{h.type}.last_check = now;\n            foreach hash<auto> item in (remove res.body.items) {\n                sendMessage(<WebSocketSendEventInfo>{\n                    \"cid\": h.conn.toInt(),\n                    \"msg\": {\n                        \"reqid\": -1,\n                        \"type\": \"event\",\n                        \"event\": convertData(res.body + {\"item\": item}),\n                    },\n                });\n            }\n            if (res.body.nextPageToken) {\n                current_url = sprintf(\"%s&pageToken=%s\", url, res.body.nextPageToken);\n                continue;\n            }\n            if (res.body.nextSyncToken) {\n                connmap{h.conn}{h.type}.sync_token = res.body.nextSyncToken;\n                UserApi::logInfo(\"connection %y type %y: updated sync token: %y\", h.conn, h.type,\n                    res.body.nextSyncToken);\n            }\n            break;\n        }\n\n        return RestHandler::makeResponse(200);\n    }\n\n    static hash<auto> doRestCommand(GoogleRestClient rest, string method, string path, auto body,\n            reference<hash<auto>> info) {\n        int retries = 0;\n        while (True) {\n            try {\n                return rest.doRequest(method, path, body, \\info);\n            } catch (hash<ExceptionInfo> ex) {\n                if (GoogleCalendarWebSocketApiDataEventSource::retry(ex, \\retries)) {\n                    continue;\n                }\n                UserApi::logError(\"%s\", get_exception_string(ex));\n                rethrow;\n            }\n        }\n    }\n\n    unsubscribeConnection(string conn) {\n        WebSocketApiObserver observer = cast<WebSocketApiObserver>(observer_map.lastValue().observer);\n        observer.unsubscribeConnection(conn);\n    }\n\n    private static bool retry(hash<ExceptionInfo> ex, reference<int> retries) {\n        if (RetrySet{ex.err}) {\n            if (++retries == MaxIoRetries) {\n                UserApi::logError(\"maximum retries exceeded (%d)\", retries);\n                return False;\n            }\n            UserApi::logWarn(\"technical error making REST call: %s: %s; retrying\", ex.err, ex.desc);\n            return True;\n        }\n        return False;\n    }\n\n    private auto convertData(auto v) {\n        return v;\n    }\n\n    private auto convertData(string v) {\n        return v =~ /^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}\\.[0-9]+/\n            ? date(v)\n            : v;\n    }\n\n    private list<auto> convertData(list<auto> l) {\n        return map GoogleCalendarWebSocketApiDataEventSource::convertData($1), l;\n    }\n\n    private hash<auto> convertData(hash<auto> h) {\n        return map {$1.key: GoogleCalendarWebSocketApiDataEventSource::convertData($1.value)}, h.pairIterator();\n    }\n}\n\nhashdecl ConnInfo {\n    GoogleRestClient rest;\n    hash<auto> channel_info;\n    string sync_token;\n    date last_check;\n}\n\nclass WebSocketApiObserver inherits DataProvider::Observer {\n    private {\n        GoogleCalendarWebSocketApiDataEventSource service;\n\n        hash<auto> cmdmap;\n\n        const ChannelStopUriPath = \"calendar/v3/channels/stop\";\n\n        #! Required args for the REST client\n        const WatchRestKeys = {\n            \"token\": True,\n        };\n\n        #! Optional args for the REST client\n        const WatchRestAllKeys = map {$1: True}, keys GoogleCalendarRestConnection::ConnectionScheme.options;\n\n        const WatchRequestKeys = {\n            \"type\": True,\n        };\n\n        const WatchTypeMap = {\n            \"events\": {\n                \"calendarid\": True,\n            },\n            \"calendarList\": {},\n        };\n\n        const WatchResponseKeys = (\n            \"id\",\n            \"resourceId\",\n            \"expiration\",\n        );\n\n        const WatchKeys = WatchRestKeys + WatchRequestKeys;\n\n        const StopKeys = {\n            \"type\": True,\n        };\n\n        const UnsubscribeKeys = WatchRestKeys + {\n            \"channel\": True,\n            \"resource\": True,\n        };\n    }\n\n    constructor(GoogleCalendarWebSocketApiDataEventSource service) {\n        self.service := service;\n\n        cmdmap = {\n            \"WATCH\": \\watch(),\n            \"STOP\": \\stop(),\n            \"UNSUBSCRIBE\": \\unsubscribe(),\n            \"INFO\": \\info(),\n        };\n    }\n\n    update(string event_id, hash<auto> data_) {\n        UserApi::logDebug(\"ws event id: %y data: %y\", event_id, data_);\n        softstring conn = data_.cx.id;\n        if (event_id == BBM_WebSocketServiceDataEventSourceConnection::ConnectionClosedId) {\n            handleClosed(conn, data_);\n            return;\n        }\n        if (event_id == BBM_WebSocketServiceDataEventSourceConnection::ConnectionEventId) {\n            handleEvent(conn, data_);\n        }\n    }\n\n    unsubscribeConnection(string conn) {\n        list<string> types;\n        foreach string type in (keys service.connmap{conn}) {\n            try {\n                stopIntern(conn, type);\n                types += type;\n            } catch (hash<ExceptionInfo> ex) {\n                # log full error message with backtrace in log\n                UserApi::logError(\"connection %y failed to unsubscribe from type %y: %s\", conn, type,\n                    get_exception_string(ex));\n            }\n        }\n        UserApi::logInfo(\"connection %y unsubscribed from channels: %y\", conn, types);\n    }\n\n    private handleClosed(string conn, hash<auto> data_) {\n        if (!service.connmap{conn}) {\n            UserApi::logInfo(\"connection %y closed; all channels unsubscribed\", conn);\n            return;\n        }\n        UserApi::logInfo(\"connection %y closed; unsubscribed from channels: %y\", conn, keys service.connmap{conn});\n\n        # remove the connection on exit\n        on_exit {\n            remove service.connmap{conn};\n            UserApi::logInfo(\"connection %y: all channels unsubscribed\", conn);\n        }\n\n        foreach string type in (keys service.connmap{conn}) {\n            try {\n                stopIntern(conn, type);\n            } catch (hash<ExceptionInfo> ex) {\n                UserApi::logError(\"connection %y: error stopping watch on channel %y: %s: %s\", conn, type,\n                    get_exception_string(ex));\n            }\n        }\n    }\n\n    private handleEvent(string conn, hash<auto> data_) {\n        if (data_.msg.typeCode() != NT_HASH) {\n            error(data_, \"missing or invalid API data; got type %y; expecting \\\"hash\\\" with a \\\"cmd\\\" key\",\n                data_.msg.fullType());\n            return;\n        }\n        if (data_.msg.cmd.typeCode() != NT_STRING) {\n            error(data_, \"missing or invalid cmd (got type %y; expecting \\\"string\\\")\", data_.msg.cmd.fullType());\n            return;\n        }\n        *code action = cmdmap{data_.msg.cmd};\n        if (!action) {\n            error(data_, \"invalid cmd %y; expecting one of: %y\", data_.msg.cmd, keys cmdmap);\n            return;\n        }\n        try {\n            action(conn, data_);\n        } catch (hash<ExceptionInfo> ex) {\n            error(data_, ex, \"error executing API %y\", data_.msg.cmd);\n        }\n    }\n\n    private watch(string conn, hash<auto> data_) {\n        hash<auto> args = checkArgs(data_.msg);\n        # check for command key args\n        checkKeys(args, keys WatchKeys);\n        string type = args.type;\n        *list<string> other_keys = keys WatchTypeMap{type};\n        if (!exists other_keys) {\n            throw \"WATCH-ERROR\", sprintf(\"invalid watch type %y; known types: %y\", type, keys WatchTypeMap);\n        }\n        checkKeys(args, other_keys);\n        if (service.connmap{conn}{type}) {\n            throw \"WATCH-ERROR\", sprintf(\"connection already has an active %y channel\", type);\n        }\n        string uri_path;\n        switch (type) {\n            case \"events\":\n                uri_path = sprintf(\"/calendar/v3/calendars/%s/events/watch\", args.calendarid);\n                break;\n            case \"calendarList\":\n                uri_path = \"/calendar/v3/users/me/calendarList/watch\";\n                break;\n        }\n        hash<auto> info;\n        hash<auto> res;\n        try {\n            GoogleRestClient rest = getGoogleClient(args, \"calendar\");\n            hash<ConnInfo> conninfo = <ConnInfo>{\n                \"rest\": rest,\n            };\n            if (type == \"calendarList\") {\n                # get sync_token\n                conninfo.sync_token = getSyncToken(rest, uri_path, \\info);\n            }\n\n            # start watching for events\n            hash<auto> body = {\n                \"id\": UUID::get(),\n                \"token\": conn,\n                \"type\": \"webhook\",\n                \"address\": service.getCallbackUrl(),\n                /*\n                \"params\": {\n                    \"ttl\": \"\",\n                },\n                */\n            };\n            res = GoogleCalendarWebSocketApiDataEventSource::doRestCommand(rest, \"POST\", uri_path, body, \\info);\n            UserApi::logInfo(\"got watch response: %y\", res.body);\n            *hash<auto> channel_info = res.body{WatchResponseKeys};\n            if (channel_info.size() != WatchResponseKeys.size()) {\n                throw \"WATCH-ERROR\", sprintf(\"response body %y missing required keys: %y\", res.body,\n                    WatchResponseKeys);\n            }\n            if (channel_info.id != body.id) {\n                throw \"WATCH-ERROR\", sprintf(\"ID in watch response %y != request ID %y\", channel_info.id, body.id);\n            }\n            # convert expiration to a date/time value\n            channel_info.expiration = gmtime(channel_info.expiration / 1000);\n            conninfo.channel_info = channel_info;\n            conninfo.last_check = now_us();\n            service.connmap{conn}{type} = conninfo;\n            service.gconnmap{channel_info.id} = {\n                \"conn\": conn,\n                \"type\": type,\n            };\n        } catch (hash<ExceptionInfo> ex) {\n            string err = \"error starting watch\";\n            if (info) {\n                err += sprintf(\": %y returned from %y\", info.\"response-uri\", info.\"request-uri\");\n                if (res) {\n                    err += sprintf(\", response body: %y\", res.body);\n                }\n            }\n            if (info) {\n                UserApi::logError(\"info: %N\", info);\n            }\n            error(data_, ex, \"%s\", err);\n            return;\n        }\n        string msg = sprintf(\"watching for events on channel %y (%y)\", type,\n            service.connmap{conn}{type}.channel_info);\n        UserApi::logInfo(\"connection %y: %s\", conn, msg);\n        sendMessage(\"info\", data_, {\n            \"info\": msg,\n        });\n    }\n\n    static GoogleRestClient getGoogleClient(hash<auto> args, string api_profile) {\n        GoogleRestClient rest(args{keys WatchRestAllKeys} + {\n            \"api_profile\": api_profile,\n        });\n        Logger logger(\"google-calendar-rest\", LoggerLevel::getLevelDebug());\n        logger.addAppender(new QorusAppender());\n        rest.setLogger(logger);\n        return rest;\n    }\n\n    private string getSyncToken(GoogleRestClient rest, string watch_path, reference<hash<auto>> info) {\n        string uri = watch_path;\n        uri =~ s/\\/watch$//;\n        uri += \"?maxResults=250\";\n        string current_uri = uri;\n        hash<auto> res;\n        while (True) {\n            res = GoogleCalendarWebSocketApiDataEventSource::doRestCommand(rest, \"GET\", current_uri, NOTHING, \\info);\n            UserApi::logInfo(\"syncToken response: %y\", res.body);\n            if (res.body.nextPageToken) {\n                current_uri = sprintf(\"%s&pageToken=%s\", uri, res.body.nextPageToken);\n                continue;\n            }\n            break;\n        }\n        return res.body.nextSyncToken;\n    }\n\n    private hash<auto> checkArgs(hash<auto> msg) {\n        if (msg.args.typeCode() != NT_HASH) {\n            throw \"WATCH-ERROR\", sprintf(\"missing or invalid \\\"args\\\" in message; got type %y but expecting \\\"hash\\\" \"\n                \"(value: %y)\", msg.args.fullType(), msg.args);\n        }\n        return msg.args;\n    }\n\n    private checkKeys(hash<auto> args, list<string> arg_keys) {\n        foreach string key in (arg_keys) {\n            if (args{key}.typeCode() != NT_STRING) {\n                throw \"WATCH-ERROR\", sprintf(\"missing required argument %y in the \\\"args\\\" hash (args: %y)\", key,\n                    args);\n            }\n        }\n    }\n\n    private stop(string conn, hash<auto> data_) {\n        hash<auto> args = checkArgs(data_.msg);\n        # check for command key args\n        checkKeys(args, keys StopKeys);\n        string type = args.type;\n        if (!service.connmap{conn}{type}) {\n            throw \"STOP-ERROR\", sprintf(\"no channel %y connected; connected channels: %y\", type,\n                keys service.connmap{conn});\n        }\n        try {\n            stopIntern(conn, type);\n        } catch (hash<ExceptionInfo> ex) {\n            error(data_, ex, \"error stopping watch on channel %y\", type);\n            return;\n        }\n\n        string msg = sprintf(\"stopped watching for events on channel %y\", conn, type);\n        UserApi::logInfo(\"connection %y: %s\", conn, msg);\n        sendMessage(\"info\", data_, {\n            \"info\": msg,\n        });\n    }\n\n    private stopIntern(string conn, string type) {\n        # issue stop request\n        hash<auto> body = {\n            \"id\": service.connmap{conn}{type}.channel_info.id,\n            \"resourceId\": service.connmap{conn}{type}.channel_info.resourceId,\n            \"token\": conn,\n        };\n        doStopIntern(conn, type, body);\n    }\n\n    private doStopIntern(string conn, string type, hash<auto> body) {\n        hash<auto> info;\n        hash<auto> res;\n        try {\n            # remove connection channel info even if the command fails\n            on_exit {\n                hash<ConnInfo> conninfo = remove service.connmap{conn}{type};\n                remove service.gconnmap{conninfo.channel_info.id};\n            }\n            res = GoogleCalendarWebSocketApiDataEventSource::doRestCommand(service.connmap{conn}{type}.rest, \"POST\",\n                ChannelStopUriPath, body, \\info);\n        } catch (hash<ExceptionInfo> ex) {\n            string desc = ex.desc;\n            if (info) {\n                desc += sprintf(\": %y returned from %y\", info.\"response-uri\", info.\"request-uri\");\n                if (res) {\n                    desc += sprintf(\", response body: %y\", res.body);\n                }\n            }\n            rethrow ex.err, desc;\n        }\n    }\n\n    private unsubscribe(string conn, hash<auto> data_) {\n        hash<auto> args = checkArgs(data_.msg);\n        # check for command key args\n        checkKeys(args, keys UnsubscribeKeys);\n        hash<auto> res;\n        hash<auto> info;\n        try {\n            GoogleRestClient rest = getGoogleClient(args, \"calendar\");\n\n            # issue unsubscribe request\n            hash<auto> body = {\n                \"id\": args.channel,\n                \"resourceId\": args.resource,\n                \"token\": conn,\n            };\n            res = GoogleCalendarWebSocketApiDataEventSource::doRestCommand(rest, \"POST\",\n                ChannelStopUriPath, body, \\info);\n        } catch (hash<ExceptionInfo> ex) {\n            error(data_, ex, \"error unsubscribeing channel %y resource: %y\", args.channel, args.resource);\n            return;\n        }\n\n        string msg = sprintf(\"unsubscribed from channel: %y resource: %y\", args.channel, args.resource);\n        UserApi::logInfo(\"connection %y: %s\", conn, msg);\n        sendMessage(\"info\", data_, {\n            \"info\": msg,\n        });\n    }\n\n    private info(string conn, hash<auto> data_) {\n        sendMessage(\"info\", data_, {\n            \"connected\": map {\n                $1.key: {\n                    \"channel\": $1.value.channel_info.id,\n                } + $1.value{\"sync_token\", \"last_check\"},\n            }, service.connmap{conn}.pairIterator(),\n        });\n    }\n\n    private error(hash<auto> data_, hash<ExceptionInfo> ex, string fmt, ...) {\n        string err = vsprintf(fmt, argv);\n        # log full error message with backtrace in log\n        UserApi::logError(\"connection \\\"%s\\\" from %y: %s: %s\", data_.cx.id, data_.cx.\"peer-info\".hostname_desc, err,\n            get_exception_string(ex));\n        # return summarized error info on the WebSocket channel\n        err += sprintf(\": %s: %s\", ex.err, ex.desc);\n        sendMessage(\"error\", data_, {\n            \"info\": err,\n        });\n    }\n\n    private error(hash<auto> data_, string fmt, ...) {\n        string err = vsprintf(fmt, argv);\n        UserApi::logError(\"connection \\\"%s\\\" from %y: %s\", data_.cx.id, data_.cx.\"peer-info\".hostname_desc, err);\n        sendMessage(\"error\", data_, {\n            \"info\": err,\n        });\n    }\n\n    private sendMessage(string type, hash<auto> data_, hash<auto> msg) {\n        string reqid = data_.msg.id ?? \"n/a\";\n        service.sendMessage(<WebSocketSendEventInfo>{\n            \"cid\": data_.cx.id,\n            \"msg\": {\n                \"reqid\": reqid,\n                \"type\": type,\n            } + msg,\n        });\n    }\n}\n\nclass GoogleCalendarCallbackRestClass inherits BBM_RestClass {\n    string name() {\n        return \"callback\";\n    }\n\n    hash<HttpHandlerResponseInfo> post(hash<auto> cx, *hash<auto> ah) {\n        #UserApi::logDebug(\"webhook cx: %y\", cx);\n        *string channel = cx.hdr.\"x-goog-channel-id\";\n        if (!channel) {\n            return RestHandler::makeResponse(400, \"malformed header; missing channel information\");\n        }\n        *string url = cx.hdr.\"x-goog-resource-uri\";\n        if (!url) {\n            return RestHandler::makeResponse(400, \"malformed header; missing resource information\");\n        }\n        *string state = cx.hdr.\"x-goog-resource-state\";\n        if (!state) {\n            return RestHandler::makeResponse(400, \"malformed header; missing state information\");\n        }\n        UserApi::logInfo(\"received Google notification: %y\",\n            (map {$1.key: $1.value}, cx.hdr.pairIterator(), $1.key =~ /^x-goog-/));\n        if (state == \"sync\") {\n            # currently ignore sync information\n            UserApi::logInfo(\"sync started for channel %y url: %y\", channel, url);\n            return RestHandler::makeResponse(200);\n        }\n        # remove any query from the URI\n        url =~ s/\\?.*$//;\n        # process event on channel\n        return GoogleCalendarWebSocketApiDataEventSource::ws.processNotification(cx, channel, url);\n    }\n}\n\nclass GoogleCalendarRestHandler inherits BBM_RestHandlerBase {\n    constructor() : BBM_RestHandlerBase() {\n        addClass(new GoogleCalendarCallbackRestClass());\n    }\n}\n\npublic class QorusAppender inherits LoggerAppender {\n    constructor() : LoggerAppender(\"qorus\") {\n        open();\n    }\n\n    processEventImpl(int type, auto params) {\n        switch (type) {\n            case EVENT_LOG:\n                UserApi::logWithLevelArgs(params.level, \"%s\", params.msg);\n                break;\n        }\n    }\n\n    private auto serializeImpl(LoggerEvent event) {\n        return {\n            \"level\": event.getLevel().getValue(),\n            \"msg\": event.getMessage(),\n        };\n    }\n}\n",
          "base-class-name": "BBM_RestServiceBase",
          "class-name": "GoogleCalendar",
          "servicetype": "USER",
          "name": "google-calendar",
          "display_name": "Google Calendar",
          "short_desc": "Google Calendar API Event Helper / Watch Service",
          "version": "1.0",
          "autostart": true,
          "remote": false,
          "methods": [
            {
              "name": "init",
              "author": "Qore Technologies, s.r.o."
            },
            {
              "name": "info",
              "author": "Qore Technologies, s.r.o."
            }
          ],
          "author": ["Qore Technologies, s.r.o."],
          "classes": [
            {
              "id": 1,
              "name": "BBM_HttpServiceGenericBase"
            },
            {
              "id": 2,
              "name": "BBM_HttpAuthenticatorBase"
            },
            {
              "id": 3,
              "name": "BBM_CorsBase"
            },
            {
              "id": 4,
              "name": "BBM_RestServiceBase"
            },
            {
              "id": 5,
              "name": "BBM_WebSocketServiceBase"
            },
            {
              "id": 6,
              "name": "BBM_WebSocketServiceDataEventSource"
            }
          ],
          "config-items": [
            {
              "name": "http-listener-bind-address",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-cert-location",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-cert-format",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-key-location",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-key-format",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-key-password",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-ssl-mode",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-accept-all-certs",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-capture-client-certs",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-root-uri",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              },
              "value": "apps/api/google-calendar"
            },
            {
              "name": "rest-auth-name",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              },
              "value": "permissive"
            },
            {
              "name": "rest-auth-cookie",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-auth-redirect",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-swagger-schema",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-remove-leading-path-components",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-cors-enable",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              },
              "value": true
            },
            {
              "name": "rest-cors-methods",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-cors-max-age",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-cors-headers",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-cors-credentials",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-allow-sharing",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "websockets-root-uri",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              },
              "value": "apps/ws/google-calendar"
            },
            {
              "name": "websockets-auth-name",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              },
              "value": "permissive"
            },
            {
              "name": "websockets-cors-enable",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "websockets-cors-methods",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "websockets-cors-max-age",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "websockets-cors-headers",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "websockets-cors-credentials",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "websockets-auth-cookie",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "websockets-auth-redirect",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "websockets-event-data",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              },
              "value": "yaml"
            },
            {
              "name": "google-calendar-public-url",
              "description": "The public URL for the service; this will be used for the callback address; it should have no URI path, as the URI path will be determined from the REST handler option.",
              "config_group": "Google Calendar Service Config",
              "type": "string",
              "default_value": "https://api.qoretechnologies.com",
              "strictly_local": true,
              "default_value_true_type": "string",
              "value": "https://api.qoretechnologies.com"
            }
          ]
        },
        "supports_enable": true,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got service 152"
    },
    {
      "request_id": "Fb2KnmE3VRQvZ3X",
      "tab_token": "none",
      "data": {
        "iface_kind": "service",
        "service": {
          "id": 120,
          "type": "service",
          "desc": "Test service written using YAML format",
          "lang": "qore",
          "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass issue3102service inherits QorusService {\n    init() {\n        logInfo(\"init() method called\");\n    }\n\n    string getString() {\n        return \"string\";\n    }\n\n    auto echo(auto arg) {\n        return arg;\n    }\n\n    auto echoInternal(auto arg) {\n        return arg;\n    }\n\n    private myPrivMethod() {\n    }\n\n    int getInt() {\n        return 1;\n    }\n\n    throwException() {\n        throw \"ERROR\", \"test error\";\n    }\n\n    int echo(int i) {\n        return i;\n    }\n}\n",
          "base-class-name": "QorusService",
          "class-name": "issue3102service",
          "servicetype": "USER",
          "name": "issue3102service",
          "display_name": "Issue3102service",
          "short_desc": "Test service written using YAML format",
          "version": "1.0",
          "autostart": true,
          "remote": true,
          "methods": [
            {
              "name": "init",
              "author": "Alzhan Turlybekov"
            },
            {
              "name": "getString",
              "author": "Alzhan Turlybekov"
            },
            {
              "name": "echo",
              "author": "Alzhan Turlybekov"
            },
            {
              "name": "echoInternal",
              "author": "Alzhan Turlybekov",
              "internal": true
            },
            {
              "name": "getInt",
              "author": "Alzhan Turlybekov"
            },
            {
              "name": "throwException",
              "author": "Qore Technologies",
              "lock": "read"
            }
          ],
          "groups": ["issue3102group"],
          "author": ["Alzhan Turlybekov"],
          "classes": [
            {
              "id": 1,
              "name": "issue3102class"
            }
          ],
          "vmaps": ["issue3102vmap"],
          "config-items": [
            {
              "name": "issue-3102-test-config-item-1",
              "parent": {
                "interface-type": "class",
                "interface-name": "issue3102class",
                "interface-version": "1.0"
              }
            },
            {
              "name": "issue-3102-test-config-item-2",
              "description": "test config item of type string",
              "config_group": "Test Group",
              "type": "string",
              "default_value": "test_2",
              "allowed_values": ["test_1", "test_2", "test_3"],
              "default_value_true_type": "string"
            },
            {
              "name": "issue-3102-test-config-item-3",
              "description": "test config item of type *float",
              "config_group": "Test Group",
              "type": "*float",
              "value": 2.1
            }
          ],
          "tags": [
            {
              "id": 1,
              "key": "mytag",
              "value": "value"
            },
            {
              "id": 2,
              "key": "mytag2",
              "value": "value2"
            }
          ]
        },
        "supports_enable": true,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got service 120"
    },
    {
      "request_id": "OgQOyS1bldcowkC",
      "tab_token": "none",
      "data": {
        "iface_kind": "service",
        "service": {
          "id": 248,
          "type": "service",
          "desc": "Code server UI extension",
          "lang": "qore",
          "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass CodeUiExtension inherits QorusService {\n    private {\n        ####### GENERATED SECTION! DON'T EDIT! ########\n        ClassConnections_CodeUiExtension class_connections();\n        ############ GENERATED SECTION END ############\n    }\n\n    ####### GENERATED SECTION! DON'T EDIT! ########\n    init() {\n        class_connections.init_ui_extension();\n    }\n    ############ GENERATED SECTION END ############\n}\n\n####### GENERATED SECTION! DON'T EDIT! ########\nclass ClassConnections_CodeUiExtension {\n    private {\n        # map of prefixed class names to class instances\n        hash<auto> class_map;\n    }\n\n    constructor() {\n        class_map = {\n            \"BBM_QorusUiExtension\": new BBM_QorusUiExtension(),\n        };\n    }\n\n    auto callClassWithPrefixMethod(string prefixed_class, string method) {\n        UserApi::logDebug(\"ClassConnections_CodeUiExtension: callClassWithPrefixMethod: method: %s class: %y\", method, prefixed_class);\n        return call_object_method_args(class_map{prefixed_class}, method, argv);\n    }\n\n    auto init_ui_extension(auto params) {\n        UserApi::logDebug(\"init_ui_extension called with data: %y\", params);\n\n        UserApi::logDebug(\"calling init: %y\", params);\n        return callClassWithPrefixMethod(\"BBM_QorusUiExtension\", \"init\", params);\n    }\n}\n############ GENERATED SECTION END ############\n",
          "base-class-name": "QorusService",
          "class-name": "CodeUiExtension",
          "servicetype": "USER",
          "name": "code-ui-extension",
          "display_name": "Code Ui Extension",
          "short_desc": "Code server UI extension",
          "version": "1.0",
          "autostart": true,
          "remote": false,
          "methods": [
            {
              "name": "init",
              "author": "Qore Technologies, s.r.o."
            }
          ],
          "author": ["Qore Technologies, s.r.o."],
          "classes": [
            {
              "id": 1,
              "name": "BBM_QorusUiExtension"
            }
          ],
          "config-items": [
            {
              "name": "ui-extension-group",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_QorusUiExtension",
                "interface-version": "1.0"
              },
              "value": "Code Server"
            },
            {
              "name": "ui-extension-menu",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_QorusUiExtension",
                "interface-version": "1.0"
              },
              "value": "Code Server"
            },
            {
              "name": "ui-extension-desc",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_QorusUiExtension",
                "interface-version": "1.0"
              },
              "value": "Provides access to the VS Code Server from Qorus until it can be integrated in the UI "
            },
            {
              "name": "ui-extension-default-resource",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_QorusUiExtension",
                "interface-version": "1.0"
              },
              "value": "extension-ui/index.qhtml"
            }
          ]
        },
        "supports_enable": true,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got service 248"
    },
    {
      "request_id": "bEB0CdnIJt4DsCs",
      "tab_token": "none",
      "data": {
        "iface_kind": "service",
        "service": {
          "id": 12,
          "type": "service",
          "desc": "## Qorus API\n\nPublically accessible API providing information about Qorus versions and component versions.\n\n## Public URL\n\n[https://api.qoretechnologies.com/qorus-api](https://api.qoretechnologies.com/qorus-api)",
          "lang": "qore",
          "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass QorusApi inherits BBM_RestServiceBase {\n    init() {\n        BBM_RestServiceBase::init();\n    }\n\n    private AbstractServiceHttpHandler getHandlerImpl() {\n        return new QorusApiRestHandler();\n    }\n\n    string getClientSecret(string app_name, string client_id) {\n        return QorusOAuth2AppsRestClass::getClientSecretEx(app_name, client_id);\n    }\n}\n\nclass QorusVersionSeriesRestClass inherits BBM_RestClass {\n    private {\n        hash<auto> info;\n    }\n\n    constructor(hash<auto> info) {\n        self.info = info;\n    }\n\n    string name() {\n        return info.qorus_series;\n    }\n\n    *AbstractRestClass subClass(string arg, hash<auto> cx, *hash<auto> ah) {\n        if (exists (auto val = info{arg})) {\n            return new BBM_AttributeRestClass(val);\n        }\n    }\n\n    hash<HttpHandlerResponseInfo> get(hash<auto> cx, *hash<auto> ah) {\n        return RestHandler::makeResponse(200, info);\n    }\n\n    hash<HttpHandlerResponseInfo> put(hash<auto> cx, *hash<auto> ah) {\n        # need to explicitly authenticate the request if possible\n        ServiceApi::tryAuthenticateRequest(\\cx);\n        ServiceApi::checkAuthorizationOr(\"VERSION-CONTROL\");\n\n        #ServiceApi::logInfo(\"user: %y auth: %y user: %y hdr: %y ar: %y\", cx.user,\n        #     ServiceApi::testAuthorization(\"VERSION-CONTROL\"), UserApi::getUserInfo(cx.user), cx.hdr);\n\n        AbstractTable versions = UserApi::getSqlTable(\"qorus-api\", \"qorus_api_qorus_series\");\n        on_error versions.rollback();\n        on_success versions.commit();\n\n        {\n            UpdateHelper uh = QorusSeriesRestClass::lockUpdateVersion();\n            versions.update(ah, {\"qorus_series\": info.qorus_series});\n            uh.update(info.qorus_series, info + ah);\n        }\n\n        return RestHandler::makeResponse(200, info + ah);\n    }\n\n    hash<HttpHandlerResponseInfo> del(hash<auto> cx, *hash<auto> ah) {\n        # need to explicitly authenticate the request if possible\n        ServiceApi::tryAuthenticateRequest(\\cx);\n        ServiceApi::checkAuthorizationOr(\"VERSION-CONTROL\");\n\n        AbstractTable versions = UserApi::getSqlTable(\"qorus-api\", \"qorus_api_qorus_series\");\n        on_error versions.rollback();\n        on_success versions.commit();\n\n        {\n            UpdateHelper uh = QorusSeriesRestClass::lockUpdateVersion();\n            versions.del(info.qorus_series);\n            uh.del(info.qorus_series);\n        }\n\n        return RestHandler::makeResponse(200, \"OK\");\n    }\n}\n\nclass QorusSeriesRestClass inherits BBM_RestClass {\n    private {\n        # version map: version series -> version info\n        static hash<string, hash<auto>> vmap;\n        static Mutex m();\n        static list<string> required_keys;\n    }\n\n    string name() {\n        return \"qorus-series\";\n    }\n\n    *AbstractRestClass subClass(string arg, hash<auto> cx, *hash<auto> ah) {\n        checkVmap();\n        if (*hash<auto> info = vmap{arg}) {\n            return new QorusVersionSeriesRestClass(info);\n        }\n    }\n\n    hash<HttpHandlerResponseInfo> get(hash<auto> cx, *hash<auto> ah) {\n        checkVmap();\n        return RestHandler::makeResponse(200, vmap.values());\n    }\n\n    hash<HttpHandlerResponseInfo> post(hash<auto> cx, *hash<auto> ah) {\n        # need to explicitly authenticate the request if possible\n        ServiceApi::tryAuthenticateRequest(\\cx);\n        ServiceApi::checkAuthorizationOr(\"VERSION-CONTROL\");\n\n        checkVmap();\n\n        foreach string key in (required_keys) {\n            if (!ah{key}.val()) {\n                throw \"VERSION-ARG-ERROR\", sprintf(\"missing required key %y\", key);\n            }\n        }\n\n        AbstractTable versions = UserApi::getSqlTable(\"qorus-api\", \"qorus_api_qorus_series\");\n        on_error versions.rollback();\n        on_success versions.commit();\n\n        {\n            UpdateHelper uh = QorusSeriesRestClass::lockUpdateVersion();\n            versions.insert(ah);\n            uh.add(ah);\n        }\n\n        return RestHandler::makeResponse(200, ah);\n    }\n\n    static UpdateHelper lockUpdateVersion() {\n        return new UpdateHelper(m, \\vmap, \"qorus_series\");\n    }\n\n    static private checkVmap() {\n        if (vmap) {\n            return;\n        }\n\n        AutoLock al(m);\n\n        # check again in the lock\n        if (vmap) {\n            return;\n        }\n\n        AbstractTable versions = UserApi::getSqlTable(\"qorus-api\", \"qorus_api_qorus_series\");\n        vmap = cast<hash<string, hash<auto>>>(map {\n            $1.qorus_series: $1,\n        }, versions.selectRows({\n            \"columns\": (\"qorus_series\", \"qorus_version\", \"series_release_date\", \"release_date\", \"support_end\"),\n        }));\n\n        #! set required keys\n        required_keys = map $1.key, versions.describe().pairIterator(),\n            $1.value.getDescriptionHash().notnull;\n    }\n}\n\nclass QorusOAuth2AppRestClass inherits BBM_RestClass {\n    private {\n        hash<auto> app;\n    }\n\n    constructor(hash<auto> app) {\n        self.app = app;\n    }\n\n    string name() {\n        return app.name;\n    }\n\n    *AbstractRestClass subClass(string arg, hash<auto> cx, *hash<auto> ah) {\n        if (app.hasKey(arg)) {\n            return new BBM_AttributeRestClass(app{arg});\n        }\n    }\n\n    hash<HttpHandlerResponseInfo> get(hash<auto> cx, *hash<auto> ah) {\n        return RestHandler::makeResponse(200, app);\n    }\n\n    hash<HttpHandlerResponseInfo> del(hash<auto> cx, *hash<auto> ah) {\n        # need to explicitly authenticate the request if possible\n        ServiceApi::tryAuthenticateRequest(\\cx);\n        ServiceApi::checkAuthorizationOr(\"OAUTH2-CONTROL\");\n\n        AbstractTable apps = UserApi::getSqlTable(\"qorus-api\", \"qorus_oauth2_apps\");\n        AbstractTable clients = UserApi::getSqlTable(\"qorus-api\", \"qorus_oauth2_clients\");\n        on_error apps.rollback();\n        on_success apps.commit();\n\n        int rows = 0;\n        {\n            UpdateHelper uh = QorusOAuth2AppsRestClass::lockUpdateApp();\n\n            rows += clients.del({\"app_id\": app.app_id});\n            rows += apps.del({\"app_id\": app.app_id});\n\n            uh.del(app.app_id);\n        }\n\n        return RestHandler::makeResponse(200, {\"info\": sprintf(\"%d row%s affected\", rows, rows == 1 ? \"\" : \"s\")});\n    }\n\n    hash<HttpHandlerResponseInfo> put(hash<auto> cx, *hash<auto> ah) {\n        # need to explicitly authenticate the request if possible\n        ServiceApi::tryAuthenticateRequest(\\cx);\n        ServiceApi::checkAuthorizationOr(\"OAUTH2-CONTROL\");\n\n        AbstractTable oauth2_apps = UserApi::getSqlTable(\"qorus-api\", \"qorus_oauth2_apps\");\n        on_error oauth2_apps.rollback();\n        on_success oauth2_apps.commit();\n\n        *hash<auto> client = remove ah.\"client\";\n\n        int rows = 0;\n        {\n            UpdateHelper uh = QorusOAuth2AppsRestClass::lockUpdateApp();\n\n            if (ah) {\n                on_error rethrow $1.err, $1.desc, $1.arg + {\"app arg\": ah};\n                rows += oauth2_apps.update(ah, {\"app_id\": app.app_id});\n                ServiceApi::logInfo(\"updated app %y: %y\", app.name, ah);\n            }\n            ah.clients = app.clients;\n            ah.client = app.client;\n            if (client) {\n                AbstractTable oauth2_clients = UserApi::getSqlTable(\"qorus-api\", \"qorus_oauth2_clients\");\n                if (client.typeCode() != NT_HASH) {\n                    throw \"CLIENT-ARG-ERROR\", sprintf(\"client has type %y; expecting \\\"hash\\\"\", client.fullType());\n                }\n\n                auto cname = remove client.client;\n                if (cname.typeCode() != NT_STRING) {\n                    throw \"CLIENT-ARG-ERROR\", sprintf(\"client has a missing or invalid \\\"client\\\" value; got: %y\", cname);\n                }\n\n                if (cname[0] == \"-\") {\n                    # delete a client\n                    cname = cname[1..];\n\n                    if (*hash<auto> dclient = app.clients{cname}) {\n                        int change = oauth2_clients.del({\"app_id\": app.app_id, \"client\": cname});\n                        rows += change;\n                        if (change) {\n                            ServiceApi::logInfo(\"app %y: deleted client %y\", app.name, cname);\n                        }\n                        remove ah.clientidmap{dclient.oauth2_client_id};\n                        remove ah.clients{cname};\n                        if (ah.client.client == cname) {\n                            # find new primary client\n                            ah.client = primaryClient(ah.clients);\n                        }\n                    } else {\n                        ServiceApi::logWarn(\"app %y: cannot delete unknown client %y\", app.name, cname);\n                    }\n                } else if (cname[0] == \"+\") {\n                    # insert a client\n                    cname = cname[1..];\n                    client = {\"client\": cname} + client;\n                    oauth2_clients.insert({\"app_id\": app.app_id} + client);\n                    ServiceApi::logInfo(\"app %y: inserted client %y\", app.name, cname);\n                    ++rows;\n                    ah.clients{cname} = client;\n                    ah.clientidmap{client.oauth2_client_id} = client.oauth2_client_secret;\n                    # find new primary client\n                    ah.client = primaryClient(ah.clients);\n                } else {\n                    if (*hash<auto> cclient = app.clients{cname}) {\n                        # update the client\n                        client = {\"client\": cname} + client;\n                        int uc = oauth2_clients.upsert(client + {\"app_id\": app.app_id},\n                            AbstractTable::UpsertSelectFirst);\n                        ServiceApi::logInfo(\"app %y: %s client %y: %y\", app.name,\n                            AbstractTable::UpsertResultMap{uc}, cname, client);\n                        switch (uc) {\n                            case AbstractTable::UR_Inserted:\n                            case AbstractTable::UR_Updated:\n                                ++rows;\n                                break;\n                        }\n\n                        # update ID map\n                        ah.clientidmap{client.oauth2_client_id} = client.oauth2_client_secret;\n\n                        # find new primary client\n                        ah.client = primaryClient(ah.clients);\n                    } else {\n                        ServiceApi::logWarn(\"app %y: cannot delete unknown client %y\", app.name, cname);\n                    }\n                }\n            }\n            uh.update(app.app_id, app + ah);\n        }\n\n        return RestHandler::makeResponse(200, {\"info\": sprintf(\"%d row%s affected\", rows, rows == 1 ? \"\" : \"s\")});\n    }\n\n    static private hash<auto> primaryClient(*hash<auto> clients) {\n        hash<auto> client;\n        # set primary client for app\n        foreach hash<auto> cclient in (clients.values()) {\n            # process primary / latest client for app\n            if (client && (cclient.client_exp && !client.client_exp)\n                || (cclient.client_exp && client.client_exp\n                    && cclient.client_exp < client.client_exp)) {\n                    continue;\n            }\n            client = cclient;\n        }\n        return client;\n    }\n}\n\nclass QorusOAuth2AppsRestClass inherits BBM_RestClass {\n    private {\n        # app map: app ID -> app info\n        static hash<string, hash<auto>> appmap;\n        # app map: app name -> app info\n        static hash<string, hash<auto>> appnamemap;\n        static Mutex m();\n        static list<string> required_keys;\n\n        static date cache_timestamp;\n    }\n\n    string name() {\n        return \"oauth2-apps\";\n    }\n\n    *AbstractRestClass subClass(string arg, hash<auto> cx, *hash<auto> ah) {\n        checkAppmap();\n        *hash<auto> app = arg.intp()\n            ? appmap{arg}\n            : appnamemap{arg};\n        if (app) {\n            return new QorusOAuth2AppRestClass(app - (\"clientidmap\", \"clients\"));\n        }\n    }\n\n/*\n    hash<HttpHandlerResponseInfo> getApps(hash<auto> cx, *hash<auto> ah) {\n        checkAppmap();\n        return RestHandler::makeResponse(200, appmap);\n    }\n\n    hash<HttpHandlerResponseInfo> getAppNames(hash<auto> cx, *hash<auto> ah) {\n        checkAppmap();\n        return RestHandler::makeResponse(200, appnamemap);\n    }\n*/\n\n    hash<HttpHandlerResponseInfo> getInfo(hash<auto> cx, *hash<auto> ah) {\n        checkAppmap();\n        int clients = foldl $1 + $2, (map $1.clients.size(), appmap.values());\n        return RestHandler::makeResponse(200, {\n            \"apps\": appmap.size(),\n            \"clients\": clients,\n            \"cached\": cache_timestamp,\n        });\n    }\n\n    hash<HttpHandlerResponseInfo> get(hash<auto> cx, *hash<auto> ah) {\n        checkAppmap();\n\n        # only return the latest client for each app\n        hash<auto> rv = appmap;\n        foreach hash<auto> i in (rv.pairIterator()) {\n            remove rv{i.key}.clientidmap;\n            foreach hash<auto> client in ((remove rv{i.key}.clients).values()) {\n                if ((*hash<auto> current_client = rv{i.key}.client)\n                    && ((client.client_exp && !current_client.client_exp)\n                        || (client.client_exp && current_client.client_exp\n                            && client.client_exp > current_client.client_exp))) {\n                    continue;\n                }\n                # do not return the real client secret\n                rv{i.key}.client = client - \"app_id\" + {\n                    \"oauth2_client_secret\": \"cloud\",\n                };\n            }\n        }\n        return RestHandler::makeResponse(200, rv.values());\n    }\n\n    hash<HttpHandlerResponseInfo> postReload(hash<auto> cx, *hash<auto> ah) {\n        # need to explicitly authenticate the request if possible\n        ServiceApi::tryAuthenticateRequest(\\cx);\n        ServiceApi::checkAuthorizationOr(\"OAUTH2-CONTROL\");\n\n        {\n            AutoLock al(m);\n            remove appmap;\n            remove appnamemap;\n\n            cacheApps();\n        }\n\n        return RestHandler::makeResponse(200, \"OK\");\n    }\n\n    hash<HttpHandlerResponseInfo> post(hash<auto> cx, *hash<auto> ah) {\n        # need to explicitly authenticate the request if possible\n        ServiceApi::tryAuthenticateRequest(\\cx);\n        ServiceApi::checkAuthorizationOr(\"OAUTH2-CONTROL\");\n\n        switch (ah.clients.typeCode()) {\n            case NT_LIST:\n                if (ah.clients[0].typeCode() != NT_HASH) {\n                    throw \"CLIENTS-ARG-ERROR\", sprintf(\"the \\\"clients\\\" arg must be a list of hashes or a hash; got \"\n                        \"type %y in the first elements of the \\\"clients\\\" list instead\", ah.clients[0].fullType());\n                }\n            case NT_HASH:\n            case NT_NOTHING:\n                break;\n\n            default:\n                throw \"CLIENTS-ARG-ERROR\", sprintf(\"the \\\"clients\\\" arg must be a list of hashes or a hash; got \"\n                    \"type %y instead\", ah.clients[0].fullType());\n        }\n\n        checkAppmap();\n\n        foreach string key in (required_keys) {\n            if (!ah{key}.val()) {\n                throw \"VERSION-ARG-ERROR\", sprintf(\"missing required key %y\", key);\n            }\n        }\n\n        hash<auto> client;\n        hash<string, hash<auto>> clients;\n        # set primary client for app\n        foreach hash<auto> cclient in (remove ah.clients) {\n            cclient -= (\"app_id\", \"client_id\");\n            # add to all clients\n            clients{cclient.client} = cclient;\n            # process primary / latest client for app\n            if (client && (cclient.client_exp && !client.client_exp)\n                || (cclient.client_exp && client.client_exp\n                    && cclient.client_exp < client.client_exp)) {\n                    continue;\n            }\n            client = cclient;\n        }\n\n        if (!ah) {\n            throw \"APP-ARG-ERROR\", \"No arguments passed to create app API\";\n        }\n\n        AbstractTable apps = UserApi::getSqlTable(\"qorus-api\", \"qorus_oauth2_apps\");\n        on_error apps.rollback();\n        on_success apps.commit();\n\n        {\n            UpdateHelper uh = lockUpdateApp();\n\n            hash<auto> app = ah;\n            ah.app_id = apps.insert(app, {\n                \"returning\": \"app_id\",\n            }).app_id;\n\n            if (ah.clients) {\n                AbstractTable clients = UserApi::getSqlTable(\"qorus-api\", \"qorus_oauth2_clients\");\n                #AbstractTable redirects = UserApi::getSqlTable(\"qorus-api\", \"qorus_oauth2_clients\");\n                map clients.insert({\"app_id\": ah.app_id} + $1), ah.clients;\n\n                # convert to a map of clients keyed by unique client name\n                ah += {\n                    \"clients\": clients,\n                    \"client\": client,\n                };\n            }\n\n            uh.add(ah);\n        }\n\n        return RestHandler::makeResponse(200, ah);\n    }\n\n    static UpdateHelper lockUpdateApp() {\n        return new UpdateHelper(m, \\appmap, \"app_id\", \\appnamemap, \"name\");\n    }\n\n    static *string getClientSecret(string name, string client_id) {\n        QorusOAuth2AppsRestClass::checkAppmap();\n        return appnamemap{name}.clientidmap{client_id};\n    }\n\n    static string getClientSecretEx(string name, string client_id) {\n        *string secret = QorusOAuth2AppsRestClass::getClientSecret(name, client_id);\n        if (!secret) {\n            throw \"OAUTH2-ERROR\", sprintf(\"no secret found for app %y and client ID %y\", name, client_id);\n        }\n        return secret;\n    }\n\n    static private checkAppmap() {\n        if (appmap) {\n            return;\n        }\n\n        AutoLock al(m);\n\n        # check again in the lock\n        if (appmap) {\n            return;\n        }\n\n        QorusOAuth2AppsRestClass::cacheApps();\n    }\n\n    static private cacheApps() {\n        cache_timestamp = now_us();\n\n        AbstractTable apps = UserApi::getSqlTable(\"qorus-api\", \"qorus_oauth2_apps\");\n        AbstractTable clients = UserApi::getSqlTable(\"qorus-api\", \"qorus_oauth2_clients\");\n        AbstractTable redirects = UserApi::getSqlTable(\"qorus-api\", \"qorus_oauth2_client_redirects\");\n\n        # write to local vars and update at the end\n        hash<string, hash<auto>> appmap;\n        hash<string, hash<auto>> appnamemap;\n\n        # client -> app ID  map\n        hash<string, string> clientappmap;\n\n        appmap = cast<hash<string, hash<auto>>>(map {$1.app_id: $1}, apps.selectRows());\n        # add clients to each app\n        foreach hash<auto> client in (clients.selectRows({\n            \"where\": {\n                \"app_id\": op_in(map $1.toInt(), keys appmap),\n            }\n        })) {\n            softstring app_id = remove client.app_id;\n            remove client.client_id;\n            # add to all clients\n            appmap{app_id}.clients{client.client} = client;\n            # process primary / latest client for app\n            if ((*hash<auto> current_client = appmap{app_id}.client)\n                && ((client.client_exp && !current_client.client_exp)\n                    || (client.client_exp && current_client.client_exp\n                        && client.client_exp < current_client.client_exp))) {\n                continue;\n            }\n            appmap{app_id}.client = client;\n            appmap{app_id}.clientidmap{client.oauth2_client_id} = client.oauth2_client_secret;\n\n            clientappmap{client.client} = app_id;\n        }\n\n        # add redirects to each client\n        foreach hash<auto> redirect in (redirects.selectRows({\n            \"where\": {\n                \"client\": op_in(keys clientappmap),\n            },\n        })) {\n            softstring app_id = clientappmap{redirect.client};\n            appmap{app_id}.clients{redirect.client}.redirects{redirect.redirect_root} = True;\n        }\n\n        # populate name map\n        map appnamemap{$1.name} = $1, appmap.values();\n\n        # set required keys\n        required_keys = map $1.key, (apps.describe() - \"app_id\").pairIterator(),\n            $1.value.getDescriptionHash().notnull;\n\n        QorusOAuth2AppsRestClass::appmap = appmap;\n        QorusOAuth2AppsRestClass::appnamemap = appnamemap;\n    }\n}\n\nclass QorusOAuth2TokenRestClass inherits BBM_RestClass {\n    string name() {\n        return \"token\";\n    }\n\n    #! Makes an OAuth2 token request to the token URL and returns the response\n    hash<HttpHandlerResponseInfo> post(hash<auto> cx, *hash<auto> ah) {\n        # remove args needed to build the request\n        string oauth2_app = doGetString(ah, \"oauth2_app\");\n        remove ah.oauth2_app;\n        string token_url = doGetString(ah, \"oauth2_token_url\");\n        remove ah.token_url;\n        *hash<auto> headers;\n        if (*string hdr = doGetString(ah, \"oauth2_headers\", True)) {\n            headers = parse_yaml(hdr);\n        }\n\n        # process args needed for the client and the request\n        string grant_type = doGetString(ah, \"grant_type\");\n        string client_id = doGetString(ah, \"client_id\");\n        string client_secret = ah.client_secret = QorusOAuth2AppsRestClass::getClientSecretEx(oauth2_app, client_id);\n\n        # setup client arguments\n        hash<auto> opts = {\n            \"url\": token_url,\n            \"data\": \"url\",\n        };\n\n        RestClient rc(opts);\n        hash<auto> info;\n        return RestHandler::makeResponse(200, rc.doRequest(\"POST\", \"\", ah, \\info, NOTHING, headers).body);\n    }\n}\n\nclass QorusApiRestHandler inherits BBM_RestHandlerBase {\n    constructor() : BBM_RestHandlerBase() {\n        addClass(new QorusSeriesRestClass());\n        addClass(new QorusOAuth2AppsRestClass());\n        addClass(new QorusOAuth2TokenRestClass());\n    }\n}\n\nclass UpdateHelper {\n    private {\n        Mutex m;\n        reference<hash<string, hash<auto>>> dmap;\n        string key;\n        *reference<hash<string, hash<auto>>> altdmap;\n        string altkey;\n    }\n\n    constructor(Mutex m, reference<hash<string, hash<auto>>> dmap, string key,\n            *reference<hash<string, hash<auto>>> altdmap, *string altkey) {\n        self.m = m;\n        self.dmap = \\dmap;\n        self.key = key;\n        if (altkey) {\n            self.altdmap = \\altdmap;\n            self.altkey = altkey;\n        }\n\n        m.lock();\n    }\n\n    destructor() {\n        m.unlock();\n    }\n\n    add(hash<auto> h) {\n        if (!h{key}.val()) {\n            throw \"MAP-ERROR\", sprintf(\"missing value for key %y in map (value: %y)\", key, h);\n        }\n        if (altkey && !h{altkey}.val()) {\n            throw \"MAP-ERROR\", sprintf(\"missing value for alternate key %y in map (value: %y)\", altkey, h);\n        }\n\n        dmap{h{key}} = h;\n        if (altkey) {\n            altdmap{h{altkey}} = h;\n        }\n    }\n\n    update(string k, hash<auto> v) {\n        if (dmap{k} && altkey && dmap{k}{altkey} != v{altkey}) {\n            altdmap{v{altkey}} = remove altdmap{dmap{k}{altkey}};\n        }\n        dmap{k} = v;\n    }\n\n    del(softstring k) {\n        if (altkey) {\n            remove altdmap{dmap{k}{altkey}};\n        }\n        remove dmap{k};\n    }\n}\n",
          "base-class-name": "BBM_RestServiceBase",
          "class-name": "QorusApi",
          "servicetype": "USER",
          "name": "qorus-api",
          "display_name": "Qorus Api",
          "short_desc": "## Qorus API",
          "version": "1.0",
          "autostart": true,
          "remote": false,
          "methods": [
            {
              "name": "init",
              "author": "Qore Technologies, s.r.o."
            },
            {
              "name": "getClientSecret",
              "author": "Qore Technologies, s.r.o.",
              "internal": true
            }
          ],
          "groups": ["QORUS-API"],
          "author": ["Qore Technologies, s.r.o."],
          "classes": [
            {
              "id": 1,
              "name": "BBM_HttpServiceGenericBase"
            },
            {
              "id": 2,
              "name": "BBM_HttpAuthenticatorBase"
            },
            {
              "id": 3,
              "name": "BBM_CorsBase"
            },
            {
              "id": 4,
              "name": "BBM_RestServiceBase"
            }
          ],
          "config-items": [
            {
              "name": "http-listener-bind-address",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-cert-location",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-cert-format",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-key-location",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-key-format",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-key-password",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-ssl-mode",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-accept-all-certs",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-capture-client-certs",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-root-uri",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              },
              "value": "qorus-api"
            },
            {
              "name": "rest-auth-name",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              },
              "value": "permissive"
            },
            {
              "name": "rest-auth-cookie",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-auth-redirect",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-swagger-schema",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-remove-leading-path-components",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-cors-enable",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              },
              "value": true
            },
            {
              "name": "rest-cors-methods",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-cors-max-age",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-cors-headers",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-cors-credentials",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-allow-sharing",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            }
          ]
        },
        "supports_enable": true,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got service 12"
    },
    {
      "request_id": "RQTN995x8y1R7mf",
      "tab_token": "none",
      "data": {
        "iface_kind": "service",
        "service": {
          "id": 279,
          "type": "service",
          "desc": "Handles OAuth2 redirect URI requests and redirects to the real URI using the value of the `state` key",
          "lang": "qore",
          "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass QorusOauth2Redirect inherits BBM_HttpServiceBase {\n    #! Returns the HTTP handler for the service\n    private AbstractServiceHttpHandler getHandlerImpl() {\n        return new QorusOauth2RedirectHandler();\n    }\n}\n\nclass QorusOauth2RedirectHandler inherits BBM_HttpHandlerBase {\n    public {\n        const RequiredParams = (\n            \"state\",\n            \"code\",\n        );\n\n        const RequiredStateKeys = (\n            \"auth_context\",\n            \"conn\",\n            \"redirect_uri\",\n            \"update_connection_uri\",\n            \"token_uri\",\n        );\n\n        const TokenRequestHeaders = {\n            \"Accept\": MimeTypeFormUrlEncoded,\n        };\n    }\n\n    hash<HttpResponseInfo> handleRequest(HttpListenerInterface listener, Socket s, hash<auto> cx, hash<auto> hdr,\n            *data body) {\n        #logInfo(\"hdr: %y\", hdr);\n        if (hdr.method != \"OPTIONS\") {\n            *hash<HttpResponseInfo> rv = tryRedirectRequest(cx, hdr);\n            logInfo(\"rv: %y\", rv);\n            if (rv) {\n                return rv;\n            }\n        }\n        return BBM_HttpHandlerBase::handleRequest(listener, s, cx, hdr, body);\n    }\n\n    #! Handles incoming requests\n    /** The \\c state parameter must be a yaml-serialized, base64-encoded hash with at least the following keys:\n        - \\c conn: the connection name to update\n        - \\c token_uri: will be used to exchange the authorization code for tokens\n        - \\c auth_context: encrytped authentication info for the redirect that will update the connection in the\n          original Qorus instance\n        - \\c redirect_uri: will be used to redirect the results to the original caller using \\c update_connection_uri\n        - \\c update_connection_uri: will be the first redirect that will update the connection in the originating\n          Qorus instance; this will afterwards redirect to \\c redirect_uri\n\n        All other values in the state hash will be used in the call to the token URI\n    */\n    private *hash<HttpResponseInfo> tryRedirectRequest(hash<auto> cx, hash<auto> hdr) {\n        hash<auto> info;\n        try {\n            hash<UriQueryInfo> h = parse_uri_query(hdr.path);\n            # check for required params\n            foreach string key in (RequiredParams) {\n                if (!h.params.hasKey(key)) {\n                    throw \"REQUEST-ERROR\", sprintf(\"request params: %y missing required key %y\", h.params, key);\n                }\n            }\n            # parse state\n            hash<auto> state = parseState(h.params);\n\n            string conn = remove state.conn;\n            string auth_context = remove state.auth_context;\n\n            # lookup client_secret if necessary\n            if (state.client_secret == \"cloud\" && state.oauth2_app.val() && state.client_id.val() ) {\n                state.client_secret = omqservice.user.\"qorus-api\".getClientSecret(state.oauth2_app, state.client_id);\n            }\n\n            # exchange authorization code for tokens\n            RestClient auth({\n                \"url\": remove state.token_uri,\n                \"data\": \"url\",\n            });\n\n            string update_connection_uri = remove state.update_connection_uri;\n            string redirect_uri = remove state.redirect_uri;\n            if (!state.grant_type) {\n                state.grant_type = \"authorization_code\";\n            }\n            # add parameters from original request\n            state += (h.params - \"state\") + {\n                \"redirect_uri\": \"https://api.qoretechnologies.com/qorus-oauth2-redirect\",\n            };\n            logInfo(\"making request to: %y for redirect: %y\", auth.getURL(), redirect_uri);\n\nlogInfo(\"STATE: %N\", state);\n\n            # exchange code for tokens\n            hash<auto> resp = auth.post(\"\", state, \\info, TokenRequestHeaders);\n            resp = resp.body;\n\n            return <HttpResponseInfo>{\n                \"code\": 307,\n                \"hdr\": {\n                    \"Location\": getRedirectUri(update_connection_uri, redirect_uri, resp + {\n                        \"conn\": conn,\n                        \"auth_context\": auth_context,\n                    }),\n                },\n            };\n        } catch (hash<ExceptionInfo> ex) {\n            logError(\"request origin info: %y: %s: %s\", cx.\"peer-info\", ex.err, ex.desc);\n            if (info) {\n                logError(\"call info: %N\", info);\n            }\n            rethrow;\n        }\n    }\n\n    private static hash<auto> parseState(hash<auto> params) {\n        hash<auto> state = parse_yaml(parse_base64_string_to_string(remove params.state));\n        # check for required state keys\n        foreach string key in (RequiredStateKeys) {\n            if (!state.hasKey(key)) {\n                throw \"STATE-ERROR\", sprintf(\"state: %y is missing required key %y\", state, key);\n            }\n        }\n        return state;\n    }\n\n    private static string getRedirectUri(string update_connection_uri, string redirect_uri, hash<auto> h) {\n        if (update_connection_uri !~ /\\?/) {\n            update_connection_uri += \"?\";\n        } else {\n            update_connection_uri += \"&\";\n        }\n        update_connection_uri += sprintf(\"redirect_uri=%s\", make_base64_string(redirect_uri));\n\n        # add parameters from token response\n        map update_connection_uri += (\"&\" + sprintf(\"%s=%s\", $1.key, $1.value)), h.pairIterator();\n        return update_connection_uri;\n    }\n}\n",
          "base-class-name": "BBM_HttpServiceBase",
          "class-name": "QorusOauth2Redirect",
          "servicetype": "USER",
          "name": "qorus-oauth2-redirect",
          "display_name": "Qorus Oauth2 Redirect",
          "short_desc": "Handles OAuth2 redirect URI requests and redirects to the real URI using the value of the 'state' key",
          "version": "1.0",
          "autostart": true,
          "remote": false,
          "methods": [
            {
              "name": "init",
              "author": "Qore Technologies, s.r.o."
            }
          ],
          "author": ["Qore Technologies, s.r.o."],
          "classes": [
            {
              "id": 1,
              "name": "BBM_HttpServiceGenericBase"
            },
            {
              "id": 2,
              "name": "BBM_HttpAuthenticatorBase"
            },
            {
              "id": 3,
              "name": "BBM_CorsBase"
            },
            {
              "id": 4,
              "name": "BBM_HttpServiceBase"
            }
          ],
          "config-items": [
            {
              "name": "http-listener-bind-address",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_HttpServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-cert-location",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_HttpServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-cert-format",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_HttpServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-key-location",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_HttpServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-key-format",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_HttpServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-key-password",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_HttpServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-ssl-mode",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_HttpServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-accept-all-certs",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_HttpServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-capture-client-certs",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_HttpServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-root-uri",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_HttpServiceBase",
                "interface-version": "1.0"
              },
              "value": "/qorus-oauth2-redirect"
            },
            {
              "name": "http-root-uri-is-regex",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_HttpServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-auth-name",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_HttpServiceBase",
                "interface-version": "1.0"
              },
              "value": "permissive"
            },
            {
              "name": "http-auth-cookie",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_HttpServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-auth-redirect",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_HttpServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-match-content-types",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_HttpServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-match-headers",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_HttpServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-cors-enable",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_HttpServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-cors-methods",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_HttpServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-cors-max-age",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_HttpServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-cors-headers",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_HttpServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-cors-credentials",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_HttpServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-allow-sharing",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_HttpServiceBase",
                "interface-version": "1.0"
              }
            }
          ]
        },
        "supports_enable": true,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got service 279"
    },
    {
      "request_id": "7IVghGTZ1GKmqOu",
      "tab_token": "none",
      "data": {
        "iface_kind": "service",
        "service": {
          "id": 215,
          "type": "service",
          "desc": "Discord bot for Qorus Discord Access",
          "lang": "qore",
          "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\n%requires DiscordDataProvider\n\nclass DiscordBot inherits QorusService {\n    public {\n        static Logger logger;\n        # REST client for the bot\n        static DiscordRestClient rest;\n    }\n\n    private {\n        DiscordWebSocketApiDataEventSource ws;\n    }\n\n    init() {\n        logger = new Logger(\"discord-bot\", LoggerLevel::getLevelInfo());\n        logger.addAppender(new QorusAppender());\n\n        rest = new DiscordRestClient({\n            \"token\": UserApi::getConfigItemValue(\"discord-bot-token\"),\n            \"token_type\": \"Bot\",\n            \"oauth2_grant_type\": NOTHING,\n        });\n\n        ws = new DiscordWebSocketApiDataEventSource();\n    }\n\n    hash<auto> info() {\n        return hash(ws{\"connmap\", \"guildmap\", \"channelmap\", \"dmmap\",} + {\n            \"users\": keys ws.usermap,\n            \"discord\": ws.discord.getConnectionInfo(),\n        });\n    }\n\n    string setLogLevel(string level) {\n        logger.setLevel(level);\n        return \"OK\";\n    }\n\n    bool reconnect() {\n        return ws.reconnect();\n    }\n}\n\nclass DiscordWebSocketConnection inherits BBM_WebSocketServiceDataEventSourceConnection {\n    constructor(hash<auto> cx, DiscordWebSocketHandler handler)\n            : BBM_WebSocketServiceDataEventSourceConnection(cx, handler) {\n    }\n\n    softstring getId() {\n        return cx.id;\n    }\n}\n\nclass DiscordWebSocketHandler inherits BBM_WebSocketServiceDataEventSourceHandler {\n    constructor(DiscordWebSocketApiDataEventSource service)\n            : BBM_WebSocketServiceDataEventSourceHandler(service) {\n    }\n\n    #! called when a connection is established\n    DiscordWebSocketConnection getConnectionImpl(hash<auto> cx, hash<auto> hdr, string cid) {\n        return new DiscordWebSocketConnection(cx, self);\n    }\n\n    #! called when the connection terminates\n    private deregisterConnectionImpl(DiscordWebSocketConnection wsc) {\n        # unsubscribe from all active channels\n        DiscordWebSocketApiDataEventSource::ws.unsubscribeAll(wsc.getId());\n        BBM_WebSocketServiceDataEventSourceHandler::deregisterConnectionImpl(wsc);\n    }\n}\n\nclass DiscordWebSocketApiDataEventSource inherits BBM_WebSocketServiceDataEventSource, DataProvider::Observer {\n    public {\n        # gateway event source\n        DiscordGatewayDataProvider discord;\n\n        # user map: user ID -> user info\n        hash<string, hash<UserInfo>> usermap;\n\n        # connection map: connection ID -> connection info\n        hash<string, hash<ConnInfo>> connmap;\n\n        # channel map: guild -> channel -> connection ID -> True\n        hash<string, hash<string, hash<string, bool>>> channelmap;\n\n        # guild map: guild -> connection ID -> True\n        hash<string, hash<string, bool>> guildmap;\n\n        # dmmap: username -> connection ID -> True\n        hash<string, hash<string, bool>> dmmap;\n\n        # guild channels: guild ID -> channel ID -> channel name\n        hash<string, hash<string, string>> guild_channel_ids;\n\n        # guild channels: guild ID -> channel name -> channel ID\n        hash<string, hash<string, string>> guild_channel_names;\n\n        # Mutex\n        Mutex lck();\n\n        # guild info condition hash, accessed only in lck: guild ID -> Condition\n        hash<string, Condition> gcond;\n\n        # guild info waiting hash, accessed only in lck: guild ID -> waiting\n        hash<string, int> gwaiting;\n\n        # user info condition hash, accessed only in lck: user ID -> Condition\n        hash<string, Condition> ucond;\n\n        # user info waiting hash, accessed only in lck: user ID -> waiting\n        hash<string, int> uwaiting;\n\n        static DiscordWebSocketApiDataEventSource ws;\n\n        # Discord gateway intents to capture messages\n        const GatewayIntents = DI_GUILD_MESSAGES | DI_DIRECT_MESSAGES | DI_MESSAGE_CONTENT;\n\n        const RetrySet = {\n            \"SOCKET-SSL-ERROR\": True,\n            \"SOCKET-CLOSED\": True,\n        };\n\n        const MaxIoRetries = 5;\n\n        # Channel categories to ignore\n        const IgnoreTypeMap = {\n            DCT_GUILD_VOICE: True,\n            DCT_GUILD_CATEGORY: True,\n            DCT_GUILD_STAGE_VOICE: True,\n        };\n    }\n\n    constructor() {\n        DiscordWebSocketApiDataEventSource::ws := self;\n\n        registerObserver(new WebSocketApiObserver(self));\n\n        discord = new DiscordGatewayDataProvider({\n            \"token\": UserApi::getConfigItemValue(\"discord-bot-token\"),\n            \"intents\": GatewayIntents,\n        });\n        discord.setLogger(DiscordBot::logger);\n        discord.registerObserver(self);\n        discord.observersReady();\n    }\n\n    bool reconnect() {\n        return discord.reconnect();\n    }\n\n    #! This method is called when a Discord event is raised\n    /**\n        @param event_id unique ID identifying an event type or class\n        @param data_ the data generated by the Observable event source\n    */\n    update(string event_id, hash<auto> data_) {\n        UserApi::logDebug(\"got event %y: %y\", event_id, data_);\n\n        if (event_id == EVENT_MESSAGE_CREATE) {\n            UserApi::logDebug(\"watched guilds: %y watched channels: %y\", guildmap, channelmap);\n\n            # check if we have a guild message\n            if (*string guild_id = data_.d.guild_id) {\n                UserApi::logDebug(\"dispatching to watchers of guild %y (%y) channel %y (%y))\", guild_id,\n                    keys guildmap{guild_id}, data_.d.channel_id, keys channelmap{guild_id}{data_.d.channel_id});\n\n                # dispatch to all channel watchers\n                map dispatch(event_id, data_, $1), keys channelmap{guild_id}{data_.d.channel_id};\n                # dispatch to all guild watchers\n                map dispatch(event_id, data_, $1), keys guildmap{guild_id};\n            } else {\n                UserApi::logInfo(\"ignoring DM\");\n                # TBA\n            }\n        } else {\n            UserApi::logDebug(\"ignoring event %y (!= %y)\", event_id, EVENT_MESSAGE_CREATE);\n        }\n    }\n\n    unsubscribeAll(string conn) {\n        *hash<ConnInfo> conninfo = remove connmap{conn};\n        if (!conninfo) {\n            UserApi::logInfo(\"connection %y closed\", conn);\n            return;\n        }\n\n        foreach hash<auto> i in (conninfo.channels.pairIterator()) {\n            map stopChannel(i.key, $1, conn), keys i.value;\n        }\n\n        map stopGuild($1, conn), keys conninfo.guilds;\n\n        if (conninfo.dm) {\n            stopDm(conninfo.userid, conn);\n        }\n        UserApi::logInfo(\"connection %y: all channels unsubscribed\", conn);\n    }\n\n    private dispatch(string event_id, hash<auto> data_, softint cid) {\n        try {\n            sendMessage(<WebSocketSendEventInfo>{\n                \"cid\": cid,\n                \"msg\": {\n                    \"reqid\": -1,\n                    \"type\": \"event\",\n                    \"event-type\": event_id,\n                    \"event\": data_,\n                },\n            });\n        } catch (hash<ExceptionInfo> ex) {\n            UserApi::logError(\"failed to dispatch event to connection %d: %s\", cid,\n                get_exception_string(ex));\n        }\n    }\n\n    #! Stops listening on a guild channel\n    stopChannel(string guild, string channel, string conn) {\n        remove channelmap{guild}{channel}{conn};\n        if (!channelmap{guild}{channel}) {\n            remove channelmap{guild}{channel};\n            if (!channelmap{guild}) {\n                remove channelmap{guild};\n            }\n        }\n    }\n\n    #! Stops listening for all messages in a guild\n    stopGuild(string guild, string conn) {\n        remove guildmap{guild}{conn};\n        if (!guildmap{guild}) {\n            remove guildmap{guild};\n        }\n    }\n\n    #! Stops listening to direct messages\n    stopDm(string id, string conn) {\n        remove dmmap{id}{conn};\n        if (!dmmap{id}) {\n            remove dmmap{id};\n        }\n    }\n\n    checkGuildInfo(softstring id) {\n        if (guild_channel_ids{id}) {\n            return;\n        }\n        lck.lock();\n        on_exit lck.unlock();\n\n        while (*Condition cond = gcond{id}) {\n            ++gwaiting{id};\n            cond.wait(lck);\n            --gwaiting{id};\n        }\n\n        # check again\n        if (guild_channel_ids{id}) {\n            return;\n        }\n\n        gcond{id} = new Condition();\n        on_exit {\n            if (gwaiting{id}) {\n                gcond{id}.signal();\n            }\n            remove gcond{id};\n        }\n\n        # run the REST call unlocked\n        lck.unlock();\n        on_exit lck.lock();\n\n        hash<auto> info;\n        hash<auto> res;\n        try {\n            res = DiscordWebSocketApiDataEventSource::doRestCommand(NOTHING, DiscordBot::rest, \"GET\",\n                \"guilds/\" + id + \"/channels\", NOTHING, \\info);\n\n            # clear info in case a non-REST-related error is subsequently raised\n            remove info;\n        } catch (hash<ExceptionInfo> ex) {\n            string err = sprintf(\"error retrieving info for guild ID %y\", id);\n            if (info) {\n                err += sprintf(\": %y returned from %y\", info.\"response-uri\", info.\"request-uri\");\n                if (res) {\n                    err += sprintf(\", response body: %y\", res.body);\n                }\n            }\n            logError(\"%s\", err);\n            return;\n        }\n\n        logInfo(\"guild %s has the following channels: %y\", id, (map $1{\"id\", \"name\"}, res.body));\n\n        # create channel maps for the guilds\n        map guild_channel_ids{id}{$1.id} = $1.name, res.body, !IgnoreTypeMap{$1.type};\n        map guild_channel_names{id}{$1.name} = $1.id, res.body, !IgnoreTypeMap{$1.type};\n    }\n\n    # Caches user info\n    hash<UserInfo> cacheUserInfo(DiscordRestClient rest, hash<auto> res, reference<hash<auto>> info) {\n        hash<auto> uinfo = res.body;\n\n        lck.lock();\n        on_exit lck.unlock();\n\n        while (*Condition cond = ucond{uinfo.id}) {\n            ++uwaiting{uinfo.id};\n            cond.wait(lck);\n            --uwaiting{uinfo.id};\n        }\n\n        # check again\n        if (usermap{uinfo.id}) {\n            return usermap{uinfo.id};\n        }\n\n        ucond{uinfo.id} = new Condition();\n        on_exit {\n            if (uwaiting{uinfo.id}) {\n                ucond{uinfo.id}.signal();\n            }\n            remove ucond{uinfo.id};\n        }\n\n        hash<UserInfo> userinfo = <UserInfo>{\n            \"info\": uinfo,\n            \"ratelimit\": map {$1.key: $1.value}, res.pairIterator(), $1.key =~ /^x-ratelimit-/,\n        };\n        UserApi::logInfo(\"set ratelimit for user %s (id %s): %y\", userinfo.info.username,\n            userinfo.info.id, userinfo.ratelimit);\n\n        # run the REST call unlocked\n        lck.unlock();\n        on_exit lck.lock();\n\n        hash<auto> res = DiscordWebSocketApiDataEventSource::doRestCommand(\\userinfo, rest, \"GET\", \"users/@me/guilds\",\n            NOTHING, \\info);\n        list<auto> guilds = res.body;\n\n        # clear info in case a non-REST-related error is subsequently raised\n        remove info;\n\n        # get info on guilds accessible to the user\n        userinfo.guilds_by_name = cast<hash<string, string>>(map {$1.name: $1.id}, guilds);\n        userinfo.guilds_by_id = cast<hash<string, string>>(map {$1.id: $1.name}, guilds);\n\n        return usermap{uinfo.id} = userinfo;\n    }\n\n    #! Returns the HTTP handler for the service\n    private AbstractServiceHttpHandler getHandlerImpl() {\n        return new DiscordWebSocketHandler(self);\n    }\n\n    static hash<auto> doRestCommand(*reference<hash<UserInfo>> userinfo, DiscordRestClient rest, string method,\n            string path, auto body, reference<hash<auto>> info) {\n        int retries = 0;\n        while (True) {\n            try {\n                if (userinfo.ratelimit.\"x-ratelimit-remaining\" == \"0\"\n                    && (*softfloat r = userinfo.ratelimit.\"x-ratelimit-reset\")) {\n                    int lt = r.toInt(); softint us = (r - lt) * 1000000;\n                    date reset = localtime(lt, us);\n                    date diff = reset - now_us();\n                    # do something if the rate limit expiry time is in the future\n                    if (diff > 0s) {\n                        if (diff > 1m) {\n                            throw \"RATE-LIMIT-ERROR\", sprintf(\"the reset time: %y is more than 1 minute in the \"\n                                \"future (%y)\", reset, diff);\n                        }\n                        UserApi::logInfo(\"RATE LIMIT: connection for user %s (id %s) sleeping for: %y\",\n                            userinfo.info.username, userinfo.info.id, diff);\n                        ServiceApi::usleep(diff);\n                    }\n                }\n                UserApi::logInfo(\"REST %y %y (%y) body: %y\", method, rest.getURL(), path, body);\n                hash<auto> res = rest.doRequest(method, path, body, \\info);\n                if (userinfo && res.\"x-ratelimit-remaining\") {\n                    userinfo.ratelimit = map {$1.key: $1.value}, res.pairIterator(), $1.key =~ /^x-ratelimit-/;\n                    UserApi::logInfo(\"updated ratelimit for user %s (id %s): %y\", userinfo.info.username,\n                        userinfo.info.id, userinfo.ratelimit);\n                }\n                return res;\n            } catch (hash<ExceptionInfo> ex) {\n                # handle rate limit errors immediately\n                if (info.\"response-headers\".status_code == 429\n                    || (userinfo && info.\"response-headers\".\"x-ratelimit-remaining\")) {\n                    if (!userinfo) {\n                        userinfo = <UserInfo>{};\n                    }\n                    userinfo.ratelimit = map {$1.key: $1.value}, info.\"response-headers\".pairIterator(),\n                        $1.key =~ /^x-ratelimit-/;\n                    if (info.\"response-headers\".status_code == 429) {\n                        UserApi::logInfo(\"retying after ratelimit error: %s: %s\", ex.err, ex.desc,\n                            userinfo.ratelimit);\n                        continue;\n                    } else {\n                        UserApi::logInfo(\"updated ratelimit for user %s (id %s): %y\", userinfo.info.username,\n                            userinfo.info.id, userinfo.ratelimit);\n                    }\n                }\n                if (DiscordWebSocketApiDataEventSource::retry(ex, \\retries)) {\n                    continue;\n                }\n                UserApi::logError(\"%s\", get_exception_string(ex));\n                rethrow;\n            }\n        }\n    }\n\n    private static bool retry(hash<ExceptionInfo> ex, reference<int> retries) {\n        if (RetrySet{ex.err}) {\n            if (++retries == MaxIoRetries) {\n                UserApi::logError(\"maximum retries exceeded (%d)\", retries);\n                return False;\n            }\n            UserApi::logWarn(\"technical error making REST call: %s: %s; retrying\", ex.err, ex.desc);\n            return True;\n        }\n        return False;\n    }\n}\n\n# Cached user information\nhashdecl UserInfo {\n    # Discord REST client\n    DiscordRestClient rest;\n\n    # user info hash\n    hash<auto> info;\n\n    # guild name -> guild ID\n    hash<string, string> guilds_by_name;\n\n    # guild ID -> guild name\n    hash<string, string> guilds_by_id;\n\n    # ratelimit information\n    hash<auto> ratelimit;\n}\n\n# Connection information\nhashdecl ConnInfo {\n    # user ID: key to usermap -> UserInfo\n    string userid;\n\n    # map of channels watched by this connection: guild -> channel -> True\n    hash<string, hash<string, bool>> channels;\n\n    # map of guilds watched by this connection: guild -> True\n    hash<string, bool> guilds;\n\n    # are DMs watched?\n    bool dm;\n}\n\nclass WebSocketApiObserver inherits DataProvider::Observer {\n    private {\n        DiscordWebSocketApiDataEventSource service;\n\n        hash<auto> cmdmap;\n\n        #! Args for the REST client\n        const RestKeys = map {$1: True}, keys DiscordRestConnection::ConnectionScheme.options;\n    }\n\n    constructor(DiscordWebSocketApiDataEventSource service) {\n        self.service := service;\n\n        cmdmap = {\n            \"GUILD-CHANNELS\": \\guildChannels(),\n            \"INFO\": \\info(),\n            \"REGISTER\": \\register(),\n            \"WATCH\": \\watch(),\n            \"GET-EXAMPLE-MESSAGE\": \\getExampleMessage(),\n            \"SEND\": \\send(),\n            \"STOP\": \\stop(),\n        };\n    }\n\n    update(string event_id, hash<auto> data_) {\n        UserApi::logDebug(\"ws event id: %y data: %y\", event_id, data_);\n        softstring conn = data_.cx.id;\n        if (event_id == BBM_WebSocketServiceDataEventSourceConnection::ConnectionClosedId) {\n            service.unsubscribeAll(conn);\n            return;\n        }\n        if (event_id == BBM_WebSocketServiceDataEventSourceConnection::ConnectionEventId) {\n            handleEvent(conn, data_);\n        }\n    }\n\n    private handleEvent(string conn, hash<auto> data_) {\n        if (data_.msg.typeCode() != NT_HASH) {\n            error(data_, \"missing or invalid API data; got type %y; expecting \\\"hash\\\" with a \\\"cmd\\\" key\",\n                data_.msg.fullType());\n            return;\n        }\n        if (data_.msg.cmd.typeCode() != NT_STRING) {\n            error(data_, \"missing or invalid cmd (got type %y; expecting \\\"string\\\")\", data_.msg.cmd.fullType());\n            return;\n        }\n        *code action = cmdmap{data_.msg.cmd};\n        if (!action) {\n            error(data_, \"invalid cmd %y; expecting one of: %y\", data_.msg.cmd, keys cmdmap);\n            return;\n        }\n        try {\n            action(conn, data_);\n        } catch (hash<ExceptionInfo> ex) {\n            error(data_, ex, \"error executing API %y\", data_.msg.cmd);\n        }\n    }\n\n    private register(string conn, hash<auto> data_) {\n        hash<auto> args = checkArgs(data_.msg);\n        hash<auto> info;\n        try {\n            hash<ConnInfo> conninfo = registerConnection(conn, args, \\info);\n            hash<UserInfo> userinfo = service.usermap{conninfo.userid};\n            string msg = sprintf(\"user %y (id %s) registered with access to guilds: %y\", userinfo.info.username,\n                userinfo.info.id, userinfo.guilds_by_id);\n            UserApi::logInfo(\"connection %y: %s\", conn, msg);\n            sendMessage(\"info\", data_, {\n                \"info\": msg,\n            });\n        } catch (hash<ExceptionInfo> ex) {\n            string err = \"error starting watch\";\n            if (info) {\n                err += sprintf(\": %y returned from %y\", info.\"response-uri\", info.\"request-uri\");\n            }\n            error(data_, ex, \"%s\", err);\n            return;\n        }\n    }\n\n    private *hash<auto> checkGuild(auto conninfo, hash<UserInfo> userinfo, hash<auto> args, *bool required) {\n        hash<auto> guild_info;\n        if (args.guild_id) {\n            guild_info.guild_name = userinfo.guilds_by_id{args.guild_id};\n            if (!guild_info.guild_name.val()) {\n                throw \"GUILD-ERROR\", sprintf(\"user %y (id %s) cannot access guild ID %y; accessible guilds: %y\",\n                    userinfo.info.username, conninfo.userid, args.guild_id, userinfo.guilds_by_id);\n            }\n            guild_info.guild_id = args.guild_id.toString();\n        } else if (args.guild_name) {\n            *string id = userinfo.guilds_by_name{args.guild_name};\n            if (!id) {\n                throw \"GUILD-ERROR\", sprintf(\"user %y (id %s) cannot access guild %y; accessible guilds: %y\",\n                    userinfo.info.username, conninfo.userid, args.guild_name, userinfo.guilds_by_name);\n            }\n            guild_info.guild_name = args.guild_name;\n            guild_info.guild_id = id;\n        }\n        if (!guild_info && required) {\n            throw \"GUILD-ERROR\", sprintf(\"missing guild_id / guild_name in args; got: %y\", args);\n        }\n        return guild_info;\n    }\n\n    private checkChannel(reference<hash<auto>> args, hash<auto> guild_info, auto conninfo, *bool required) {\n        if (args.channel_name) {\n            service.checkGuildInfo(guild_info.guild_id);\n            if (!exists (args.channel_id = service.guild_channel_names{guild_info.guild_id}{args.channel_name})) {\n                throw \"CHANNEL-ERROR\", sprintf(\"guild_id %y has no channel named %y; known channels: %y\",\n                    guild_info.guild_id, args.channel_name,\n                    keys service.guild_channel_names{guild_info.guild_id});\n            }\n        } else if (args.channel_id) {\n            service.checkGuildInfo(guild_info.guild_id);\n            args.channel_name = service.guild_channel_ids{guild_info.guild_id}{args.channel_id};\n            if (!exists args.channel_name) {\n                throw \"CHANNEL-ERROR\", sprintf(\"guild_id %y has no channel with ID %y; known channels: %y\",\n                    guild_info.guild_id, args.channel_id, service.guild_channel_ids{guild_info.guild_id});\n            }\n        }\n        if (required && !args.channel_id && !args.channel_name) {\n            throw \"CHANNEL-ERROR\", sprintf(\"missing channel_id / channel_name in args; got: %y\", args);\n        }\n    }\n\n    # returns an example message on the given channel\n    private getExampleMessage(string conn, hash<auto> data_) {\n        hash<auto> args = checkArgs(data_.msg);\n\n        auto conninfo = getConnection(conn, args);\n        hash<UserInfo> userinfo = service.usermap{conninfo.userid};\n\n        # verify that the guild is accessible\n        hash<auto> guild_info = checkGuild(conninfo, userinfo, args, True);\n        checkChannel(\\args, guild_info, conninfo, True);\n\n        # must use the bot token\n        DiscordRestClient rest = getDiscordClient({\n            \"token\": UserApi::getConfigItemValue(\"discord-bot-token\"),\n            \"token_type\": \"Bot\",\n            \"oauth2_grant_type\": NOTHING,\n        });\n\n        # get user info\n        hash<auto> info;\n        hash<auto> msg = DiscordWebSocketApiDataEventSource::doRestCommand(NOTHING, rest, \"GET\", \"channels/\"\n            + args.channel_id + \"/messages?limit=1\", NOTHING, \\info).body[0];\n\n        UserApi::logInfo(\"connection %y: %s\", conn, msg);\n        sendMessage(\"info\", data_, {\n            \"info\": msg,\n        });\n    }\n\n    private watch(string conn, hash<auto> data_) {\n        hash<auto> args = checkArgs(data_.msg);\n\n        auto conninfo = getConnection(conn, args);\n        hash<UserInfo> userinfo = service.usermap{conninfo.userid};\n\n        # verify that the guild is accessible\n        hash<auto> guild_info = checkGuild(conninfo, userinfo, args, True);\n        checkChannel(\\args, guild_info, conninfo);\n\n        string msg = sprintf(\"user %y (id %s) \", userinfo.info.username, conninfo.userid);\n\n        if (args.channel_id) {\n            if (service.channelmap{guild_info.guild_id}{args.channel_id}{conn}) {\n                msg += sprintf(\"already watching messages in guild %y (id %s) channel %s\", guild_info.guild_name,\n                    guild_info.guild_id, args.channel_id);\n            } else {\n                service.channelmap{guild_info.guild_id}{args.channel_id}{conn} = True;\n                conninfo.channels{guild_info.guild_id}{args.channel_id} = True;\n                msg += sprintf(\"watching messages in guild %y (id %s) channel %y (id %s)\", guild_info.guild_name,\n                    guild_info.guild_id, args.channel_name, args.channel_id);\n            }\n        } else {\n            if (service.guildmap{guild_info.guild_id}{conn}) {\n                msg += sprintf(\"already watching all messages in guild %y (id %s)\", guild_info.guild_name,\n                    guild_info.guild_id);\n            } else {\n                service.guildmap{guild_info.guild_id}{conn} = True;\n                conninfo.guilds{guild_info.guild_id} = True;\n                msg += sprintf(\"watching all messages in guild %y (id %s)\", guild_info.guild_name,\n                    guild_info.guild_id);\n            }\n        }\n\n        UserApi::logInfo(\"connection %y: %s\", conn, msg);\n        sendMessage(\"info\", data_, {\n            \"info\": msg,\n        });\n    }\n\n    # Gets user info and info on accessible guilds\n    private reference<hash<ConnInfo>> getConnection(string conn, hash<auto> args) {\n        if (!service.connmap{conn}) {\n            throw \"REGISTER-ERROR\", sprintf(\"connection %y is not yet registered; call REGISTER first\", conn);\n        }\n        return \\service.connmap{conn};\n    }\n\n    # Gets user info and info on accessible guilds\n    private hash<ConnInfo> registerConnection(string conn, hash<auto> args, reference<hash<auto>> info) {\n        if (service.connmap{conn}) {\n            throw \"REGISTER-ERROR\", sprintf(\"connection %y is already registered\", conn);\n        }\n\n        # cache user info if necessary\n        DiscordRestClient rest = getDiscordClient(args);\n\n        # get user info\n        hash<auto> res = DiscordWebSocketApiDataEventSource::doRestCommand(NOTHING, rest, \"GET\", \"users/@me\",\n            NOTHING, \\info);\n\n        # clear info in case a non-REST-related error is subsequently raised\n        remove info;\n\n        hash<UserInfo> userinfo = service.cacheUserInfo(rest, res, \\info);\n        hash<ConnInfo> conninfo = <ConnInfo>{\n            \"userid\": userinfo.info.id,\n        };\n        return service.connmap{conn} = conninfo;\n    }\n\n    static DiscordRestClient getDiscordClient(hash<auto> args) {\n        return new DiscordRestClient(args{keys RestKeys} + {\"logger\": DiscordBot::logger});\n    }\n\n    private hash<auto> checkArgs(hash<auto> msg) {\n        if (msg.args.typeCode() != NT_HASH) {\n            throw \"WATCH-ERROR\", sprintf(\"missing or invalid \\\"args\\\" in message; got type %y but expecting \\\"hash\\\" \"\n                \"(value: %y)\", msg.args.fullType(), msg.args);\n        }\n        return msg.args;\n    }\n\n    private checkKeys(hash<auto> args, list<string> arg_keys) {\n        foreach string key in (arg_keys) {\n            if (args{key}.typeCode() != NT_STRING) {\n                throw \"WATCH-ERROR\", sprintf(\"missing required argument %y in the \\\"args\\\" hash (args: %y)\", key,\n                    args);\n            }\n        }\n    }\n\n    private stop(string conn, hash<auto> data_) {\n        hash<auto> args = checkArgs(data_.msg);\n\n        auto conninfo = getConnection(conn, args);\n        hash<UserInfo> userinfo = service.usermap{conninfo.userid};\n\n        string msg = sprintf(\"user %y (id %s) \", userinfo.info.username, conninfo.userid);\n        if (!service.connmap{conn}) {\n            msg += \"has no active connections\";\n        } else {\n            string guild_id;\n            string guild_name;\n            if (args.guild_id) {\n                guild_name = userinfo.guilds_by_id{args.guild_id};\n                if (!guild_name.val()) {\n                    throw \"STOP-ERROR\", sprintf(\"user %y (id %s) cannot access guild ID %y; accessible guilds: %y\",\n                        userinfo.info.username, conninfo.userid, args.guild_id, userinfo.guilds_by_id);\n                }\n                guild_id = args.guild_id;\n            } else if (args.guild_name) {\n                *string id = userinfo.guilds_by_name{args.guild_name};\n                if (!id) {\n                    throw \"STOP-ERROR\", sprintf(\"user %y (id %s) cannot access guild %y; accessible guilds: %y\",\n                        userinfo.info.username, conninfo.userid, args.guild_name, userinfo.guilds_by_name);\n                }\n                guild_name = args.guild_name;\n                guild_id = id;\n            }\n\n            if (guild_id) {\n                if (args.channel_name) {\n                    service.checkGuildInfo(guild_id);\n                    if (!exists (args.channel_id = service.guild_channel_names{guild_id}{args.channel_name})) {\n                        throw \"WATCH-ERROR\", sprintf(\"guild_id %y has no channel named %y; known channels: %y\", guild_id,\n                            args.channel_name, keys service.guild_channel_names{guild_id});\n                    }\n                }\n\n                if (args.channel_id) {\n                    if (!service.channelmap{guild_id}{args.channel_id}{conn}) {\n                        msg += sprintf(\"not watching messages in guild %y (id %s) channel %s\", guild_name, guild_id,\n                            args.channel_id);\n                    } else {\n                        service.stopChannel(guild_id, args.channel_id, conn);\n                        remove conninfo.channels{guild_id}{args.channel_id};\n                        msg += sprintf(\"stopped watching messages in guild %y (id %s) channel %s\", guild_name, guild_id,\n                            args.channel_id);\n                    }\n                } else {\n                    if (!service.guildmap{guild_id}{conn}) {\n                        msg += sprintf(\"not watching all messages in guild %y (id %s)\", guild_name, guild_id);\n                    } else {\n                        service.stopGuild(guild_id, conn);\n                        remove conninfo.guilds{guild_id};\n                        msg += sprintf(\"watching all messages in guild %y (id %s)\", guild_name, guild_id);\n                    }\n                }\n            } else {\n                if (!service.dmmap{conninfo.userid}{conn}) {\n                    msg += \"not watching direct message to user\";\n                } else {\n                    service.stopDm(conninfo.userid, conn);\n                    remove conninfo.dm;\n                    msg += \"stopped watching direct message to user\";\n                }\n            }\n        }\n\n        UserApi::logInfo(\"connection %y: %s\", conn, msg);\n        sendMessage(\"info\", data_, {\n            \"info\": msg,\n        });\n    }\n\n    private info(string conn, hash<auto> data_) {\n        hash<auto> info;\n        if (*hash<ConnInfo> ci = service.connmap{conn}) {\n            *hash<UserInfo> ui = service.usermap{ci.userid};\n            info = {\n                \"status\": \"OK\",\n            } + ci + {\n                \"guilds\": ui.guilds_by_name,\n            };\n        } else {\n            info = {\n                \"status\": \"not registered\",\n            };\n        }\n        sendMessage(\"info\", data_, info);\n    }\n\n    private guildChannels(string conn, hash<auto> data_) {\n        hash<auto> args = checkArgs(data_.msg);\n        if (!args.guild_id) {\n            throw \"GUILD-CHANNELS-ERROR\", sprintf(\"missing required argument \\\"guild_id\\\" in the \\\"args\\\" hash: %y\",\n                args);\n        }\n        hash<ConnInfo> ci = service.connmap{conn};\n        hash<UserInfo> ui = service.usermap{ci.userid};\n        if (!ui.guilds_by_id) {\n            throw \"GUILD-CHANNELS-ERROR\", sprintf(\"guild %y is not accessible to user %y (id %y)\", args.guild_id,\n                ui.info.username, ui.info.id);\n        }\n\n        service.checkGuildInfo(args.guild_id);\n        sendMessage(\"channels\", data_, {\n            \"channels\": service.guild_channel_names{args.guild_id},\n        });\n    }\n\n    private send(string conn, hash<auto> data_) {\n        hash<auto> args = checkArgs(data_.msg);\n        if (!args.guild_id) {\n            throw \"GUILD-CHANNELS-ERROR\", sprintf(\"missing required argument \\\"guild_id\\\" in the \\\"args\\\" hash: %y\",\n                args);\n        }\n        if (!args.channel_id) {\n            throw \"GUILD-CHANNELS-ERROR\", sprintf(\"missing required argument \\\"channel_id\\\" in the \\\"args\\\" hash: %y\",\n                args);\n        }\n        if (!args.\"data\") {\n            throw \"GUILD-CHANNELS-ERROR\", sprintf(\"missing required argument \\\"data\\\" in the \\\"args\\\" hash: %y\",\n                args);\n        }\n        hash<ConnInfo> ci = service.connmap{conn};\n        hash<UserInfo> ui = service.usermap{ci.userid};\n        if (!ui.guilds_by_id{args.guild_id}) {\n            throw \"GUILD-CHANNELS-ERROR\", sprintf(\"guild %y is not accessible to user %y (id %y)\", args.guild_id,\n                ui.info.username, ui.info.id);\n        }\n        if (!service.guild_channel_ids{args.guild_id}{args.channel_id}) {\n            throw \"GUILD-CHANNELS-ERROR\", sprintf(\"channel %y does not exist in guild %y\", args. channel_id,\n                args.guild_id);\n        }\n\n        hash<auto> info;\n        hash<auto> res;\n        try {\n            res = DiscordWebSocketApiDataEventSource::doRestCommand(NOTHING, DiscordBot::rest, \"POST\",\n                \"channels/\" + args.channel_id + \"/messages\", args.\"data\", \\info);\n\n            # clear info in case a non-REST-related error is subsequently raised\n            remove info;\n        } catch (hash<ExceptionInfo> ex) {\n            string err = sprintf(\"error send message on channel %y\", args.channel_id);\n            if (info) {\n                err += sprintf(\": %y returned from %y\", info.\"response-uri\", info.\"request-uri\");\n                if (res) {\n                    err += sprintf(\", response body: %y\", res.body);\n                }\n            }\n            UserApi::logError(\"%s\", err);\n            sendMessage(\"error\", data_, {\n                \"error\": err,\n            });\n            return;\n        }\n\n        UserApi::logInfo(\"sent message on channel %y: %y\", args.channel_id, args.\"data\");\n\n        sendMessage(\"info\", data_, {\n            \"info\": DiscordWebSocketClient::convertData(res.body),\n        });\n    }\n\n    private error(hash<auto> data_, hash<ExceptionInfo> ex, string fmt, ...) {\n        string err = vsprintf(fmt, argv);\n        # log full error message with backtrace in log\n        UserApi::logError(\"connection \\\"%s\\\" from %y: %s: %s\", data_.cx.id, data_.cx.\"peer-info\".hostname_desc, err,\n            get_exception_string(ex));\n        # return summarized error info on the WebSocket channel\n        err += sprintf(\": %s: %s\", ex.err, ex.desc);\n        sendMessage(\"error\", data_, {\n            \"error\": err,\n        });\n    }\n\n    private error(hash<auto> data_, string fmt, ...) {\n        string err = vsprintf(fmt, argv);\n        UserApi::logError(\"connection \\\"%s\\\" from %y: %s\", data_.cx.id, data_.cx.\"peer-info\".hostname_desc, err);\n        sendMessage(\"error\", data_, {\n            \"error\": err,\n        });\n    }\n\n    private sendMessage(string type, hash<auto> data_, hash<auto> msg) {\n        string reqid = data_.msg.id ?? \"n/a\";\n        service.sendMessage(<WebSocketSendEventInfo>{\n            \"cid\": data_.cx.id,\n            \"msg\": {\n                \"reqid\": reqid,\n                \"type\": type,\n            } + msg,\n        });\n    }\n}\n\npublic class QorusAppender inherits LoggerAppender {\n    constructor() : LoggerAppender(\"qorus\") {\n        open();\n    }\n\n    processEventImpl(int type, auto params) {\n        switch (type) {\n            case EVENT_LOG:\n                UserApi::logWithLevelArgs(params.level, \"%s\", params.msg);\n                break;\n        }\n    }\n\n    private auto serializeImpl(LoggerEvent event) {\n        return {\n            \"level\": event.getLevel().getValue(),\n            \"msg\": event.getMessage(),\n        };\n    }\n}\n",
          "base-class-name": "QorusService",
          "class-name": "DiscordBot",
          "servicetype": "USER",
          "name": "discord-bot",
          "display_name": "Discord Bot",
          "short_desc": "Discord bot for Qorus Discord Access",
          "version": "1.0",
          "autostart": true,
          "remote": true,
          "methods": [
            {
              "name": "init",
              "author": "Qore Technologies, s.r.o."
            },
            {
              "name": "info",
              "author": "Qore Technologies, s.r.o."
            },
            {
              "name": "setLogLevel",
              "author": "Qore Technologies, s.r.o."
            },
            {
              "name": "reconnect",
              "author": "Qore Technologies, s.r.o."
            }
          ],
          "groups": ["QORUS-API"],
          "author": ["Qore Technologies, s.r.o."],
          "classes": [
            {
              "id": 1,
              "name": "BBM_HttpServiceGenericBase"
            },
            {
              "id": 2,
              "name": "BBM_HttpAuthenticatorBase"
            },
            {
              "id": 3,
              "name": "BBM_CorsBase"
            },
            {
              "id": 4,
              "name": "BBM_WebSocketServiceBase"
            },
            {
              "id": 5,
              "name": "BBM_WebSocketServiceDataEventSource"
            }
          ],
          "config-items": [
            {
              "name": "discord-bot-token",
              "description": "The token for the Discord bot",
              "config_group": "Discord Bot Config",
              "type": "string",
              "sensitive": true,
              "value": "MTE2MTI4MDE3NDIyMjk5OTY2NA.Gss-x0.C6-RNKU5vkkoxIgWcw6ljJ7Wuv-PUo4-k3Ch9M"
            },
            {
              "name": "http-listener-bind-address",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-cert-location",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-cert-format",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-key-location",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-key-format",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-key-password",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-ssl-mode",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-accept-all-certs",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-capture-client-certs",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-allow-sharing",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "websockets-root-uri",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              },
              "value": "apps/ws/discord"
            },
            {
              "name": "websockets-auth-name",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              },
              "value": "permissive"
            },
            {
              "name": "websockets-cors-enable",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "websockets-cors-methods",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "websockets-cors-max-age",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "websockets-cors-headers",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "websockets-cors-credentials",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "websockets-auth-cookie",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "websockets-auth-redirect",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              }
            },
            {
              "name": "websockets-event-data",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_WebSocketServiceDataEventSource",
                "interface-version": "1.0"
              },
              "value": "yaml"
            }
          ]
        },
        "supports_enable": true,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got service 215"
    },
    {
      "request_id": "M783VDGw2IFdc8q",
      "tab_token": "none",
      "data": {
        "iface_kind": "service",
        "service": {
          "id": 11,
          "type": "service",
          "desc": "## Demo REST API Service\n\nThis is a demo REST API service for creating a billing account\n\nIt uses a Swagger schema available at `resource://telco-billing-rest-api:billing-demo-1.0.yaml` and requires no authentication.\n\nOn Kubernetes it can be deployed as a microservice by setting `stateless = true`",
          "lang": "qore",
          "source": "# -*- mode: qore; indent-tabs-mode: nil -*-\n\n# import the Swagger module for Swagger 2.0 REST schema validation\n%requires Swagger\n\n%new-style\n%require-types\n%strict-args\n%enable-all-warnings\n\n# REST API hash<auto> \"response_200\"\nhashdecl response_200 {\n    int Id;\n}\n\n# REST API hash<auto> \"Account\"\nhashdecl Account {\n    int Id;\n    string Name;\n    string Type;\n    string TaxId;\n    string RequestId;\n    hash<PaymentInfo> PaymentInfo;\n    string BillCycle;\n}\n\n# REST API hash<auto> \"PaymentInfo\"\nhashdecl PaymentInfo {\n    string Type;\n    string Id;\n    string Expiration;\n    string CVV2;\n    string Name;\n    string Address;\n}\n\n# REST class for URI path /accounts/{accountId}: methods: GET, PUT, DELETE\nclass AccountsAccountIdRestClass inherits AbstractRestClass {\n    private {\n        string arg;\n    }\n\n    constructor(string arg) {\n        self.arg = arg;\n    }\n\n    string name() {\n        return arg;\n    }\n\n    # GET /accounts/{accountId}\n    hash<auto> get(hash<auto> cx, *hash<auto> ah) {\n        # NOTE: insert custom method code here\n        hash<Account> body({\n            \"Id\": arg.toInt(),\n            \"Name\": \"value\",\n            \"Type\": \"value\",\n            \"TaxId\": \"value\",\n            \"RequestId\": \"value\",\n            \"PaymentInfo\": new hash<PaymentInfo>({\n                \"Type\": \"value\",\n                \"Id\": \"value\",\n                \"Expiration\": \"value\",\n                \"CVV2\": \"value\",\n                \"Name\": \"value\",\n                \"Address\": \"value\",\n            }),\n            \"BillCycle\": \"value\",\n        });\n        return RestHandler::makeResponse(200, body);\n    }\n\n    # PUT /accounts/{accountId}\n    hash<auto> put(hash<auto> cx, *hash<auto> ah) {\n        # NOTE: insert custom method code here\n        return RestHandler::makeResponse(200);\n    }\n\n    # DELETE /accounts/{accountId}\n    hash<auto> delete(hash<auto> cx, *hash<auto> ah) {\n        # NOTE: insert custom method code here\n        return RestHandler::makeResponse(200);\n    }\n}\n\n# REST class for URI path /accounts: methods: POST\nclass AccountsRestClass inherits AbstractRestClass {\n    string name() {\n        return \"accounts\";\n    }\n\n    *AbstractRestClass subClass(string arg, hash<auto> cx, *hash<auto> ah) {\n        # FIXME: implement appropriate wildcard matching logic here for arg =~ /{accountId}/\n        return new AccountsAccountIdRestClass(arg);\n    }\n\n    # GET /accounts\n    hash<auto> get(hash<auto> cx, *hash<auto> ah) {\n        if (ServiceApi::getConfigItemValue(\"set-error\")) {\n            UserApi::logInfo(\"returning an error due to the \\\"set-error\\\" flag\");\n            return RestHandler::makeResponse(404, sprintf(\"RequestId %y not found\", ah.RequestId));\n        }\n        # NOTE: insert custom method code here\n        hash<Account> body({\n            \"Id\": rand() % 10000000,\n            \"Name\": \"value\",\n            \"Type\": \"value\",\n            \"TaxId\": \"value\",\n            \"RequestId\": string(ah.RequestId),\n            \"PaymentInfo\": new hash<PaymentInfo>({\n                \"Type\": \"value\",\n                \"Id\": \"value\",\n                \"Expiration\": \"value\",\n                \"CVV2\": \"value\",\n                \"Name\": \"value\",\n                \"Address\": \"value\",\n            }),\n            \"BillCycle\": \"value\",\n        });\n        return RestHandler::makeResponse(200, body);\n    }\n\n    # POST /accounts\n    hash<auto> post(hash<auto> cx, *hash<auto> ah) {\n        if (ServiceApi::getConfigItemValue(\"set-error\")) {\n            UserApi::logInfo(\"returning an error due to the \\\"set-error\\\" flag\");\n            return RestHandler::makeResponse(500, \"temporary system error\");\n        }\n        # NOTE: insert custom method code here\n        hash<response_200> body({\n            \"Id\": rand() % 10000000,\n        });\n        ServiceApi::logInfo(\"req: %y resp: %y\", ah, body);\n        return RestHandler::makeResponse(200, body);\n    }\n}\n\nclass BillingAPIDemoRestHandler inherits BBM_RestHandlerBase {\n    constructor() : BBM_RestHandlerBase() {\n        addClass(new AccountsRestClass());\n    }\n\n    # remove the path prefix from requests before matching\n    removeRootPath(reference<string> path) {\n        path =~ s/^\\/*billing-demo//;\n    }\n}\n\nclass TelcoBillingRestApi inherits BBM_RestServiceBase {\n    private AbstractServiceHttpHandler getHandlerImpl() {\n        return new BillingAPIDemoRestHandler();\n    }\n\n    # name: activateCustomer\n    # desc: create demo activate customer order\n    int activateCustomer() {\n        hash<auto> order = {\n            \"staticdata\": {\n                \"pos-code\": 1238593,\n                \"customer\": {\n                    \"data\": \"@party-1\",\n                    \"customer-category\": \"SOHO\",\n                    \"accounts\": {\n                        \"type\": \"BUSINESS\",\n                        \"payment-info\": \"@payment-1\",\n                        \"account-password\": \"@party-1\",\n                        \"account-pin\": \"@party-1\",\n                        \"payment-terms\": \"NET30\",\n                        \"bill-cycle\": \"BUSINESS-30-15\",\n                        \"services\": {\n                            \"type\": \"MOBILE-CONVERGENT\",\n                            \"tariff\": \"Premium Business+\",\n                            \"options\": (\n                                \"DATA+\",\n                                \"SMS+\",\n                                \"MMS+\",\n                                \"VPN\",\n                            ),\n                            \"network-profile\": \"FAST\",\n                            \"roaming-profile\": \"STD-INTL0\",\n                            \"msisdn\": \"@msisdn-1\",\n                            \"iccid\": \"@iccid-1\",\n                            \"activation-date\": 2019-04-01T11:28:43,\n                            \"service-level\": \"BUSINESS-STANDARD+\",\n                        },\n                    },\n                },\n            },\n            \"sensitive_data\": {\n                \"tax-number\": {\n                    \"A793873.234\": {\n                        \"data\": {\n                            \"business_name\": NOTHING,\n                            \"given_names\": \"John\",\n                            \"family_name\": \"Customer\",\n                            \"street_address\": \"10 Orange Street\",\n                            \"city\": \"London\",\n                            \"postal_code\": \"WC2N 5DU\",\n                            \"country\": \"UK\",\n                            \"email\": \"john@customer.com\",\n                            \"home-tel\": \"0149391234\",\n                            \"contact-preference\": \"email\",\n                            \"party-password\": \"example-password\",\n                            \"party-pin\": \"0123\",\n                            \"credit-checked\": True,\n                            \"credit-score\": 850,\n                        },\n                        \"aliases\": \"party-1\",\n                    },\n                },\n                \"credit-card-info\": {\n                    \"1234-5678-9999-9999\": {\n                        \"data\": {\n                            \"type\": \"credit-card\",\n                            \"card-type\": \"VISA\",\n                            \"card-expiration-date\": \"12-25\",\n                            \"CVV2\": \"000\",\n                            \"name\": \"John Customer\",\n                            \"billing-address\": \"10 Orange Street, London WC2N 5DU\",\n                            \"contact-tel\": \"0149391234\",\n                            \"contact-email\": \"john@customer.com\",\n                        },\n                        \"aliases\": \"payment-1\",\n                    },\n                },\n                \"msisdn\": {\n                    \"9012345677\": {\n                        \"data\": {\n                            \"type\": \"STD\",\n                            \"provisioning-status\": \"PREPROVISIONED\",\n                        },\n                        \"aliases\": \"msisdn-1\",\n                    },\n                },\n                \"iccid\": {\n                    \"131432423404094\": {\n                        \"data\": {\n                            \"type\": \"STD\",\n                            \"provisioning-status\": \"PREPROVISIONED\",\n                        },\n                        \"aliases\": \"iccid-1\",\n                    },\n                },\n            },\n        };\n        return createOrder(\"TELCO-ACTIVATE-CUSTOMER\", NOTHING, order);\n    }\n}\n",
          "base-class-name": "BBM_RestServiceBase",
          "class-name": "TelcoBillingRestApi",
          "servicetype": "USER",
          "name": "telco-billing-rest-api",
          "display_name": "Telco Billing Rest Api",
          "short_desc": "## Demo REST API Service",
          "version": "1.0",
          "autostart": true,
          "remote": false,
          "methods": [
            {
              "name": "init",
              "author": "Qore Technologies, s.r.o."
            },
            {
              "name": "activateCustomer",
              "author": "Qore Technologies, s.r.o."
            }
          ],
          "groups": ["demo-telco-om", "demo"],
          "author": ["Qore Technologies, s.r.o."],
          "classes": [
            {
              "id": 1,
              "name": "BBM_HttpServiceGenericBase"
            },
            {
              "id": 2,
              "name": "BBM_HttpAuthenticatorBase"
            },
            {
              "id": 3,
              "name": "BBM_CorsBase"
            },
            {
              "id": 4,
              "name": "BBM_RestServiceBase"
            }
          ],
          "config-items": [
            {
              "name": "http-listener-bind-address",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-cert-location",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-cert-format",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-key-location",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-key-format",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-key-password",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-ssl-mode",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-accept-all-certs",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-capture-client-certs",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-root-uri",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              },
              "value": "/billing-demo"
            },
            {
              "name": "rest-auth-name",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              },
              "value": "permissive"
            },
            {
              "name": "rest-swagger-schema",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              },
              "value": "resource://billing-demo-1.0.yaml"
            },
            {
              "name": "set-error",
              "description": "flag to set errors on POST account requests",
              "config_group": "Demo Configuration",
              "type": "bool",
              "default_value": false
            },
            {
              "name": "rest-cors-enable",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-cors-methods",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-cors-max-age",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-cors-headers",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-cors-credentials",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-remove-leading-path-components",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-auth-cookie",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "rest-auth-redirect",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            },
            {
              "name": "http-listener-allow-sharing",
              "parent": {
                "interface-type": "class",
                "interface-name": "BBM_RestServiceBase",
                "interface-version": "1.0"
              }
            }
          ]
        },
        "supports_enable": true,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got service 11"
    },
    {
      "request_id": "SZlWtDjHcrx3tec",
      "tab_token": "none",
      "data": {
        "iface_kind": "service",
        "service": {
          "id": 726,
          "type": "service",
          "desc": "Value map test",
          "lang": "qore",
          "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass ValueMapTest inherits QorusService {\n    auto lookup(string vmap, string key) {\n        return getValueMap(vmap, key);\n    }\n}\n",
          "base-class-name": "QorusService",
          "class-name": "ValueMapTest",
          "servicetype": "USER",
          "name": "value-map-test",
          "display_name": "Value Map Test",
          "short_desc": "Value map test",
          "version": "1.0",
          "autostart": false,
          "remote": false,
          "methods": [
            {
              "name": "lookup"
            }
          ],
          "groups": ["regression", "test"],
          "author": ["Qore Technologies, s.r.o."],
          "vmaps": [
            "regression1",
            "regression2",
            "regression3",
            "value-map-test-date",
            "value-map-test-int",
            "value-map-test-string"
          ]
        },
        "supports_enable": true,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got service 726"
    },
    {
      "request_id": "lQx1yIjcUmYdnne",
      "tab_token": "none",
      "data": {
        "iface_kind": "service",
        "service": {
          "id": 29,
          "type": "service",
          "desc": "Service HTTP handler thread context test",
          "lang": "qore",
          "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass MyRestHandler inherits AbstractServiceRestHandler {\n    constructor() : AbstractServiceRestHandler(\"issue-3534\", False, new PermissiveAuthenticator()) {\n    }\n\n    hash<HttpHandlerResponseInfo> get(hash<auto> cx, *hash<auto> ah) {\n        return UserApi::getConfigItemValue(\"issue-3534-test\")\n            ? RestHandler::makeResponse(200, \"OK\")\n            : RestHandler::makeResponse(501, \"ERROR\");\n    }\n}\n\nclass Issue3534 inherits QorusService {\n    init() {\n        bindHttp(new MyRestHandler());\n    }\n}\n",
          "base-class-name": "QorusService",
          "class-name": "Issue3534",
          "servicetype": "USER",
          "name": "issue-3534",
          "display_name": "Issue 3534",
          "short_desc": "Service HTTP handler thread context test",
          "version": "1.0",
          "autostart": false,
          "remote": true,
          "methods": [
            {
              "name": "init",
              "author": "Qore Technologies, s.r.o."
            }
          ],
          "groups": ["regression", "test"],
          "author": ["Qore Technologies, s.r.o."],
          "config-items": [
            {
              "name": "issue-3534-test",
              "description": "test",
              "config_group": "Issue 3534 Test",
              "type": "bool",
              "default_value": true,
              "strictly_local": true,
              "default_value_true_type": "bool"
            }
          ],
          "tags": [
            {
              "id": 1,
              "key": "TEST",
              "value": "issue-3534"
            }
          ]
        },
        "supports_enable": true,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got service 29"
    }
  ],
  "sla": [
    {
      "request_id": "1VhA3s9cDPNZy2n",
      "tab_token": "none",
      "data": {
        "iface_kind": "sla",
        "sla": {
          "id": 164,
          "type": "sla",
          "name": "yNqJ3b5PvYZVhWp",
          "display_name": "Y NqJ3b5 PvYZ Vh Wp",
          "short_desc": "test",
          "units": "seconds",
          "desc": "test"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got sla 164"
    },
    {
      "request_id": "mxBAr6YQNPosHMv",
      "tab_token": "none",
      "data": {
        "iface_kind": "sla",
        "sla": {
          "id": 165,
          "type": "sla",
          "name": "tDzHDXDReX3tOaw",
          "display_name": "T DzHDXD ReX3t Oaw",
          "short_desc": "test",
          "units": "seconds",
          "desc": "test"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got sla 165"
    },
    {
      "request_id": "e8SUZ6KNkuwghgj",
      "tab_token": "none",
      "data": {
        "iface_kind": "sla",
        "sla": {
          "id": 284,
          "type": "sla",
          "name": "AVNirs0RY5dtu6Z",
          "display_name": "AV Nirs0RY5dtu6Z",
          "short_desc": "test",
          "units": "seconds",
          "desc": "test"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got sla 284"
    },
    {
      "request_id": "zsViMvh1nK9kz32",
      "tab_token": "none",
      "data": {
        "iface_kind": "sla",
        "sla": {
          "id": 285,
          "type": "sla",
          "name": "uib76TYyYACAczf",
          "display_name": "Uib76T YyYAC Aczf",
          "short_desc": "test",
          "units": "seconds",
          "desc": "test"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got sla 285"
    },
    {
      "request_id": "W8nLsSjfKJ1ZqcK",
      "tab_token": "none",
      "data": {
        "iface_kind": "sla",
        "sla": {
          "id": 255,
          "type": "sla",
          "name": "sla-KS6p13KDxnjOvf7",
          "display_name": "Sla KS6p13K Dxnj Ovf7",
          "short_desc": "test",
          "units": "seconds",
          "desc": "test"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got sla 255"
    }
  ],
  "step": [
    {
      "request_id": "ifTbFwjEMqQnnjo",
      "tab_token": "none",
      "data": {
        "iface_kind": "step",
        "step": {
          "id": 8,
          "type": "step",
          "lang": "qore",
          "source": "%new-style\n%require-types\n%strict-args\n%enable-all-warnings\n\nclass TelcoRegisterCounterFraudAccount inherits Demo {\n}\n",
          "name": "TelcoRegisterCounterFraudAccount",
          "display_name": "Telco Register Counter Fraud Account",
          "short_desc": "registers the account in the CFS",
          "desc": "registers the account in the CFS",
          "version": "1.0",
          "steptype": "NORMAL",
          "arraytype": "NONE",
          "author": ["Qore Technologies, s.r.o."],
          "class-name": "TelcoRegisterCounterFraudAccount",
          "base-class-name": "Demo",
          "classes": [
            {
              "id": 1,
              "name": "Demo"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got step 8"
    },
    {
      "request_id": "S1TKQVeVcFs69qO",
      "tab_token": "none",
      "data": {
        "iface_kind": "step",
        "step": {
          "id": 104,
          "type": "step",
          "lang": "qore",
          "name": "async_dummy_1",
          "display_name": "Async Dummy 1",
          "desc": "async seg dummy test func",
          "version": "1.0",
          "steptype": "NORMAL",
          "arraytype": "SERIES",
          "author": ["Qore Technologies, sro"]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got step 104"
    },
    {
      "request_id": "M36FUI1YDOnv1tt",
      "tab_token": "none",
      "data": {
        "iface_kind": "step",
        "step": {
          "id": 10,
          "type": "step",
          "lang": "qore",
          "source": "%new-style\n%require-types\n%strict-args\n%enable-all-warnings\n\nclass TelcoUpdateCrmAccount inherits Demo {\n}\n",
          "name": "TelcoUpdateCrmAccount",
          "display_name": "Telco Update Crm Account",
          "short_desc": "updates the account status in CRM",
          "desc": "updates the account status in CRM",
          "version": "1.0",
          "steptype": "NORMAL",
          "arraytype": "NONE",
          "author": ["Qore Technologies, s.r.o."],
          "class-name": "TelcoUpdateCrmAccount",
          "base-class-name": "Demo",
          "classes": [
            {
              "id": 1,
              "name": "Demo"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got step 10"
    },
    {
      "request_id": "oFRKYQMjwnYVVEW",
      "tab_token": "none",
      "data": {
        "iface_kind": "step",
        "step": {
          "id": 11,
          "type": "step",
          "lang": "qore",
          "source": "%new-style\n%require-types\n%strict-args\n%enable-all-warnings\n\nclass TelcoUpdateCrmCustomer inherits Demo {\n}\n",
          "name": "TelcoUpdateCrmCustomer",
          "display_name": "Telco Update Crm Customer",
          "short_desc": "update the CRM system on the status of the customer activation action",
          "desc": "update the CRM system on the status of the customer activation action",
          "version": "1.0",
          "steptype": "NORMAL",
          "arraytype": "NONE",
          "author": ["Qore Technologies, s.r.o."],
          "class-name": "TelcoUpdateCrmCustomer",
          "base-class-name": "Demo",
          "classes": [
            {
              "id": 1,
              "name": "Demo"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got step 11"
    },
    {
      "request_id": "GHDPrK6L9DvEtZy",
      "tab_token": "none",
      "data": {
        "iface_kind": "step",
        "step": {
          "id": 70,
          "type": "step",
          "lang": "qore",
          "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass FsmTestStep1 inherits QorusNormalStep {\n    primary() {\n    }\n}\n",
          "name": "FsmTestStep1",
          "display_name": "Fsm Test Step1",
          "short_desc": "FSM step test 1",
          "desc": "FSM step test 1",
          "version": "1.0",
          "steptype": "NORMAL",
          "arraytype": "NONE",
          "author": ["Qore Technologies, s.r.o."],
          "class-name": "FsmTestStep1",
          "base-class-name": "QorusNormalStep",
          "fsm": [
            {
              "name": "fsm-dep-test",
              "triggers": [
                {
                  "method": "primary"
                }
              ]
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got step 70"
    },
    {
      "request_id": "HxuYSWcd8l2sq8n",
      "tab_token": "none",
      "data": {
        "iface_kind": "step",
        "step": {
          "id": 278,
          "type": "step",
          "lang": "qore",
          "source": "%new-style\n%require-types\n%strict-args\n%enable-all-warnings\n\nclass issue3333step2 inherits QorusNormalArrayStep {\n    softlist<auto> array() {\n        return (\"test1\", \"test2\", \"test3\");\n    }\n\n    primary(auto array_arg) {\n        logInfo(\"array_arg: %s\", array_arg);\n    }\n}\n",
          "name": "issue3333step2",
          "display_name": "Issue3333step2",
          "short_desc": "issue3333 array test step",
          "desc": "issue3333 array test step",
          "version": "1.0",
          "steptype": "NORMAL",
          "arraytype": "SERIES",
          "author": ["Qore Technologies, s.r.o."],
          "class-name": "issue3333step2",
          "classes": [
            {
              "id": 1,
              "name": "issue3333class"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got step 278"
    },
    {
      "request_id": "tCKA7KZVwDgC99J",
      "tab_token": "none",
      "data": {
        "iface_kind": "step",
        "step": {
          "id": 220,
          "type": "step",
          "lang": "qore",
          "name": "Issue3010Step",
          "display_name": "Issue3010 Step",
          "version": "1.0",
          "steptype": "NORMAL",
          "arraytype": "NONE"
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got step 220"
    },
    {
      "request_id": "ol5XqaT0IYm6BN6",
      "tab_token": "none",
      "data": {
        "iface_kind": "step",
        "step": {
          "id": 68,
          "type": "step",
          "lang": "java",
          "source": "import com.qoretechnologies.qorus.*;\nimport com.qoretechnologies.qorus.workflow.*;\n\nclass Issue3471Step extends QorusNormalStep {\n    public Issue3471Step() throws Throwable {\n        throw new Exception(\"shouldn't be called when loaded\");\n    }\n\n    public void primary() throws Throwable {\n    }\n}\n",
          "name": "Issue3471Step",
          "display_name": "Issue3471 Step",
          "short_desc": "test step class",
          "desc": "test step class",
          "version": "1.0",
          "steptype": "NORMAL",
          "arraytype": "NONE",
          "author": ["Qore Technologies, s.r.o."],
          "class-name": "Issue3471Step",
          "base-class-name": "QorusNormalStep",
          "config-items": [
            {
              "name": "issue-3471-step-cfg-item-1",
              "description": "test",
              "config_group": "test",
              "type": "*hash",
              "strictly_local": true
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got step 68"
    },
    {
      "request_id": "4WfegDoWw6UiLIo",
      "tab_token": "none",
      "data": {
        "iface_kind": "step",
        "step": {
          "id": 223,
          "type": "step",
          "lang": "qore",
          "name": "Issue3215Step",
          "display_name": "Issue3215 Step",
          "version": "1.0",
          "steptype": "NORMAL",
          "arraytype": "NONE",
          "config-items": [
            {
              "config_group": "Default",
              "type": "hash",
              "default_value": {
                "step_test_1": 1,
                "step_test_2": [1, 2],
                "step_test_3": {
                  "step_sub_test_1": "step_test_value_1"
                }
              },
              "strictly_local": true,
              "default_value_true_type": "hash"
            },
            {
              "config_group": "Default",
              "type": "hash",
              "default_value": {
                "step_test_1": 1,
                "step_test_2": "asd",
                "step_test_3": [1, 2],
                "step_test_4": {
                  "step_sub_test_1": "step_test_value_1"
                }
              },
              "default_value_true_type": "hash"
            },
            {
              "config_group": "testGroup",
              "type": "list",
              "default_value": [
                "step_test_value_1",
                "step_test_value_2",
                "step_test_value_3"
              ],
              "default_value_true_type": "list"
            },
            {
              "config_group": "Default",
              "type": "*date"
            },
            {
              "config_group": "testGroup",
              "type": "*bool"
            },
            {
              "config_group": "Default",
              "type": "float",
              "default_value": 2.2,
              "allowed_values": [2.2, 3.33, 213.1],
              "default_value_true_type": "float"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got step 223"
    },
    {
      "request_id": "X5TfAXewLYBxwhM",
      "tab_token": "none",
      "data": {
        "iface_kind": "step",
        "step": {
          "id": 97,
          "type": "step",
          "lang": "qore",
          "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass Issue39892 inherits QorusNormalStep {\n    primary() {\n    }\n}\n",
          "name": "issue-3989-2",
          "display_name": "Issue 3989 2",
          "short_desc": "config item test",
          "desc": "config item test",
          "version": "1.0",
          "steptype": "NORMAL",
          "arraytype": "NONE",
          "class-name": "Issue39892",
          "base-class-name": "QorusNormalStep",
          "config-items": [
            {
              "name": "config-test",
              "description": "test",
              "config_group": "Group",
              "type": "string",
              "default_value": "a",
              "allowed_values": ["a", "b", "c"],
              "default_value_true_type": "string"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got step 97"
    }
  ],
  "type": [
    {
      "request_id": "5UnyZkNHAqIXbYB",
      "tab_token": "none",
      "data": {
        "iface_kind": "type",
        "type": {
          "id": 11,
          "type": "type",
          "path": "/qoretechnologies/building-blocks/rest-action/request",
          "display_name": "/qoretechnologies/building-blocks/rest-action/request",
          "short_desc": "Qore data type \"hash<auto>\"",
          "desc": "Qore data type \"hash<auto>\"",
          "typeinfo": {
            "base_type": "hash<auto>",
            "name": "hash<auto>",
            "can_manage_fields": true,
            "mandatory": true,
            "typename": "hash",
            "options": null,
            "supported_options": {
              "qore.no_null": {
                "type": "bool",
                "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
              },
              "qore.external_name": {
                "type": "string",
                "desc": "A note giving the external name for the type"
              }
            },
            "types_accepted": ["hash"],
            "types_returned": ["hash"],
            "xname": "HashDataType",
            "fields": {
              "body": {
                "name": "body",
                "desc": "the request body for the REST call",
                "canBeNull": true,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "body",
                "parentPath": false,
                "type": {
                  "base_type": "auto",
                  "name": "auto",
                  "can_manage_fields": false,
                  "mandatory": false,
                  "typename": "auto",
                  "options": null,
                  "supported_options": null,
                  "types_accepted": ["any"],
                  "types_returned": ["any"],
                  "xname": "QoreDataType",
                  "fields": {}
                }
              },
              "hdr": {
                "name": "hdr",
                "desc": "any HTTP headers to add to the request",
                "canBeNull": true,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "hdr",
                "parentPath": false,
                "type": {
                  "base_type": "hash<auto>",
                  "name": "*hash<auto>",
                  "can_manage_fields": false,
                  "mandatory": false,
                  "typename": "hash",
                  "options": null,
                  "supported_options": null,
                  "types_accepted": ["hash", "nothing", "null"],
                  "types_returned": ["hash", "nothing"],
                  "xname": "HashDataType",
                  "fields": {}
                }
              },
              "uri_path": {
                "name": "uri_path",
                "desc": "any string to add to the URI path configured for the REST action building block",
                "canBeNull": true,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "uri_path",
                "parentPath": false,
                "type": {
                  "base_type": "string",
                  "name": "*string",
                  "can_manage_fields": false,
                  "mandatory": false,
                  "typename": "string",
                  "options": null,
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    },
                    "string.encoding": {
                      "type": "string",
                      "desc": "the output encoding when writing to the type"
                    },
                    "string.max_size_chars": {
                      "type": "integer",
                      "desc": "the maximum length of the string in characters"
                    },
                    "string.empty_to_nothing": {
                      "type": "bool",
                      "desc": "if an empty string should be converted to no value"
                    }
                  },
                  "types_accepted": ["string", "nothing", "null"],
                  "types_returned": ["string", "nothing"],
                  "xname": "QoreStringDataTypeBase",
                  "fields": {}
                }
              }
            }
          },
          "locked": false
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got type 11"
    },
    {
      "request_id": "HxHG3j0kUnyga4E",
      "tab_token": "none",
      "data": {
        "iface_kind": "type",
        "type": {
          "id": 14,
          "type": "type",
          "path": "/qoretechnologies/building-blocks/aws/sns/notification",
          "display_name": "/qoretechnologies/building-blocks/aws/sns/notification",
          "short_desc": "Qore data type \"hash<auto>\"",
          "desc": "Qore data type \"hash<auto>\"",
          "typeinfo": {
            "base_type": "hash<auto>",
            "name": "hash<auto>",
            "can_manage_fields": true,
            "mandatory": true,
            "typename": "hash",
            "options": null,
            "supported_options": {
              "qore.no_null": {
                "type": "bool",
                "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
              },
              "qore.external_name": {
                "type": "string",
                "desc": "A note giving the external name for the type"
              }
            },
            "types_accepted": ["hash"],
            "types_returned": ["hash"],
            "xname": "HashDataType",
            "fields": {
              "Type": {
                "name": "Type",
                "desc": "always `Notification`",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "Type",
                "parentPath": false,
                "type": {
                  "base_type": "string",
                  "name": "string",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "string",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    },
                    "string.encoding": {
                      "type": "string",
                      "desc": "the output encoding when writing to the type"
                    },
                    "string.max_size_chars": {
                      "type": "integer",
                      "desc": "the maximum length of the string in characters"
                    }
                  },
                  "types_accepted": ["string"],
                  "types_returned": ["string"],
                  "xname": "QoreStringDataTypeBase",
                  "fields": {}
                }
              },
              "MessageId": {
                "name": "MessageId",
                "desc": "The AWS message ID (ex: `dc1e94d9-56c5-5e96-808d-cc7f68faa162`)",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "MessageId",
                "parentPath": false,
                "type": {
                  "base_type": "string",
                  "name": "string",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "string",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    },
                    "string.encoding": {
                      "type": "string",
                      "desc": "the output encoding when writing to the type"
                    },
                    "string.max_size_chars": {
                      "type": "integer",
                      "desc": "the maximum length of the string in characters"
                    }
                  },
                  "types_accepted": ["string"],
                  "types_returned": ["string"],
                  "xname": "QoreStringDataTypeBase",
                  "fields": {}
                }
              },
              "TopicArn": {
                "name": "TopicArn",
                "desc": "The AWS topic ARN (ex: `arn:aws:sns:us-east-2:111122223333:ExampleTopic1`)",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "TopicArn",
                "parentPath": false,
                "type": {
                  "base_type": "string",
                  "name": "string",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "string",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    },
                    "string.encoding": {
                      "type": "string",
                      "desc": "the output encoding when writing to the type"
                    },
                    "string.max_size_chars": {
                      "type": "integer",
                      "desc": "the maximum length of the string in characters"
                    }
                  },
                  "types_accepted": ["string"],
                  "types_returned": ["string"],
                  "xname": "QoreStringDataTypeBase",
                  "fields": {}
                }
              },
              "Subject": {
                "name": "Subject",
                "desc": "The message subject (ex: `TestSubject`)",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "Subject",
                "parentPath": false,
                "type": {
                  "base_type": "string",
                  "name": "string",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "string",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    },
                    "string.encoding": {
                      "type": "string",
                      "desc": "the output encoding when writing to the type"
                    },
                    "string.max_size_chars": {
                      "type": "integer",
                      "desc": "the maximum length of the string in characters"
                    }
                  },
                  "types_accepted": ["string"],
                  "types_returned": ["string"],
                  "xname": "QoreStringDataTypeBase",
                  "fields": {}
                }
              },
              "Message": {
                "name": "Message",
                "desc": "The message body",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "Message",
                "parentPath": false,
                "type": {
                  "base_type": "string",
                  "name": "string",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "string",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    },
                    "string.encoding": {
                      "type": "string",
                      "desc": "the output encoding when writing to the type"
                    },
                    "string.max_size_chars": {
                      "type": "integer",
                      "desc": "the maximum length of the string in characters"
                    }
                  },
                  "types_accepted": ["string"],
                  "types_returned": ["string"],
                  "xname": "QoreStringDataTypeBase",
                  "fields": {}
                }
              },
              "Timestamp": {
                "name": "Timestamp",
                "desc": "The date/time of the message",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "Timestamp",
                "parentPath": false,
                "type": {
                  "base_type": "date",
                  "name": "date",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "date",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    }
                  },
                  "types_accepted": ["date"],
                  "types_returned": ["date"],
                  "xname": "QoreDataType",
                  "fields": {}
                }
              },
              "SignatureVersion": {
                "name": "SignatureVersion",
                "desc": "The signation version (ex: `1`)",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "SignatureVersion",
                "parentPath": false,
                "type": {
                  "base_type": "string",
                  "name": "string",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "string",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    },
                    "string.encoding": {
                      "type": "string",
                      "desc": "the output encoding when writing to the type"
                    },
                    "string.max_size_chars": {
                      "type": "integer",
                      "desc": "the maximum length of the string in characters"
                    }
                  },
                  "types_accepted": ["string"],
                  "types_returned": ["string"],
                  "xname": "QoreStringDataTypeBase",
                  "fields": {}
                }
              },
              "Signature": {
                "name": "Signature",
                "desc": "The message signature (ex: `FMG5tlZhJNHLHUXvZgtZzlk24FzVa7oX0T4P03neeXw8ZEXZx6z35j2FOTuNYShn2h0bKNC/zLTnMyIxEzmi2X1shOBWsJHkrW2xkR58ABZF+4uWHEE73yDVR4SyYAikP9jstZzDRm+bcVs8+T0yaLiEGLrIIIL4esi1llhIkgErCuy5btPcWXBdio2fpCRD5x9oR6gmE/rd5O7lX1c1uvnv4r1Lkk4pqP2/iUfxFZva1xLSRvgyfm6D9hNklVyPfy+7TalMD0lzmJuOrExtnSIbZew3foxgx8GT+lbZkLd0ZdtdRJlIyPRP44eyq78sU0Eo/LsDr0Iak4ZDpg8dXg==`)",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "Signature",
                "parentPath": false,
                "type": {
                  "base_type": "string",
                  "name": "string",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "string",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    },
                    "string.encoding": {
                      "type": "string",
                      "desc": "the output encoding when writing to the type"
                    },
                    "string.max_size_chars": {
                      "type": "integer",
                      "desc": "the maximum length of the string in characters"
                    }
                  },
                  "types_accepted": ["string"],
                  "types_returned": ["string"],
                  "xname": "QoreStringDataTypeBase",
                  "fields": {}
                }
              },
              "SigningCertURL": {
                "name": "SigningCertURL",
                "desc": "The signing certificate URL (ex: `https://sns.us-east-2.amazonaws.com/SimpleNotificationService-010a507c1833636cd94bdb98bd93083a.pem`)",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "SigningCertURL",
                "parentPath": false,
                "type": {
                  "base_type": "string",
                  "name": "string",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "string",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    },
                    "string.encoding": {
                      "type": "string",
                      "desc": "the output encoding when writing to the type"
                    },
                    "string.max_size_chars": {
                      "type": "integer",
                      "desc": "the maximum length of the string in characters"
                    }
                  },
                  "types_accepted": ["string"],
                  "types_returned": ["string"],
                  "xname": "QoreStringDataTypeBase",
                  "fields": {}
                }
              },
              "UnsubscribeURL": {
                "name": "UnsubscribeURL",
                "desc": "The unsubscribe URL (ex: `https://sns.us-east-2.amazonaws.com/?Action=Unsubscribe&SubscriptionArn=arn:aws:sns:us-east-2:111122223333:ExampleTopic1:e1039402-24e7-40a3-a0d4-797da162b297`)",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "UnsubscribeURL",
                "parentPath": false,
                "type": {
                  "base_type": "string",
                  "name": "string",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "string",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    },
                    "string.encoding": {
                      "type": "string",
                      "desc": "the output encoding when writing to the type"
                    },
                    "string.max_size_chars": {
                      "type": "integer",
                      "desc": "the maximum length of the string in characters"
                    }
                  },
                  "types_accepted": ["string"],
                  "types_returned": ["string"],
                  "xname": "QoreStringDataTypeBase",
                  "fields": {}
                }
              }
            }
          },
          "locked": false
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got type 14"
    },
    {
      "request_id": "o6qoRC59i7KDY6N",
      "tab_token": "none",
      "data": {
        "iface_kind": "type",
        "type": {
          "id": 18,
          "type": "type",
          "path": "/qoretechnologies/building-blocks/mqtt-paho/deliveryComplete",
          "display_name": "/qoretechnologies/building-blocks/mqtt-paho/deliveryComplete",
          "short_desc": "Qore data type \"hash<auto>\"",
          "desc": "Qore data type \"hash<auto>\"",
          "typeinfo": {
            "base_type": "hash<auto>",
            "name": "hash<auto>",
            "can_manage_fields": true,
            "mandatory": true,
            "typename": "hash",
            "options": null,
            "supported_options": {
              "qore.no_null": {
                "type": "bool",
                "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
              },
              "qore.external_name": {
                "type": "string",
                "desc": "A note giving the external name for the type"
              }
            },
            "types_accepted": ["hash"],
            "types_returned": ["hash"],
            "xname": "HashDataType",
            "fields": {
              "topics": {
                "name": "topics",
                "desc": "the topic or topics for the message",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "topics",
                "parentPath": false,
                "type": {
                  "base_type": "list",
                  "name": "list<auto>",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "list",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    }
                  },
                  "types_accepted": ["list"],
                  "types_returned": ["list"],
                  "xname": "QoreDataType",
                  "fields": {}
                }
              },
              "id": {
                "name": "id",
                "desc": "the message ID delivered",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "id",
                "parentPath": false,
                "type": {
                  "base_type": "string",
                  "name": "string",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "string",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    },
                    "string.encoding": {
                      "type": "string",
                      "desc": "the output encoding when writing to the type"
                    },
                    "string.max_size_chars": {
                      "type": "integer",
                      "desc": "the maximum length of the string in characters"
                    }
                  },
                  "types_accepted": ["string"],
                  "types_returned": ["string"],
                  "xname": "QoreStringDataTypeBase",
                  "fields": {}
                }
              },
              "payload": {
                "name": "payload",
                "desc": "the message payload, decoded if configuration specifies it",
                "canBeNull": true,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "payload",
                "parentPath": false,
                "type": {
                  "base_type": "auto",
                  "name": "auto",
                  "can_manage_fields": false,
                  "mandatory": false,
                  "typename": "auto",
                  "options": null,
                  "supported_options": null,
                  "types_accepted": ["any"],
                  "types_returned": ["any"],
                  "xname": "QoreDataType",
                  "fields": {}
                }
              },
              "qos": {
                "name": "qos",
                "desc": "the QoS code for the message",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "qos",
                "parentPath": false,
                "type": {
                  "base_type": "int",
                  "name": "int",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "int",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    }
                  },
                  "types_accepted": ["int", "integer"],
                  "types_returned": ["int", "integer"],
                  "xname": "QoreDataType",
                  "fields": {}
                }
              },
              "duplicate": {
                "name": "duplicate",
                "desc": "if the message is a duplicate",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "duplicate",
                "parentPath": false,
                "type": {
                  "base_type": "bool",
                  "name": "bool",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "bool",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    }
                  },
                  "types_accepted": ["bool"],
                  "types_returned": ["bool"],
                  "xname": "QoreDataType",
                  "fields": {}
                }
              },
              "retained": {
                "name": "retained",
                "desc": "if the message was retained",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "retained",
                "parentPath": false,
                "type": {
                  "base_type": "bool",
                  "name": "bool",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "bool",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    }
                  },
                  "types_accepted": ["bool"],
                  "types_returned": ["bool"],
                  "xname": "QoreDataType",
                  "fields": {}
                }
              }
            }
          },
          "locked": false
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got type 18"
    },
    {
      "request_id": "fVnCriuGGuNNJnM",
      "tab_token": "none",
      "data": {
        "iface_kind": "type",
        "type": {
          "id": 19,
          "type": "type",
          "path": "/qoretechnologies/building-blocks/salesforce/stream-event-account",
          "display_name": "/qoretechnologies/building-blocks/salesforce/stream-event-account",
          "short_desc": "Qore data type \"hash<auto>\"",
          "desc": "Qore data type \"hash<auto>\"",
          "typeinfo": {
            "base_type": "hash<auto>",
            "name": "hash<auto>",
            "can_manage_fields": true,
            "mandatory": true,
            "typename": "hash",
            "options": null,
            "supported_options": {
              "qore.no_null": {
                "type": "bool",
                "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
              },
              "qore.external_name": {
                "type": "string",
                "desc": "A note giving the external name for the type"
              }
            },
            "types_accepted": ["hash"],
            "types_returned": ["hash"],
            "xname": "HashDataType",
            "fields": {
              "event": {
                "name": "event",
                "desc": "event metadata hash",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "event",
                "parentPath": false,
                "type": {
                  "base_type": "hash<auto>",
                  "name": "hash<auto>",
                  "can_manage_fields": true,
                  "mandatory": true,
                  "typename": "hash",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    }
                  },
                  "types_accepted": ["hash"],
                  "types_returned": ["hash"],
                  "xname": "HashDataType",
                  "fields": {
                    "replayId": {
                      "name": "replayId",
                      "desc": "Salesforce event ID",
                      "canBeNull": false,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "replayId",
                      "parentPath": false,
                      "type": {
                        "base_type": "int",
                        "name": "int",
                        "can_manage_fields": false,
                        "mandatory": true,
                        "typename": "int",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          }
                        },
                        "types_accepted": ["int", "integer"],
                        "types_returned": ["int", "integer"],
                        "xname": "QoreDataType",
                        "fields": {}
                      }
                    }
                  }
                }
              },
              "payload": {
                "name": "payload",
                "desc": "the event payload hash; contents depend on the event source",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "payload",
                "parentPath": false,
                "type": {
                  "base_type": "hash<auto>",
                  "name": "hash<auto>",
                  "can_manage_fields": true,
                  "mandatory": true,
                  "typename": "hash",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    }
                  },
                  "types_accepted": ["hash"],
                  "types_returned": ["hash"],
                  "xname": "HashDataType",
                  "fields": {
                    "AccountNumber": {
                      "name": "AccountNumber",
                      "desc": "Account AccountNumber",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "AccountNumber",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "AccountSource": {
                      "name": "AccountSource",
                      "desc": "Account AccountSource",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "AccountSource",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "Active__c": {
                      "name": "Active__c",
                      "desc": "Account Active__c",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "Active__c",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "AnnualRevenue": {
                      "name": "AnnualRevenue",
                      "desc": "Account AnnualRevenue",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "AnnualRevenue",
                      "parentPath": false,
                      "type": {
                        "base_type": "float",
                        "name": "*float",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "float",
                        "options": null,
                        "supported_options": null,
                        "types_accepted": [
                          "float",
                          "int",
                          "integer",
                          "nothing",
                          "null"
                        ],
                        "types_returned": ["float", "nothing"],
                        "xname": "QoreDataType",
                        "fields": {}
                      }
                    },
                    "BillingAddress": {
                      "name": "BillingAddress",
                      "desc": "Account Billing info",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "BillingAddress",
                      "parentPath": false,
                      "type": {
                        "base_type": "hash<auto>",
                        "name": "*hash<auto>",
                        "can_manage_fields": true,
                        "mandatory": false,
                        "typename": "hash",
                        "options": null,
                        "supported_options": null,
                        "types_accepted": ["hash", "nothing", "null"],
                        "types_returned": ["hash", "nothing"],
                        "xname": "HashDataType",
                        "fields": {
                          "City": {
                            "name": "City",
                            "desc": "Account Billing City",
                            "canBeNull": true,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "City",
                            "parentPath": false,
                            "type": {
                              "base_type": "string",
                              "name": "*string",
                              "can_manage_fields": false,
                              "mandatory": false,
                              "typename": "string",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                },
                                "string.encoding": {
                                  "type": "string",
                                  "desc": "the output encoding when writing to the type"
                                },
                                "string.max_size_chars": {
                                  "type": "integer",
                                  "desc": "the maximum length of the string in characters"
                                },
                                "string.empty_to_nothing": {
                                  "type": "bool",
                                  "desc": "if an empty string should be converted to no value"
                                }
                              },
                              "types_accepted": ["string", "nothing", "null"],
                              "types_returned": ["string", "nothing"],
                              "xname": "QoreStringDataTypeBase",
                              "fields": {}
                            }
                          },
                          "Country": {
                            "name": "Country",
                            "desc": "Account Billing Country",
                            "canBeNull": true,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "Country",
                            "parentPath": false,
                            "type": {
                              "base_type": "string",
                              "name": "*string",
                              "can_manage_fields": false,
                              "mandatory": false,
                              "typename": "string",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                },
                                "string.encoding": {
                                  "type": "string",
                                  "desc": "the output encoding when writing to the type"
                                },
                                "string.max_size_chars": {
                                  "type": "integer",
                                  "desc": "the maximum length of the string in characters"
                                },
                                "string.empty_to_nothing": {
                                  "type": "bool",
                                  "desc": "if an empty string should be converted to no value"
                                }
                              },
                              "types_accepted": ["string", "nothing", "null"],
                              "types_returned": ["string", "nothing"],
                              "xname": "QoreStringDataTypeBase",
                              "fields": {}
                            }
                          },
                          "GeocodeAccuracy": {
                            "name": "GeocodeAccuracy",
                            "desc": "Account Billing GeocodeAccuracy",
                            "canBeNull": true,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "GeocodeAccuracy",
                            "parentPath": false,
                            "type": {
                              "base_type": "string",
                              "name": "*string",
                              "can_manage_fields": false,
                              "mandatory": false,
                              "typename": "string",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                },
                                "string.encoding": {
                                  "type": "string",
                                  "desc": "the output encoding when writing to the type"
                                },
                                "string.max_size_chars": {
                                  "type": "integer",
                                  "desc": "the maximum length of the string in characters"
                                },
                                "string.empty_to_nothing": {
                                  "type": "bool",
                                  "desc": "if an empty string should be converted to no value"
                                }
                              },
                              "types_accepted": ["string", "nothing", "null"],
                              "types_returned": ["string", "nothing"],
                              "xname": "QoreStringDataTypeBase",
                              "fields": {}
                            }
                          },
                          "Latitude": {
                            "name": "Latitude",
                            "desc": "Account Billing Latitude",
                            "canBeNull": true,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "Latitude",
                            "parentPath": false,
                            "type": {
                              "base_type": "float",
                              "name": "*float",
                              "can_manage_fields": false,
                              "mandatory": false,
                              "typename": "float",
                              "options": null,
                              "supported_options": null,
                              "types_accepted": [
                                "float",
                                "int",
                                "integer",
                                "nothing",
                                "null"
                              ],
                              "types_returned": ["float", "nothing"],
                              "xname": "QoreDataType",
                              "fields": {}
                            }
                          },
                          "Longitude": {
                            "name": "Longitude",
                            "desc": "Account Billing Longitude",
                            "canBeNull": true,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "Longitude",
                            "parentPath": false,
                            "type": {
                              "base_type": "float",
                              "name": "*float",
                              "can_manage_fields": false,
                              "mandatory": false,
                              "typename": "float",
                              "options": null,
                              "supported_options": null,
                              "types_accepted": [
                                "float",
                                "int",
                                "integer",
                                "nothing",
                                "null"
                              ],
                              "types_returned": ["float", "nothing"],
                              "xname": "QoreDataType",
                              "fields": {}
                            }
                          },
                          "PostalCode": {
                            "name": "PostalCode",
                            "desc": "Account Billing PostalCode",
                            "canBeNull": true,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "PostalCode",
                            "parentPath": false,
                            "type": {
                              "base_type": "string",
                              "name": "*string",
                              "can_manage_fields": false,
                              "mandatory": false,
                              "typename": "string",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                },
                                "string.encoding": {
                                  "type": "string",
                                  "desc": "the output encoding when writing to the type"
                                },
                                "string.max_size_chars": {
                                  "type": "integer",
                                  "desc": "the maximum length of the string in characters"
                                },
                                "string.empty_to_nothing": {
                                  "type": "bool",
                                  "desc": "if an empty string should be converted to no value"
                                }
                              },
                              "types_accepted": ["string", "nothing", "null"],
                              "types_returned": ["string", "nothing"],
                              "xname": "QoreStringDataTypeBase",
                              "fields": {}
                            }
                          },
                          "State": {
                            "name": "State",
                            "desc": "Account Billing State",
                            "canBeNull": true,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "State",
                            "parentPath": false,
                            "type": {
                              "base_type": "string",
                              "name": "*string",
                              "can_manage_fields": false,
                              "mandatory": false,
                              "typename": "string",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                },
                                "string.encoding": {
                                  "type": "string",
                                  "desc": "the output encoding when writing to the type"
                                },
                                "string.max_size_chars": {
                                  "type": "integer",
                                  "desc": "the maximum length of the string in characters"
                                },
                                "string.empty_to_nothing": {
                                  "type": "bool",
                                  "desc": "if an empty string should be converted to no value"
                                }
                              },
                              "types_accepted": ["string", "nothing", "null"],
                              "types_returned": ["string", "nothing"],
                              "xname": "QoreStringDataTypeBase",
                              "fields": {}
                            }
                          },
                          "Street": {
                            "name": "Street",
                            "desc": "Account Billing Street",
                            "canBeNull": true,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "Street",
                            "parentPath": false,
                            "type": {
                              "base_type": "string",
                              "name": "*string",
                              "can_manage_fields": false,
                              "mandatory": false,
                              "typename": "string",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                },
                                "string.encoding": {
                                  "type": "string",
                                  "desc": "the output encoding when writing to the type"
                                },
                                "string.max_size_chars": {
                                  "type": "integer",
                                  "desc": "the maximum length of the string in characters"
                                },
                                "string.empty_to_nothing": {
                                  "type": "bool",
                                  "desc": "if an empty string should be converted to no value"
                                }
                              },
                              "types_accepted": ["string", "nothing", "null"],
                              "types_returned": ["string", "nothing"],
                              "xname": "QoreStringDataTypeBase",
                              "fields": {}
                            }
                          }
                        }
                      }
                    },
                    "CleanStatus": {
                      "name": "CleanStatus",
                      "desc": "Account CleanStatus",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "CleanStatus",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "CustomerPriority__c": {
                      "name": "CustomerPriority__c",
                      "desc": "Account CustomerPriority__c",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "CustomerPriority__c",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "DandbCompanyId": {
                      "name": "DandbCompanyId",
                      "desc": "Account DandbCompanyId",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "DandbCompanyId",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "Description": {
                      "name": "Description",
                      "desc": "Account Description",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "Description",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "DunsNumber": {
                      "name": "DunsNumber",
                      "desc": "Account DunsNumber",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "DunsNumber",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "Fax": {
                      "name": "Fax",
                      "desc": "Account Fax",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "Fax",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "Hardware_Key_Id__c": {
                      "name": "Hardware_Key_Id__c",
                      "desc": "Account Hardware_Key_Id__c",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "Hardware_Key_Id__c",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "Industry": {
                      "name": "Industry",
                      "desc": "Account Industry",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "Industry",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "Jigsaw": {
                      "name": "Jigsaw",
                      "desc": "Account Jigsaw",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "Jigsaw",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "JigsawCompanyId": {
                      "name": "JigsawCompanyId",
                      "desc": "Account JigsawCompanyId",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "JigsawCompanyId",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "NaicsCode": {
                      "name": "NaicsCode",
                      "desc": "Account NaicsCode",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "NaicsCode",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "NaicsDesc": {
                      "name": "NaicsDesc",
                      "desc": "Account NaicsDesc",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "NaicsDesc",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "Name": {
                      "name": "Name",
                      "desc": "Account name",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "Name",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "NumberOfEmployees": {
                      "name": "NumberOfEmployees",
                      "desc": "Account NumberOfEmployees",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "NumberOfEmployees",
                      "parentPath": false,
                      "type": {
                        "base_type": "int",
                        "name": "*int",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "int",
                        "options": null,
                        "supported_options": null,
                        "types_accepted": ["int", "integer", "nothing", "null"],
                        "types_returned": ["int", "integer", "nothing"],
                        "xname": "QoreDataType",
                        "fields": {}
                      }
                    },
                    "NumberofLocations__c": {
                      "name": "NumberofLocations__c",
                      "desc": "Account NumberofLocations__c",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "NumberofLocations__c",
                      "parentPath": false,
                      "type": {
                        "base_type": "float",
                        "name": "*float",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "float",
                        "options": null,
                        "supported_options": null,
                        "types_accepted": [
                          "float",
                          "int",
                          "integer",
                          "nothing",
                          "null"
                        ],
                        "types_returned": ["float", "nothing"],
                        "xname": "QoreDataType",
                        "fields": {}
                      }
                    },
                    "OwnerId": {
                      "name": "OwnerId",
                      "desc": "Account OwnerId",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "OwnerId",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "Ownership": {
                      "name": "Ownership",
                      "desc": "Account Ownership",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "Ownership",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "ParentId": {
                      "name": "ParentId",
                      "desc": "Account ParentId",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "ParentId",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "Phone": {
                      "name": "Phone",
                      "desc": "Account Phone",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "Phone",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "PhotoUrl": {
                      "name": "PhotoUrl",
                      "desc": "Account PhotoUrl",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "PhotoUrl",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "Rating": {
                      "name": "Rating",
                      "desc": "Account Rating",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "Rating",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "SLAExpirationDate__c": {
                      "name": "SLAExpirationDate__c",
                      "desc": "Account SLAExpirationDate__c",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "SLAExpirationDate__c",
                      "parentPath": false,
                      "type": {
                        "base_type": "date",
                        "name": "*date",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "date",
                        "options": null,
                        "supported_options": null,
                        "types_accepted": ["date", "nothing", "null"],
                        "types_returned": ["date", "nothing"],
                        "xname": "QoreDataType",
                        "fields": {}
                      }
                    },
                    "SLASerialNumber__c": {
                      "name": "SLASerialNumber__c",
                      "desc": "Account SLASerialNumber__c",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "SLASerialNumber__c",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "SLA__c": {
                      "name": "SLA__c",
                      "desc": "Account SLA__c",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "SLA__c",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "ShippingAddress": {
                      "name": "ShippingAddress",
                      "desc": "Account Shipping info",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "ShippingAddress",
                      "parentPath": false,
                      "type": {
                        "base_type": "hash<auto>",
                        "name": "*hash<auto>",
                        "can_manage_fields": true,
                        "mandatory": false,
                        "typename": "hash",
                        "options": null,
                        "supported_options": null,
                        "types_accepted": ["hash", "nothing", "null"],
                        "types_returned": ["hash", "nothing"],
                        "xname": "HashDataType",
                        "fields": {
                          "City": {
                            "name": "City",
                            "desc": "Account Shipping City",
                            "canBeNull": true,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "City",
                            "parentPath": false,
                            "type": {
                              "base_type": "string",
                              "name": "*string",
                              "can_manage_fields": false,
                              "mandatory": false,
                              "typename": "string",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                },
                                "string.encoding": {
                                  "type": "string",
                                  "desc": "the output encoding when writing to the type"
                                },
                                "string.max_size_chars": {
                                  "type": "integer",
                                  "desc": "the maximum length of the string in characters"
                                },
                                "string.empty_to_nothing": {
                                  "type": "bool",
                                  "desc": "if an empty string should be converted to no value"
                                }
                              },
                              "types_accepted": ["string", "nothing", "null"],
                              "types_returned": ["string", "nothing"],
                              "xname": "QoreStringDataTypeBase",
                              "fields": {}
                            }
                          },
                          "Country": {
                            "name": "Country",
                            "desc": "Account Shipping Country",
                            "canBeNull": true,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "Country",
                            "parentPath": false,
                            "type": {
                              "base_type": "string",
                              "name": "*string",
                              "can_manage_fields": false,
                              "mandatory": false,
                              "typename": "string",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                },
                                "string.encoding": {
                                  "type": "string",
                                  "desc": "the output encoding when writing to the type"
                                },
                                "string.max_size_chars": {
                                  "type": "integer",
                                  "desc": "the maximum length of the string in characters"
                                },
                                "string.empty_to_nothing": {
                                  "type": "bool",
                                  "desc": "if an empty string should be converted to no value"
                                }
                              },
                              "types_accepted": ["string", "nothing", "null"],
                              "types_returned": ["string", "nothing"],
                              "xname": "QoreStringDataTypeBase",
                              "fields": {}
                            }
                          },
                          "GeocodeAccuracy": {
                            "name": "GeocodeAccuracy",
                            "desc": "Account Shipping GeocodeAccuracy",
                            "canBeNull": true,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "GeocodeAccuracy",
                            "parentPath": false,
                            "type": {
                              "base_type": "string",
                              "name": "*string",
                              "can_manage_fields": false,
                              "mandatory": false,
                              "typename": "string",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                },
                                "string.encoding": {
                                  "type": "string",
                                  "desc": "the output encoding when writing to the type"
                                },
                                "string.max_size_chars": {
                                  "type": "integer",
                                  "desc": "the maximum length of the string in characters"
                                },
                                "string.empty_to_nothing": {
                                  "type": "bool",
                                  "desc": "if an empty string should be converted to no value"
                                }
                              },
                              "types_accepted": ["string", "nothing", "null"],
                              "types_returned": ["string", "nothing"],
                              "xname": "QoreStringDataTypeBase",
                              "fields": {}
                            }
                          },
                          "Latitude": {
                            "name": "Latitude",
                            "desc": "Account Shipping Latitude",
                            "canBeNull": true,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "Latitude",
                            "parentPath": false,
                            "type": {
                              "base_type": "float",
                              "name": "*float",
                              "can_manage_fields": false,
                              "mandatory": false,
                              "typename": "float",
                              "options": null,
                              "supported_options": null,
                              "types_accepted": [
                                "float",
                                "int",
                                "integer",
                                "nothing",
                                "null"
                              ],
                              "types_returned": ["float", "nothing"],
                              "xname": "QoreDataType",
                              "fields": {}
                            }
                          },
                          "Longitude": {
                            "name": "Longitude",
                            "desc": "Account Shipping Longitude",
                            "canBeNull": true,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "Longitude",
                            "parentPath": false,
                            "type": {
                              "base_type": "float",
                              "name": "*float",
                              "can_manage_fields": false,
                              "mandatory": false,
                              "typename": "float",
                              "options": null,
                              "supported_options": null,
                              "types_accepted": [
                                "float",
                                "int",
                                "integer",
                                "nothing",
                                "null"
                              ],
                              "types_returned": ["float", "nothing"],
                              "xname": "QoreDataType",
                              "fields": {}
                            }
                          },
                          "PostalCode": {
                            "name": "PostalCode",
                            "desc": "Account Shipping PostalCode",
                            "canBeNull": true,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "PostalCode",
                            "parentPath": false,
                            "type": {
                              "base_type": "string",
                              "name": "*string",
                              "can_manage_fields": false,
                              "mandatory": false,
                              "typename": "string",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                },
                                "string.encoding": {
                                  "type": "string",
                                  "desc": "the output encoding when writing to the type"
                                },
                                "string.max_size_chars": {
                                  "type": "integer",
                                  "desc": "the maximum length of the string in characters"
                                },
                                "string.empty_to_nothing": {
                                  "type": "bool",
                                  "desc": "if an empty string should be converted to no value"
                                }
                              },
                              "types_accepted": ["string", "nothing", "null"],
                              "types_returned": ["string", "nothing"],
                              "xname": "QoreStringDataTypeBase",
                              "fields": {}
                            }
                          },
                          "State": {
                            "name": "State",
                            "desc": "Account Shipping State",
                            "canBeNull": true,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "State",
                            "parentPath": false,
                            "type": {
                              "base_type": "string",
                              "name": "*string",
                              "can_manage_fields": false,
                              "mandatory": false,
                              "typename": "string",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                },
                                "string.encoding": {
                                  "type": "string",
                                  "desc": "the output encoding when writing to the type"
                                },
                                "string.max_size_chars": {
                                  "type": "integer",
                                  "desc": "the maximum length of the string in characters"
                                },
                                "string.empty_to_nothing": {
                                  "type": "bool",
                                  "desc": "if an empty string should be converted to no value"
                                }
                              },
                              "types_accepted": ["string", "nothing", "null"],
                              "types_returned": ["string", "nothing"],
                              "xname": "QoreStringDataTypeBase",
                              "fields": {}
                            }
                          },
                          "Street": {
                            "name": "Street",
                            "desc": "Account Shipping Street",
                            "canBeNull": true,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "Street",
                            "parentPath": false,
                            "type": {
                              "base_type": "string",
                              "name": "*string",
                              "can_manage_fields": false,
                              "mandatory": false,
                              "typename": "string",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                },
                                "string.encoding": {
                                  "type": "string",
                                  "desc": "the output encoding when writing to the type"
                                },
                                "string.max_size_chars": {
                                  "type": "integer",
                                  "desc": "the maximum length of the string in characters"
                                },
                                "string.empty_to_nothing": {
                                  "type": "bool",
                                  "desc": "if an empty string should be converted to no value"
                                }
                              },
                              "types_accepted": ["string", "nothing", "null"],
                              "types_returned": ["string", "nothing"],
                              "xname": "QoreStringDataTypeBase",
                              "fields": {}
                            }
                          }
                        }
                      }
                    },
                    "Sic": {
                      "name": "Sic",
                      "desc": "Account Sic",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "Sic",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "SicDesc": {
                      "name": "SicDesc",
                      "desc": "Account SicDesc",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "SicDesc",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "Site": {
                      "name": "Site",
                      "desc": "Account Site",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "Site",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "TickerSymbol": {
                      "name": "TickerSymbol",
                      "desc": "Account TickerSymbol",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "TickerSymbol",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "Tradestyle": {
                      "name": "Tradestyle",
                      "desc": "Account Tradestyle",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "Tradestyle",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "Type": {
                      "name": "Type",
                      "desc": "Account Type",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "Type",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "UpsellOpportunity__c": {
                      "name": "UpsellOpportunity__c",
                      "desc": "Account UpsellOpportunity__c",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "UpsellOpportunity__c",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "Website": {
                      "name": "Website",
                      "desc": "Account Website",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "Website",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "YearStarted": {
                      "name": "YearStarted",
                      "desc": "Account YearStarted",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "YearStarted",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "LastModifiedDate": {
                      "name": "LastModifiedDate",
                      "desc": "Object LastModifiedDate",
                      "canBeNull": false,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "LastModifiedDate",
                      "parentPath": false,
                      "type": {
                        "base_type": "date",
                        "name": "date",
                        "can_manage_fields": false,
                        "mandatory": true,
                        "typename": "date",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          }
                        },
                        "types_accepted": ["date"],
                        "types_returned": ["date"],
                        "xname": "QoreDataType",
                        "fields": {}
                      }
                    },
                    "ChangeEventHeader": {
                      "name": "ChangeEventHeader",
                      "desc": "Salesforce change event info",
                      "canBeNull": false,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "ChangeEventHeader",
                      "parentPath": false,
                      "type": {
                        "base_type": "hash<auto>",
                        "name": "hash<auto>",
                        "can_manage_fields": true,
                        "mandatory": true,
                        "typename": "hash",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          }
                        },
                        "types_accepted": ["hash"],
                        "types_returned": ["hash"],
                        "xname": "HashDataType",
                        "fields": {
                          "changeOrigin": {
                            "name": "changeOrigin",
                            "desc": "Only populated for changes done by API apps or from Lightning Experience; empty otherwise. The Salesforce API and the API client ID that initiated the change, if set by the client",
                            "canBeNull": false,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "changeOrigin",
                            "parentPath": false,
                            "type": {
                              "base_type": "string",
                              "name": "string",
                              "can_manage_fields": false,
                              "mandatory": true,
                              "typename": "string",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                },
                                "string.encoding": {
                                  "type": "string",
                                  "desc": "the output encoding when writing to the type"
                                },
                                "string.max_size_chars": {
                                  "type": "integer",
                                  "desc": "the maximum length of the string in characters"
                                }
                              },
                              "types_accepted": ["string"],
                              "types_returned": ["string"],
                              "xname": "QoreStringDataTypeBase",
                              "fields": {}
                            }
                          },
                          "changeType": {
                            "name": "changeType",
                            "desc": "The operation that caused the change. Can be one of the following values: - `CREATE` - `UPDATE` - `DELETE` - `UNDELETE`\nFor gap events, the change type starts with the `GAP_` prefix: - `GAP_CREATE` - `GAP_UPDATE` - `GAP_DELETE` - `GAP_UNDELETE`\nFor overflow events, the change type is `GAP_OVERFLOW`.",
                            "canBeNull": false,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "changeType",
                            "parentPath": false,
                            "type": {
                              "base_type": "string",
                              "name": "string",
                              "can_manage_fields": false,
                              "mandatory": true,
                              "typename": "string",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                },
                                "string.encoding": {
                                  "type": "string",
                                  "desc": "the output encoding when writing to the type"
                                },
                                "string.max_size_chars": {
                                  "type": "integer",
                                  "desc": "the maximum length of the string in characters"
                                }
                              },
                              "types_accepted": ["string"],
                              "types_returned": ["string"],
                              "xname": "QoreStringDataTypeBase",
                              "fields": {}
                            }
                          },
                          "changedFields": {
                            "name": "changedFields",
                            "desc": "list of the fields that were changed in an update operation, including the `LastModifiedDate` system field. This field is empty for other operations, including record creation",
                            "canBeNull": false,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "changedFields",
                            "parentPath": false,
                            "type": {
                              "base_type": "list",
                              "name": "list<auto>",
                              "can_manage_fields": false,
                              "mandatory": true,
                              "typename": "list",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                }
                              },
                              "types_accepted": ["list"],
                              "types_returned": ["list"],
                              "xname": "QoreDataType",
                              "fields": {}
                            }
                          },
                          "commitNumber": {
                            "name": "commitNumber",
                            "desc": "The system change number (SCN) of a committed transaction, which increases sequentially",
                            "canBeNull": false,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "commitNumber",
                            "parentPath": false,
                            "type": {
                              "base_type": "int",
                              "name": "int",
                              "can_manage_fields": false,
                              "mandatory": true,
                              "typename": "int",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                }
                              },
                              "types_accepted": ["int", "integer"],
                              "types_returned": ["int", "integer"],
                              "xname": "QoreDataType",
                              "fields": {}
                            }
                          },
                          "commitTimestamp": {
                            "name": "commitTimestamp",
                            "desc": "The date and time when the change occurred, represented as the number of milliseconds since `January 1, 1970 00:00:00 GMT`",
                            "canBeNull": false,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "commitTimestamp",
                            "parentPath": false,
                            "type": {
                              "base_type": "int",
                              "name": "int",
                              "can_manage_fields": false,
                              "mandatory": true,
                              "typename": "int",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                }
                              },
                              "types_accepted": ["int", "integer"],
                              "types_returned": ["int", "integer"],
                              "xname": "QoreDataType",
                              "fields": {}
                            }
                          },
                          "commitUser": {
                            "name": "commitUser",
                            "desc": "The ID of the user that ran the change operation",
                            "canBeNull": false,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "commitUser",
                            "parentPath": false,
                            "type": {
                              "base_type": "string",
                              "name": "string",
                              "can_manage_fields": false,
                              "mandatory": true,
                              "typename": "string",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                },
                                "string.encoding": {
                                  "type": "string",
                                  "desc": "the output encoding when writing to the type"
                                },
                                "string.max_size_chars": {
                                  "type": "integer",
                                  "desc": "the maximum length of the string in characters"
                                }
                              },
                              "types_accepted": ["string"],
                              "types_returned": ["string"],
                              "xname": "QoreStringDataTypeBase",
                              "fields": {}
                            }
                          },
                          "entityName": {
                            "name": "entityName",
                            "desc": "The API name of the standard or custom object that the change pertains to",
                            "canBeNull": false,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "entityName",
                            "parentPath": false,
                            "type": {
                              "base_type": "string",
                              "name": "string",
                              "can_manage_fields": false,
                              "mandatory": true,
                              "typename": "string",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                },
                                "string.encoding": {
                                  "type": "string",
                                  "desc": "the output encoding when writing to the type"
                                },
                                "string.max_size_chars": {
                                  "type": "integer",
                                  "desc": "the maximum length of the string in characters"
                                }
                              },
                              "types_accepted": ["string"],
                              "types_returned": ["string"],
                              "xname": "QoreStringDataTypeBase",
                              "fields": {}
                            }
                          },
                          "recordIds": {
                            "name": "recordIds",
                            "desc": "One or more record IDs for the changed records (typically only one ID)",
                            "canBeNull": false,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "recordIds",
                            "parentPath": false,
                            "type": {
                              "base_type": "list",
                              "name": "list<auto>",
                              "can_manage_fields": false,
                              "mandatory": true,
                              "typename": "list",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                }
                              },
                              "types_accepted": ["list"],
                              "types_returned": ["list"],
                              "xname": "QoreDataType",
                              "fields": {}
                            }
                          },
                          "sequenceNumber": {
                            "name": "sequenceNumber",
                            "desc": "The sequence of the change within a transaction",
                            "canBeNull": false,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "sequenceNumber",
                            "parentPath": false,
                            "type": {
                              "base_type": "int",
                              "name": "int",
                              "can_manage_fields": false,
                              "mandatory": true,
                              "typename": "int",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                }
                              },
                              "types_accepted": ["int", "integer"],
                              "types_returned": ["int", "integer"],
                              "xname": "QoreDataType",
                              "fields": {}
                            }
                          },
                          "transactionKey": {
                            "name": "transactionKey",
                            "desc": "A string that uniquely identifies each Salesforce transaction. You can use this key to identify and group all changes that were made in the same transaction",
                            "canBeNull": false,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "transactionKey",
                            "parentPath": false,
                            "type": {
                              "base_type": "string",
                              "name": "string",
                              "can_manage_fields": false,
                              "mandatory": true,
                              "typename": "string",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                },
                                "string.encoding": {
                                  "type": "string",
                                  "desc": "the output encoding when writing to the type"
                                },
                                "string.max_size_chars": {
                                  "type": "integer",
                                  "desc": "the maximum length of the string in characters"
                                }
                              },
                              "types_accepted": ["string"],
                              "types_returned": ["string"],
                              "xname": "QoreStringDataTypeBase",
                              "fields": {}
                            }
                          }
                        }
                      }
                    },
                    "zeyos_contact_id__c": {
                      "name": "zeyos_contact_id__c",
                      "desc": "Account zeyos_contact_id__c",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "zeyos_contact_id__c",
                      "parentPath": false,
                      "type": {
                        "base_type": "float",
                        "name": "*float",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "float",
                        "options": null,
                        "supported_options": null,
                        "types_accepted": [
                          "float",
                          "int",
                          "integer",
                          "nothing",
                          "null"
                        ],
                        "types_returned": ["float", "nothing"],
                        "xname": "QoreDataType",
                        "fields": {}
                      }
                    }
                  }
                }
              },
              "schema": {
                "name": "schema",
                "desc": "Salesforce event REST event schema identifier",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "schema",
                "parentPath": false,
                "type": {
                  "base_type": "string",
                  "name": "string",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "string",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    },
                    "string.encoding": {
                      "type": "string",
                      "desc": "the output encoding when writing to the type"
                    },
                    "string.max_size_chars": {
                      "type": "integer",
                      "desc": "the maximum length of the string in characters"
                    }
                  },
                  "types_accepted": ["string"],
                  "types_returned": ["string"],
                  "xname": "QoreStringDataTypeBase",
                  "fields": {}
                }
              }
            }
          },
          "locked": false
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got type 19"
    },
    {
      "request_id": "pKaFUiOOYlCExbj",
      "tab_token": "none",
      "data": {
        "iface_kind": "type",
        "type": {
          "id": 21,
          "type": "type",
          "path": "/qoretechnologies/building-blocks/sftp/event",
          "display_name": "/qoretechnologies/building-blocks/sftp/event",
          "short_desc": "Qore data type \"hash<auto>\"",
          "desc": "Qore data type \"hash<auto>\"",
          "typeinfo": {
            "base_type": "hash<auto>",
            "name": "hash<auto>",
            "can_manage_fields": true,
            "mandatory": true,
            "typename": "hash",
            "options": null,
            "supported_options": {
              "qore.no_null": {
                "type": "bool",
                "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
              },
              "qore.external_name": {
                "type": "string",
                "desc": "A note giving the external name for the type"
              }
            },
            "types_accepted": ["hash"],
            "types_returned": ["hash"],
            "xname": "HashDataType",
            "fields": {
              "tmp_filename": {
                "name": "tmp_filename",
                "desc": "the temporary filename used to store the file until the post action; only present if the `sftp-polling-file-connection` config item is set",
                "canBeNull": true,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "tmp_filename",
                "parentPath": false,
                "type": {
                  "base_type": "string",
                  "name": "*string",
                  "can_manage_fields": false,
                  "mandatory": false,
                  "typename": "string",
                  "options": null,
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    },
                    "string.encoding": {
                      "type": "string",
                      "desc": "the output encoding when writing to the type"
                    },
                    "string.max_size_chars": {
                      "type": "integer",
                      "desc": "the maximum length of the string in characters"
                    },
                    "string.empty_to_nothing": {
                      "type": "bool",
                      "desc": "if an empty string should be converted to no value"
                    }
                  },
                  "types_accepted": ["string", "nothing", "null"],
                  "types_returned": ["string", "nothing"],
                  "xname": "QoreStringDataTypeBase",
                  "fields": {}
                }
              },
              "tmp_path": {
                "name": "tmp_path",
                "desc": "the temporary path on the filesystem of the file used during the initial file transfer; only present if the `sftp-polling-file-connection` config item is set",
                "canBeNull": true,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "tmp_path",
                "parentPath": false,
                "type": {
                  "base_type": "string",
                  "name": "*string",
                  "can_manage_fields": false,
                  "mandatory": false,
                  "typename": "string",
                  "options": null,
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    },
                    "string.encoding": {
                      "type": "string",
                      "desc": "the output encoding when writing to the type"
                    },
                    "string.max_size_chars": {
                      "type": "integer",
                      "desc": "the maximum length of the string in characters"
                    },
                    "string.empty_to_nothing": {
                      "type": "bool",
                      "desc": "if an empty string should be converted to no value"
                    }
                  },
                  "types_accepted": ["string", "nothing", "null"],
                  "types_returned": ["string", "nothing"],
                  "xname": "QoreStringDataTypeBase",
                  "fields": {}
                }
              },
              "local_path": {
                "name": "local_path",
                "desc": "this key is set to a string giving the local path where the file's data is stored; only present if the `sftp-polling-file-connection` config item is set",
                "canBeNull": true,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "local_path",
                "parentPath": false,
                "type": {
                  "base_type": "string",
                  "name": "*string",
                  "can_manage_fields": false,
                  "mandatory": false,
                  "typename": "string",
                  "options": null,
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    },
                    "string.encoding": {
                      "type": "string",
                      "desc": "the output encoding when writing to the type"
                    },
                    "string.max_size_chars": {
                      "type": "integer",
                      "desc": "the maximum length of the string in characters"
                    },
                    "string.empty_to_nothing": {
                      "type": "bool",
                      "desc": "if an empty string should be converted to no value"
                    }
                  },
                  "types_accepted": ["string", "nothing", "null"],
                  "types_returned": ["string", "nothing"],
                  "xname": "QoreStringDataTypeBase",
                  "fields": {}
                }
              },
              "transfer_time": {
                "name": "transfer_time",
                "desc": "a relative date/time value giving the time it took to transfer the file; only present if the `sftp-polling-file-connection` config item is set",
                "canBeNull": true,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "transfer_time",
                "parentPath": false,
                "type": {
                  "base_type": "date",
                  "name": "*date",
                  "can_manage_fields": false,
                  "mandatory": false,
                  "typename": "date",
                  "options": null,
                  "supported_options": null,
                  "types_accepted": ["date", "nothing", "null"],
                  "types_returned": ["date", "nothing"],
                  "xname": "QoreDataType",
                  "fields": {}
                }
              },
              "remote_status": {
                "name": "remote_status",
                "desc": "a string giving the disposition of the file on the remote server; either `DELETED` or `MOVED`",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "remote_status",
                "parentPath": false,
                "type": {
                  "base_type": "string",
                  "name": "string",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "string",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    },
                    "string.encoding": {
                      "type": "string",
                      "desc": "the output encoding when writing to the type"
                    },
                    "string.max_size_chars": {
                      "type": "integer",
                      "desc": "the maximum length of the string in characters"
                    }
                  },
                  "types_accepted": ["string"],
                  "types_returned": ["string"],
                  "xname": "QoreStringDataTypeBase",
                  "fields": {}
                }
              },
              "remote_move_targert": {
                "name": "remote_move_targert",
                "desc": "a string giving the target file name for moved files; only present when `remote_status` is `MOVED`",
                "canBeNull": true,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "remote_move_targert",
                "parentPath": false,
                "type": {
                  "base_type": "string",
                  "name": "*string",
                  "can_manage_fields": false,
                  "mandatory": false,
                  "typename": "string",
                  "options": null,
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    },
                    "string.encoding": {
                      "type": "string",
                      "desc": "the output encoding when writing to the type"
                    },
                    "string.max_size_chars": {
                      "type": "integer",
                      "desc": "the maximum length of the string in characters"
                    },
                    "string.empty_to_nothing": {
                      "type": "bool",
                      "desc": "if an empty string should be converted to no value"
                    }
                  },
                  "types_accepted": ["string", "nothing", "null"],
                  "types_returned": ["string", "nothing"],
                  "xname": "QoreStringDataTypeBase",
                  "fields": {}
                }
              }
            }
          },
          "locked": false
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got type 21"
    },
    {
      "request_id": "a28z9997mQS3gQu",
      "tab_token": "none",
      "data": {
        "iface_kind": "type",
        "type": {
          "id": 24,
          "type": "type",
          "path": "/qoretechnologies/building-blocks/salesforce/stream-event",
          "display_name": "/qoretechnologies/building-blocks/salesforce/stream-event",
          "short_desc": "Qore data type \"hash<auto>\"",
          "desc": "Qore data type \"hash<auto>\"",
          "typeinfo": {
            "base_type": "hash<auto>",
            "name": "hash<auto>",
            "can_manage_fields": true,
            "mandatory": true,
            "typename": "hash",
            "options": null,
            "supported_options": {
              "qore.no_null": {
                "type": "bool",
                "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
              },
              "qore.external_name": {
                "type": "string",
                "desc": "A note giving the external name for the type"
              }
            },
            "types_accepted": ["hash"],
            "types_returned": ["hash"],
            "xname": "HashDataType",
            "fields": {
              "event": {
                "name": "event",
                "desc": "event metadata hash",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "event",
                "parentPath": false,
                "type": {
                  "base_type": "hash<auto>",
                  "name": "hash<auto>",
                  "can_manage_fields": true,
                  "mandatory": true,
                  "typename": "hash",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    }
                  },
                  "types_accepted": ["hash"],
                  "types_returned": ["hash"],
                  "xname": "HashDataType",
                  "fields": {
                    "replayId": {
                      "name": "replayId",
                      "desc": "Salesforce event ID",
                      "canBeNull": false,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "replayId",
                      "parentPath": false,
                      "type": {
                        "base_type": "int",
                        "name": "int",
                        "can_manage_fields": false,
                        "mandatory": true,
                        "typename": "int",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          }
                        },
                        "types_accepted": ["int", "integer"],
                        "types_returned": ["int", "integer"],
                        "xname": "QoreDataType",
                        "fields": {}
                      }
                    }
                  }
                }
              },
              "payload": {
                "name": "payload",
                "desc": "the event payload hash; contents depend on the event source",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "payload",
                "parentPath": false,
                "type": {
                  "base_type": "hash<auto>",
                  "name": "hash<auto>",
                  "can_manage_fields": true,
                  "mandatory": true,
                  "typename": "hash",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    }
                  },
                  "types_accepted": ["hash"],
                  "types_returned": ["hash"],
                  "xname": "HashDataType",
                  "fields": {
                    "ChangeEventHeader": {
                      "name": "ChangeEventHeader",
                      "desc": "Salesforce change event info",
                      "canBeNull": false,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "ChangeEventHeader",
                      "parentPath": false,
                      "type": {
                        "base_type": "hash<auto>",
                        "name": "hash<auto>",
                        "can_manage_fields": true,
                        "mandatory": true,
                        "typename": "hash",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          }
                        },
                        "types_accepted": ["hash"],
                        "types_returned": ["hash"],
                        "xname": "HashDataType",
                        "fields": {
                          "changeOrigin": {
                            "name": "changeOrigin",
                            "desc": "Only populated for changes done by API apps or from Lightning Experience; empty otherwise. The Salesforce API and the API client ID that initiated the change, if set by the client",
                            "canBeNull": false,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "changeOrigin",
                            "parentPath": false,
                            "type": {
                              "base_type": "string",
                              "name": "string",
                              "can_manage_fields": false,
                              "mandatory": true,
                              "typename": "string",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                },
                                "string.encoding": {
                                  "type": "string",
                                  "desc": "the output encoding when writing to the type"
                                },
                                "string.max_size_chars": {
                                  "type": "integer",
                                  "desc": "the maximum length of the string in characters"
                                }
                              },
                              "types_accepted": ["string"],
                              "types_returned": ["string"],
                              "xname": "QoreStringDataTypeBase",
                              "fields": {}
                            }
                          },
                          "changeType": {
                            "name": "changeType",
                            "desc": "The operation that caused the change. Can be one of the following values: - `CREATE` - `UPDATE` - `DELETE` - `UNDELETE`\nFor gap events, the change type starts with the `GAP_` prefix: - `GAP_CREATE` - `GAP_UPDATE` - `GAP_DELETE` - `GAP_UNDELETE`\nFor overflow events, the change type is `GAP_OVERFLOW`.",
                            "canBeNull": false,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "changeType",
                            "parentPath": false,
                            "type": {
                              "base_type": "string",
                              "name": "string",
                              "can_manage_fields": false,
                              "mandatory": true,
                              "typename": "string",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                },
                                "string.encoding": {
                                  "type": "string",
                                  "desc": "the output encoding when writing to the type"
                                },
                                "string.max_size_chars": {
                                  "type": "integer",
                                  "desc": "the maximum length of the string in characters"
                                }
                              },
                              "types_accepted": ["string"],
                              "types_returned": ["string"],
                              "xname": "QoreStringDataTypeBase",
                              "fields": {}
                            }
                          },
                          "changedFields": {
                            "name": "changedFields",
                            "desc": "list of the fields that were changed in an update operation, including the `LastModifiedDate` system field. This field is empty for other operations, including record creation",
                            "canBeNull": false,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "changedFields",
                            "parentPath": false,
                            "type": {
                              "base_type": "list",
                              "name": "list<auto>",
                              "can_manage_fields": false,
                              "mandatory": true,
                              "typename": "list",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                }
                              },
                              "types_accepted": ["list"],
                              "types_returned": ["list"],
                              "xname": "QoreDataType",
                              "fields": {}
                            }
                          },
                          "commitNumber": {
                            "name": "commitNumber",
                            "desc": "The system change number (SCN) of a committed transaction, which increases sequentially",
                            "canBeNull": false,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "commitNumber",
                            "parentPath": false,
                            "type": {
                              "base_type": "int",
                              "name": "int",
                              "can_manage_fields": false,
                              "mandatory": true,
                              "typename": "int",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                }
                              },
                              "types_accepted": ["int", "integer"],
                              "types_returned": ["int", "integer"],
                              "xname": "QoreDataType",
                              "fields": {}
                            }
                          },
                          "commitTimestamp": {
                            "name": "commitTimestamp",
                            "desc": "The date and time when the change occurred, represented as the number of milliseconds since `January 1, 1970 00:00:00 GMT`",
                            "canBeNull": false,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "commitTimestamp",
                            "parentPath": false,
                            "type": {
                              "base_type": "int",
                              "name": "int",
                              "can_manage_fields": false,
                              "mandatory": true,
                              "typename": "int",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                }
                              },
                              "types_accepted": ["int", "integer"],
                              "types_returned": ["int", "integer"],
                              "xname": "QoreDataType",
                              "fields": {}
                            }
                          },
                          "commitUser": {
                            "name": "commitUser",
                            "desc": "The ID of the user that ran the change operation",
                            "canBeNull": false,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "commitUser",
                            "parentPath": false,
                            "type": {
                              "base_type": "string",
                              "name": "string",
                              "can_manage_fields": false,
                              "mandatory": true,
                              "typename": "string",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                },
                                "string.encoding": {
                                  "type": "string",
                                  "desc": "the output encoding when writing to the type"
                                },
                                "string.max_size_chars": {
                                  "type": "integer",
                                  "desc": "the maximum length of the string in characters"
                                }
                              },
                              "types_accepted": ["string"],
                              "types_returned": ["string"],
                              "xname": "QoreStringDataTypeBase",
                              "fields": {}
                            }
                          },
                          "entityName": {
                            "name": "entityName",
                            "desc": "The API name of the standard or custom object that the change pertains to",
                            "canBeNull": false,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "entityName",
                            "parentPath": false,
                            "type": {
                              "base_type": "string",
                              "name": "string",
                              "can_manage_fields": false,
                              "mandatory": true,
                              "typename": "string",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                },
                                "string.encoding": {
                                  "type": "string",
                                  "desc": "the output encoding when writing to the type"
                                },
                                "string.max_size_chars": {
                                  "type": "integer",
                                  "desc": "the maximum length of the string in characters"
                                }
                              },
                              "types_accepted": ["string"],
                              "types_returned": ["string"],
                              "xname": "QoreStringDataTypeBase",
                              "fields": {}
                            }
                          },
                          "recordIds": {
                            "name": "recordIds",
                            "desc": "One or more record IDs for the changed records (typically only one ID)",
                            "canBeNull": false,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "recordIds",
                            "parentPath": false,
                            "type": {
                              "base_type": "list",
                              "name": "list<auto>",
                              "can_manage_fields": false,
                              "mandatory": true,
                              "typename": "list",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                }
                              },
                              "types_accepted": ["list"],
                              "types_returned": ["list"],
                              "xname": "QoreDataType",
                              "fields": {}
                            }
                          },
                          "sequenceNumber": {
                            "name": "sequenceNumber",
                            "desc": "The sequence of the change within a transaction",
                            "canBeNull": false,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "sequenceNumber",
                            "parentPath": false,
                            "type": {
                              "base_type": "int",
                              "name": "int",
                              "can_manage_fields": false,
                              "mandatory": true,
                              "typename": "int",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                }
                              },
                              "types_accepted": ["int", "integer"],
                              "types_returned": ["int", "integer"],
                              "xname": "QoreDataType",
                              "fields": {}
                            }
                          },
                          "transactionKey": {
                            "name": "transactionKey",
                            "desc": "A string that uniquely identifies each Salesforce transaction. You can use this key to identify and group all changes that were made in the same transaction",
                            "canBeNull": false,
                            "isCustom": true,
                            "firstCustomInHierarchy": true,
                            "isChild": false,
                            "level": 0,
                            "path": "transactionKey",
                            "parentPath": false,
                            "type": {
                              "base_type": "string",
                              "name": "string",
                              "can_manage_fields": false,
                              "mandatory": true,
                              "typename": "string",
                              "options": {
                                "qore.no_null": true
                              },
                              "supported_options": {
                                "qore.no_null": {
                                  "type": "bool",
                                  "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                                },
                                "qore.external_name": {
                                  "type": "string",
                                  "desc": "A note giving the external name for the type"
                                },
                                "string.encoding": {
                                  "type": "string",
                                  "desc": "the output encoding when writing to the type"
                                },
                                "string.max_size_chars": {
                                  "type": "integer",
                                  "desc": "the maximum length of the string in characters"
                                }
                              },
                              "types_accepted": ["string"],
                              "types_returned": ["string"],
                              "xname": "QoreStringDataTypeBase",
                              "fields": {}
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
              "schema": {
                "name": "schema",
                "desc": "Salesforce event REST event schema identifier",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "schema",
                "parentPath": false,
                "type": {
                  "base_type": "string",
                  "name": "string",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "string",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    },
                    "string.encoding": {
                      "type": "string",
                      "desc": "the output encoding when writing to the type"
                    },
                    "string.max_size_chars": {
                      "type": "integer",
                      "desc": "the maximum length of the string in characters"
                    }
                  },
                  "types_accepted": ["string"],
                  "types_returned": ["string"],
                  "xname": "QoreStringDataTypeBase",
                  "fields": {}
                }
              }
            }
          },
          "locked": false
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got type 24"
    },
    {
      "request_id": "ETPSI3DsgJs7nkT",
      "tab_token": "none",
      "data": {
        "iface_kind": "type",
        "type": {
          "id": 28,
          "type": "type",
          "path": "/qoretechnologies/building-blocks/websockets/broadcast-data-event",
          "display_name": "/qoretechnologies/building-blocks/websockets/broadcast-data-event",
          "short_desc": "Qore data type \"hash<auto>\"",
          "desc": "Qore data type \"hash<auto>\"",
          "typeinfo": {
            "base_type": "hash<auto>",
            "name": "hash<auto>",
            "can_manage_fields": true,
            "mandatory": true,
            "typename": "hash",
            "options": null,
            "supported_options": {
              "qore.no_null": {
                "type": "bool",
                "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
              },
              "qore.external_name": {
                "type": "string",
                "desc": "A note giving the external name for the type"
              }
            },
            "types_accepted": ["hash"],
            "types_returned": ["hash"],
            "xname": "HashDataType",
            "fields": {
              "msg": {
                "name": "msg",
                "desc": "The message to broadcast; can be of any type that can be serialized",
                "canBeNull": true,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "msg",
                "parentPath": false,
                "type": {
                  "base_type": "auto",
                  "name": "auto",
                  "can_manage_fields": false,
                  "mandatory": false,
                  "typename": "auto",
                  "options": null,
                  "supported_options": null,
                  "types_accepted": ["any"],
                  "types_returned": ["any"],
                  "xname": "QoreDataType",
                  "fields": {}
                }
              }
            }
          },
          "locked": false
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got type 28"
    },
    {
      "request_id": "HBtxKvV12PZ8ouS",
      "tab_token": "none",
      "data": {
        "iface_kind": "type",
        "type": {
          "id": 29,
          "type": "type",
          "path": "/qoretechnologies/building-blocks/websockets/recv-data-event",
          "display_name": "/qoretechnologies/building-blocks/websockets/recv-data-event",
          "short_desc": "Qore data type \"hash<auto>\"",
          "desc": "Qore data type \"hash<auto>\"",
          "typeinfo": {
            "base_type": "hash<auto>",
            "name": "hash<auto>",
            "can_manage_fields": true,
            "mandatory": true,
            "typename": "hash",
            "options": null,
            "supported_options": {
              "qore.no_null": {
                "type": "bool",
                "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
              },
              "qore.external_name": {
                "type": "string",
                "desc": "A note giving the external name for the type"
              }
            },
            "types_accepted": ["hash"],
            "types_returned": ["hash"],
            "xname": "HashDataType",
            "fields": {
              "event_id": {
                "name": "event_id",
                "desc": "the unique event ID",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "event_id",
                "parentPath": false,
                "type": {
                  "base_type": "int",
                  "name": "int",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "int",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    }
                  },
                  "types_accepted": ["int", "integer"],
                  "types_returned": ["int", "integer"],
                  "xname": "QoreDataType",
                  "fields": {}
                }
              },
              "cx": {
                "name": "cx",
                "desc": "the connection context hash",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "cx",
                "parentPath": false,
                "type": {
                  "base_type": "hash<auto>",
                  "name": "hash<auto>",
                  "can_manage_fields": true,
                  "mandatory": true,
                  "typename": "hash",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    }
                  },
                  "types_accepted": ["hash"],
                  "types_returned": ["hash"],
                  "xname": "HashDataType",
                  "fields": {
                    "socket": {
                      "name": "socket",
                      "desc": "the bind address used to bind the listener in `qorus-core`",
                      "canBeNull": false,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "socket",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "string",
                        "can_manage_fields": false,
                        "mandatory": true,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          }
                        },
                        "types_accepted": ["string"],
                        "types_returned": ["string"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "socket-info": {
                      "name": "socket-info",
                      "desc": "a hash of socket information for the listening socket (as returned by `Qore::Socket::getSocketInfo()`)\n",
                      "canBeNull": false,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "socket-info",
                      "parentPath": false,
                      "type": {
                        "base_type": "hash<auto>",
                        "name": "hash<auto>",
                        "can_manage_fields": false,
                        "mandatory": true,
                        "typename": "hash",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          }
                        },
                        "types_accepted": ["hash"],
                        "types_returned": ["hash"],
                        "xname": "HashDataType",
                        "fields": {}
                      }
                    },
                    "peer-info": {
                      "name": "peer-info",
                      "desc": "a hash of socket information for the remote socket (as returned by `Qore::Socket::getPeerInfo()`)",
                      "canBeNull": false,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "peer-info",
                      "parentPath": false,
                      "type": {
                        "base_type": "hash<auto>",
                        "name": "hash<auto>",
                        "can_manage_fields": false,
                        "mandatory": true,
                        "typename": "hash",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          }
                        },
                        "types_accepted": ["hash"],
                        "types_returned": ["hash"],
                        "xname": "HashDataType",
                        "fields": {}
                      }
                    },
                    "url": {
                      "name": "url",
                      "desc": "a hash of broken-down URL information (as returned from `parse_url()`)",
                      "canBeNull": false,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "url",
                      "parentPath": false,
                      "type": {
                        "base_type": "hash<auto>",
                        "name": "hash<auto>",
                        "can_manage_fields": false,
                        "mandatory": true,
                        "typename": "hash",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          }
                        },
                        "types_accepted": ["hash"],
                        "types_returned": ["hash"],
                        "xname": "HashDataType",
                        "fields": {}
                      }
                    },
                    "id": {
                      "name": "id",
                      "desc": "The unique connection ID assigned by the HTTP server",
                      "canBeNull": false,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "id",
                      "parentPath": false,
                      "type": {
                        "base_type": "int",
                        "name": "int",
                        "can_manage_fields": false,
                        "mandatory": true,
                        "typename": "int",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          }
                        },
                        "types_accepted": ["int", "integer"],
                        "types_returned": ["int", "integer"],
                        "xname": "QoreDataType",
                        "fields": {}
                      }
                    },
                    "listener-id": {
                      "name": "listener-id",
                      "desc": "the HTTP server listener ID (see `HttpServer::HttpServer::getListenerInfo()`)",
                      "canBeNull": false,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "listener-id",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "string",
                        "can_manage_fields": false,
                        "mandatory": true,
                        "typename": "string",
                        "options": {
                          "qore.no_null": true
                        },
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          }
                        },
                        "types_accepted": ["string"],
                        "types_returned": ["string"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    },
                    "user": {
                      "name": "user",
                      "desc": "The Qorus username for the connection user, if any",
                      "canBeNull": true,
                      "isCustom": true,
                      "firstCustomInHierarchy": true,
                      "isChild": false,
                      "level": 0,
                      "path": "user",
                      "parentPath": false,
                      "type": {
                        "base_type": "string",
                        "name": "*string",
                        "can_manage_fields": false,
                        "mandatory": false,
                        "typename": "string",
                        "options": null,
                        "supported_options": {
                          "qore.no_null": {
                            "type": "bool",
                            "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                          },
                          "qore.external_name": {
                            "type": "string",
                            "desc": "A note giving the external name for the type"
                          },
                          "string.encoding": {
                            "type": "string",
                            "desc": "the output encoding when writing to the type"
                          },
                          "string.max_size_chars": {
                            "type": "integer",
                            "desc": "the maximum length of the string in characters"
                          },
                          "string.empty_to_nothing": {
                            "type": "bool",
                            "desc": "if an empty string should be converted to no value"
                          }
                        },
                        "types_accepted": ["string", "nothing", "null"],
                        "types_returned": ["string", "nothing"],
                        "xname": "QoreStringDataTypeBase",
                        "fields": {}
                      }
                    }
                  }
                }
              },
              "type": {
                "name": "type",
                "desc": "the original message payload type:\n- `STRING`\n- `BINARY`",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "type",
                "parentPath": false,
                "type": {
                  "base_type": "string",
                  "name": "string",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "string",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    },
                    "string.encoding": {
                      "type": "string",
                      "desc": "the output encoding when writing to the type"
                    },
                    "string.max_size_chars": {
                      "type": "integer",
                      "desc": "the maximum length of the string in characters"
                    }
                  },
                  "types_accepted": ["string"],
                  "types_returned": ["string"],
                  "xname": "QoreStringDataTypeBase",
                  "fields": {}
                }
              },
              "msg": {
                "name": "msg",
                "desc": "The actual message from the remote WebSocket client - any type that can be deserialized",
                "canBeNull": true,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "msg",
                "parentPath": false,
                "type": {
                  "base_type": "auto",
                  "name": "auto",
                  "can_manage_fields": false,
                  "mandatory": false,
                  "typename": "auto",
                  "options": null,
                  "supported_options": null,
                  "types_accepted": ["any"],
                  "types_returned": ["any"],
                  "xname": "QoreDataType",
                  "fields": {}
                }
              },
              "cid": {
                "name": "cid",
                "desc": "the string connection ID; this ID must be used to send messages to the same connection",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "cid",
                "parentPath": false,
                "type": {
                  "base_type": "string",
                  "name": "string",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "string",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    },
                    "string.encoding": {
                      "type": "string",
                      "desc": "the output encoding when writing to the type"
                    },
                    "string.max_size_chars": {
                      "type": "integer",
                      "desc": "the maximum length of the string in characters"
                    }
                  },
                  "types_accepted": ["string"],
                  "types_returned": ["string"],
                  "xname": "QoreStringDataTypeBase",
                  "fields": {}
                }
              }
            }
          },
          "locked": false
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got type 29"
    },
    {
      "request_id": "s7DBB6jVC6A4pzv",
      "tab_token": "none",
      "data": {
        "iface_kind": "type",
        "type": {
          "id": 30,
          "type": "type",
          "path": "/qoretechnologies/building-blocks/websockets/send-data-event",
          "display_name": "/qoretechnologies/building-blocks/websockets/send-data-event",
          "short_desc": "Qore data type \"hash<auto>\"",
          "desc": "Qore data type \"hash<auto>\"",
          "typeinfo": {
            "base_type": "hash<auto>",
            "name": "hash<auto>",
            "can_manage_fields": true,
            "mandatory": true,
            "typename": "hash",
            "options": null,
            "supported_options": {
              "qore.no_null": {
                "type": "bool",
                "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
              },
              "qore.external_name": {
                "type": "string",
                "desc": "A note giving the external name for the type"
              }
            },
            "types_accepted": ["hash"],
            "types_returned": ["hash"],
            "xname": "HashDataType",
            "fields": {
              "cid": {
                "name": "cid",
                "desc": "The connection ID to use to send the message",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "cid",
                "parentPath": false,
                "type": {
                  "base_type": "string",
                  "name": "string",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "string",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    },
                    "string.encoding": {
                      "type": "string",
                      "desc": "the output encoding when writing to the type"
                    },
                    "string.max_size_chars": {
                      "type": "integer",
                      "desc": "the maximum length of the string in characters"
                    }
                  },
                  "types_accepted": ["string"],
                  "types_returned": ["string"],
                  "xname": "QoreStringDataTypeBase",
                  "fields": {}
                }
              },
              "msg": {
                "name": "msg",
                "desc": "The message to send; can be of any type that can be serialized",
                "canBeNull": true,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "msg",
                "parentPath": false,
                "type": {
                  "base_type": "auto",
                  "name": "auto",
                  "can_manage_fields": false,
                  "mandatory": false,
                  "typename": "auto",
                  "options": null,
                  "supported_options": null,
                  "types_accepted": ["any"],
                  "types_returned": ["any"],
                  "xname": "QoreDataType",
                  "fields": {}
                }
              }
            }
          },
          "locked": false
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got type 30"
    },
    {
      "request_id": "oRMzjVysR9cGr1q",
      "tab_token": "none",
      "data": {
        "iface_kind": "type",
        "type": {
          "id": 31,
          "type": "type",
          "path": "/haltian/sensor/busylight-output",
          "display_name": "/haltian/sensor/busylight-output",
          "short_desc": "Qore data type \"hash<auto>\"",
          "desc": "Qore data type \"hash<auto>\"",
          "typeinfo": {
            "base_type": "hash<auto>",
            "name": "hash<auto>",
            "can_manage_fields": true,
            "mandatory": true,
            "typename": "hash",
            "options": null,
            "supported_options": {
              "qore.no_null": {
                "type": "bool",
                "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
              },
              "qore.external_name": {
                "type": "string",
                "desc": "A note giving the external name for the type"
              }
            },
            "types_accepted": ["hash"],
            "types_returned": ["hash"],
            "xname": "HashDataType",
            "fields": {
              "red": {
                "name": "red",
                "desc": "The `RED` light color component, from 0-255 (default `0`)",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "red",
                "parentPath": false,
                "type": {
                  "base_type": "int",
                  "name": "int",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "int",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    }
                  },
                  "types_accepted": ["int", "integer"],
                  "types_returned": ["int", "integer"],
                  "xname": "QoreDataType",
                  "fields": {}
                }
              },
              "green": {
                "name": "green",
                "desc": "The `GREEN` light color component, from 0-255 (default `0`)",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "green",
                "parentPath": false,
                "type": {
                  "base_type": "int",
                  "name": "int",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "int",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    }
                  },
                  "types_accepted": ["int", "integer"],
                  "types_returned": ["int", "integer"],
                  "xname": "QoreDataType",
                  "fields": {}
                }
              },
              "blue": {
                "name": "blue",
                "desc": "The `BLUE` light color component, from 0-255 (default `0`)",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "blue",
                "parentPath": false,
                "type": {
                  "base_type": "int",
                  "name": "int",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "int",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    }
                  },
                  "types_accepted": ["int", "integer"],
                  "types_returned": ["int", "integer"],
                  "xname": "QoreDataType",
                  "fields": {}
                }
              },
              "on": {
                "name": "on",
                "desc": "The `ON` light duration, from 0-255 (default `255`)",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "on",
                "parentPath": false,
                "type": {
                  "base_type": "int",
                  "name": "int",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "int",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    }
                  },
                  "types_accepted": ["int", "integer"],
                  "types_returned": ["int", "integer"],
                  "xname": "QoreDataType",
                  "fields": {}
                }
              },
              "off": {
                "name": "off",
                "desc": "The `OFF` light duration, from 0-255 (default `0`)",
                "canBeNull": false,
                "isCustom": true,
                "firstCustomInHierarchy": true,
                "isChild": false,
                "level": 0,
                "path": "off",
                "parentPath": false,
                "type": {
                  "base_type": "int",
                  "name": "int",
                  "can_manage_fields": false,
                  "mandatory": true,
                  "typename": "int",
                  "options": {
                    "qore.no_null": true
                  },
                  "supported_options": {
                    "qore.no_null": {
                      "type": "bool",
                      "desc": "if True then NULL is not supported on input if NOTHING is also not accepted"
                    },
                    "qore.external_name": {
                      "type": "string",
                      "desc": "A note giving the external name for the type"
                    }
                  },
                  "types_accepted": ["int", "integer"],
                  "types_returned": ["int", "integer"],
                  "xname": "QoreDataType",
                  "fields": {}
                }
              }
            }
          },
          "locked": false
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got type 31"
    }
  ],
  "value-map": [
    {
      "request_id": "sLJulOHA5DGg62K",
      "tab_token": "none",
      "data": {
        "iface_kind": "value-map",
        "value-map": {
          "id": 1,
          "type": "value-map",
          "name": "regression1",
          "display_name": "Regression1",
          "short_desc": "test value map",
          "desc": "test value map",
          "valuetype": "string",
          "dateformat": "DD.MM.YYYY",
          "exception": true,
          "author": ["Petr Vanek (Qore Technologies, sro)"],
          "groups": ["test"],
          "value-maps": [
            {
              "id": 1,
              "key": "key1",
              "value": "foo"
            },
            {
              "id": 2,
              "key": "key2",
              "value": "bar"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got value-map 1"
    },
    {
      "request_id": "G4ie0scaaYWz2cb",
      "tab_token": "none",
      "data": {
        "iface_kind": "value-map",
        "value-map": {
          "id": 2,
          "type": "value-map",
          "name": "regression2",
          "display_name": "Regression2",
          "short_desc": "test value map",
          "desc": "test value map",
          "valuetype": "string",
          "dateformat": "DD.MM.YYYY",
          "exception": false,
          "author": ["Petr Vanek (Qore Technologies, sro)"],
          "groups": ["test"],
          "value-maps": [
            {
              "id": 1,
              "key": "key1",
              "value": "foo"
            },
            {
              "id": 2,
              "key": "key2",
              "value": "bar"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got value-map 2"
    },
    {
      "request_id": "8E08XLKZRWr2bgz",
      "tab_token": "none",
      "data": {
        "iface_kind": "value-map",
        "value-map": {
          "id": 3,
          "type": "value-map",
          "name": "regression3",
          "display_name": "Regression3",
          "short_desc": "test value map",
          "desc": "test value map",
          "valuetype": "int",
          "dateformat": "DD.MM.YYYY",
          "exception": true,
          "author": ["Petr Vanek (Qore Technologies, sro)"],
          "groups": ["test"],
          "value-maps": [
            {
              "id": 1,
              "key": "key1",
              "value": 1
            },
            {
              "id": 2,
              "key": "key2",
              "value": 2
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got value-map 3"
    },
    {
      "request_id": "uQ3xlU3d6vlueXB",
      "tab_token": "none",
      "data": {
        "iface_kind": "value-map",
        "value-map": {
          "id": 6,
          "type": "value-map",
          "name": "issue3102regression3",
          "display_name": "Issue3102regression3",
          "short_desc": "test value map",
          "desc": "test value map",
          "valuetype": "int",
          "dateformat": "DD.MM.YYYY",
          "exception": true,
          "author": ["Petr Vanek (Qore Technologies, sro)"],
          "groups": ["test"],
          "value-maps": [
            {
              "id": 1,
              "key": "key1",
              "value": 1
            },
            {
              "id": 2,
              "key": "key2",
              "value": 2
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got value-map 6"
    },
    {
      "request_id": "xFp7Eob4DTiu4VX",
      "tab_token": "none",
      "data": {
        "iface_kind": "value-map",
        "value-map": {
          "id": 7,
          "type": "value-map",
          "name": "issue3102vmap",
          "display_name": "Issue3102vmap",
          "short_desc": "test value map",
          "desc": "test value map",
          "valuetype": "int",
          "dateformat": "YYYY-MM-DD",
          "exception": true,
          "author": ["Petr Vanek (Qore Technologies, sro)"],
          "groups": ["issue3102group"],
          "value-maps": [
            {
              "id": 1,
              "key": "key1",
              "value": 1
            },
            {
              "id": 2,
              "key": "key2",
              "value": 2
            },
            {
              "id": 3,
              "key": "key3",
              "value": 3
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got value-map 7"
    },
    {
      "request_id": "IN38XlZlkIkOCTy",
      "tab_token": "none",
      "data": {
        "iface_kind": "value-map",
        "value-map": {
          "id": 17,
          "type": "value-map",
          "name": "SegmentMap",
          "display_name": "Segment Map",
          "short_desc": "Maps MEWS segments to NetSuite segments",
          "desc": "Maps MEWS segments to NetSuite segments; default when no match: `HO : RR : RRT`",
          "valuetype": "string",
          "dateformat": "YYYY-MM-DD",
          "exception": false,
          "author": ["Qore Technologies, s.r.o."],
          "groups": ["JULIUS-MEINL"],
          "value-maps": [
            {
              "id": 1,
              "key": "10-Retail",
              "value": "HO : RR : RRT : RETL"
            },
            {
              "id": 2,
              "key": "12-Negotiated",
              "value": "HO : RR : RRT : NEGT"
            },
            {
              "id": 3,
              "key": "11-Discount",
              "value": "HO : RR : RRT : DISC"
            },
            {
              "id": 4,
              "key": "22-Government Group",
              "value": "HO : RR : RRG : GOVT"
            },
            {
              "id": 5,
              "key": "20-Corporate Group",
              "value": "HO : RR : RRG : CRPX"
            },
            {
              "id": 6,
              "key": "23-Tour / Wholesalers Group",
              "value": "HO : RR : RRG : TOUR"
            },
            {
              "id": 7,
              "key": "24-SMERF Group",
              "value": "HO : RR : RRG : SMRF"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got value-map 17"
    },
    {
      "request_id": "91mj8sfapEVBWzX",
      "tab_token": "none",
      "data": {
        "iface_kind": "value-map",
        "value-map": {
          "id": 18,
          "type": "value-map",
          "name": "VatCodes",
          "display_name": "Vat Codes",
          "short_desc": "Maps from MEWS VAT rates to NetSuite VAT codes",
          "desc": "Maps from MEWS VAT rates to NetSuite VAT codes; default when no mapping exists: `VAT:UNDEF-CZ`",
          "valuetype": "string",
          "dateformat": "YYYY-MM-DD",
          "exception": false,
          "author": ["Qore Technologies, s.r.o."],
          "groups": ["JULIUS-MEINL"],
          "value-maps": [
            {
              "id": 1,
              "key": "0",
              "value": "N/A:Mews"
            },
            {
              "id": 2,
              "key": "0.1",
              "value": "VAT:SR-CZ"
            },
            {
              "id": 3,
              "key": "0.15",
              "value": "VAT:R-CZ"
            },
            {
              "id": 4,
              "key": "0.21",
              "value": "VAT:S-CZ"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got value-map 18"
    },
    {
      "request_id": "gaasrkUplhfklQW",
      "tab_token": "none",
      "data": {
        "iface_kind": "value-map",
        "value-map": {
          "id": 147,
          "type": "value-map",
          "name": "value-map-test-int",
          "display_name": "Value Map Test Int",
          "short_desc": "Value map test",
          "desc": "Value map test",
          "valuetype": "int",
          "dateformat": "YYYY-MM-DD",
          "exception": false,
          "author": ["Qore Technologies, s.r.o."],
          "value-maps": [
            {
              "id": 1,
              "key": "a",
              "value": 1
            },
            {
              "id": 2,
              "key": "b",
              "value": 2
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got value-map 147"
    },
    {
      "request_id": "k5LGTVAkMiF47B2",
      "tab_token": "none",
      "data": {
        "iface_kind": "value-map",
        "value-map": {
          "id": 148,
          "type": "value-map",
          "name": "value-map-test-date",
          "display_name": "Value Map Test Date",
          "short_desc": "Value map test",
          "desc": "Value map test",
          "valuetype": "date",
          "dateformat": "YYYY-MM-DD HH:mm:SS",
          "exception": false,
          "author": ["Qore Technologies, s.r.o."],
          "value-maps": [
            {
              "id": 1,
              "key": "a",
              "value": "2024-04-02T13:30:00.000000+02:00"
            },
            {
              "id": 2,
              "key": "b",
              "value": "2024-04-02T16:00:00.000000+02:00"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got value-map 148"
    },
    {
      "request_id": "QFaENH2TqqqhXQY",
      "tab_token": "none",
      "data": {
        "iface_kind": "value-map",
        "value-map": {
          "id": 149,
          "type": "value-map",
          "name": "value-map-test-string",
          "display_name": "Value Map Test String",
          "short_desc": "Value map test",
          "desc": "Value map test",
          "valuetype": "string",
          "dateformat": "YYYY-MM-DD",
          "exception": false,
          "author": ["Qore Technologies, s.r.o."],
          "value-maps": [
            {
              "id": 1,
              "key": "a",
              "value": "1"
            },
            {
              "id": 2,
              "key": "b",
              "value": "two"
            },
            {
              "id": 3,
              "key": "c",
              "value": "3.0"
            },
            {
              "id": 4,
              "key": "d",
              "value": "2024-04-02"
            }
          ]
        }
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got value-map 149"
    }
  ],
  "workflow": [
    {
      "request_id": "KBZLsiNT6Tuhho0",
      "tab_token": "none",
      "data": {
        "iface_kind": "workflow",
        "workflow": {
          "id": 166,
          "type": "workflow",
          "name": "ISSUE-3333-WORKFLOW",
          "display_name": "ISSUE 3333 WORKFLOW",
          "short_desc": "ISSUE-3333-WORKFLOW test workflow",
          "desc": "ISSUE-3333-WORKFLOW test workflow",
          "version": "1.0",
          "autostart": 0,
          "remote": true,
          "sla_threshold": 1800,
          "lang": "qore",
          "author": ["Qore Technologies, s.r.o."],
          "classes": [
            {
              "id": 1,
              "name": "issue3333class"
            }
          ],
          "steps": ["issue3333step1:1.0", "issue3333step2:1.0"],
          "steps-info": {
            "issue3333step1:1.0": {
              "type": "step",
              "lang": "qore",
              "source": "%new-style\n%require-types\n%strict-args\n%enable-all-warnings\n\nclass issue3333step1 inherits QorusNormalArrayStep {\n    softlist<auto> array() {\n        return (\"test1\", \"test2\", \"test3\");\n    }\n\n    primary(auto array_arg) {\n        logInfo(\"array_arg: %s\", array_arg);\n    }\n}\n",
              "name": "issue3333step1",
              "display_name": "Issue3333step1",
              "short_desc": "issue3333 array test step",
              "desc": "issue3333 array test step",
              "version": "1.0",
              "steptype": "NORMAL",
              "arraytype": "SERIES",
              "author": ["Qore Technologies, s.r.o."],
              "class-name": "issue3333step1",
              "classes": ["issue3333class"]
            },
            "issue3333step2:1.0": {
              "type": "step",
              "lang": "qore",
              "source": "%new-style\n%require-types\n%strict-args\n%enable-all-warnings\n\nclass issue3333step2 inherits QorusNormalArrayStep {\n    softlist<auto> array() {\n        return (\"test1\", \"test2\", \"test3\");\n    }\n\n    primary(auto array_arg) {\n        logInfo(\"array_arg: %s\", array_arg);\n    }\n}\n",
              "name": "issue3333step2",
              "display_name": "Issue3333step2",
              "short_desc": "issue3333 array test step",
              "desc": "issue3333 array test step",
              "version": "1.0",
              "steptype": "NORMAL",
              "arraytype": "SERIES",
              "author": ["Qore Technologies, s.r.o."],
              "class-name": "issue3333step2",
              "classes": ["issue3333class"]
            }
          }
        },
        "supports_enable": true,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got workflow 166"
    },
    {
      "request_id": "iknlYgk915dyKNx",
      "tab_token": "none",
      "data": {
        "iface_kind": "workflow",
        "workflow": {
          "id": 14,
          "type": "workflow",
          "name": "TELCO-RETIRE-ACCOUNT",
          "display_name": "TELCO RETIRE ACCOUNT",
          "short_desc": "demo telco account suspension workflow",
          "desc": "demo telco account suspension workflow",
          "version": "1.0",
          "autostart": 1,
          "remote": false,
          "sla_threshold": 55,
          "groups": ["demo", "demo-telco-om"],
          "lang": "qore",
          "author": ["Qore Technologies, s.r.o."],
          "steps": [
            "telco_retire_billing_account:1.0",
            [
              "telco_retire_technical_services:1.0",
              "telco_retire_counter_fraud_account:1.0"
            ],
            "telco_update_crm_retire_account:1.0"
          ],
          "steps-info": {
            "telco_retire_billing_account:1.0": {
              "type": "step",
              "lang": "qore",
              "name": "telco_retire_billing_account",
              "display_name": "Telco Retire Billing Account",
              "short_desc": "retire the billing account",
              "desc": "retire the billing account",
              "version": "1.0",
              "steptype": "NORMAL",
              "arraytype": "NONE",
              "author": ["Qore Technologies, s.r.o."]
            },
            "telco_retire_technical_services:1.0": {
              "type": "step",
              "lang": "qore",
              "name": "telco_retire_technical_services",
              "display_name": "Telco Retire Technical Services",
              "short_desc": "retire services on the network and supporting systems (number management, MNP etc) according to the product/tariff/options ordered",
              "desc": "retire services on the network and supporting systems (number management, MNP etc) according to the product/tariff/options ordered",
              "version": "1.0",
              "steptype": "SUBWORKFLOW",
              "arraytype": "SERIES",
              "author": ["Qore Technologies, s.r.o."]
            },
            "telco_retire_counter_fraud_account:1.0": {
              "type": "step",
              "lang": "qore",
              "name": "telco_retire_counter_fraud_account",
              "display_name": "Telco Retire Counter Fraud Account",
              "short_desc": "retire the account info in the counter-fraud system",
              "desc": "retire the account info in the counter-fraud system",
              "version": "1.0",
              "steptype": "NORMAL",
              "arraytype": "NONE",
              "author": ["Qore Technologies, s.r.o."]
            },
            "telco_update_crm_retire_account:1.0": {
              "type": "step",
              "lang": "qore",
              "name": "telco_update_crm_retire_account",
              "display_name": "Telco Update Crm Retire Account",
              "short_desc": "update the CRM system on the status of the account suspension action",
              "desc": "update the CRM system on the status of the account suspension action",
              "version": "1.0",
              "steptype": "NORMAL",
              "arraytype": "NONE",
              "author": ["Qore Technologies, s.r.o."]
            }
          }
        },
        "supports_enable": true,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got workflow 14"
    },
    {
      "request_id": "WpHQrfMtacMIK4I",
      "tab_token": "none",
      "data": {
        "iface_kind": "workflow",
        "workflow": {
          "id": 114,
          "type": "workflow",
          "name": "ISSUE-3274-WORKFLOW2",
          "display_name": "ISSUE 3274 WORKFLOW2",
          "short_desc": "test class-based java workflow",
          "desc": "test class-based java workflow",
          "version": "1.0",
          "autostart": 0,
          "remote": true,
          "sla_threshold": 2,
          "source": "import com.qoretechnologies.qorus.OMQ;\nimport com.qoretechnologies.qorus.UserApi;\nimport com.qoretechnologies.qorus.workflow.QorusWorkflow;\n\nimport java.util.Map;\n\nclass Issue3274WorkflowJavaClass extends QorusWorkflow {\n    @Override\n    protected void oneTimeInitImpl() throws Throwable {\n        logInfo(\"Issue3274WorkflowClass::oneTimeInitImpl is called\");\n    }\n\n    @Override\n    protected void errorHandlerImpl(String errcode, Map<String, Object> errinfo, Object opt) throws Throwable {\n        logInfo(\"Issue3274WorkflowClass::errorHandlerImpl is called\");\n    }\n\n    @Override\n    protected void detachImpl(String status, String external_order_instanceid) throws Throwable {\n        logInfo(\"Issue3274WorkflowClass::detachImpl is called\");\n    }\n\n    @Override\n    protected void attachImpl() throws Throwable {\n        logInfo(\"Issue3274WorkflowClass::attachImpl is called\");\n    }\n}\n",
          "base-class-name": "QorusWorkflow",
          "class-name": "Issue3274WorkflowJavaClass",
          "lang": "java",
          "author": ["Qore Technologies, s.r.o."],
          "steps": ["Issue3274Step2:1.0"],
          "steps-info": {
            "Issue3274Step2:1.0": {
              "type": "step",
              "lang": "qore",
              "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass Issue3274Step inherits QorusNormalStep {\n    primary() {\n        log(LL_INFO, \"Issue3274Step was called\");\n    }\n}\n",
              "name": "Issue3274Step2",
              "display_name": "Issue3274 Step2",
              "short_desc": "Simple worklfow step example",
              "desc": "Simple worklfow step example",
              "version": "1.0",
              "steptype": "NORMAL",
              "arraytype": "NONE",
              "author": ["Qore Technologies, s.r.o."],
              "class-name": "Issue3274Step"
            }
          }
        },
        "supports_enable": true,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got workflow 114"
    },
    {
      "request_id": "GSFrhW59vMHze92",
      "tab_token": "none",
      "data": {
        "iface_kind": "workflow",
        "workflow": {
          "id": 47,
          "type": "workflow",
          "name": "MAPPER-TEST",
          "display_name": "MAPPER TEST",
          "short_desc": "mapper test workflow",
          "desc": "mapper test workflow",
          "version": "1.0",
          "autostart": 0,
          "remote": false,
          "sla_threshold": 60,
          "groups": ["test", "regression"],
          "lang": "qore",
          "author": ["Qore Technologies, s.r.o."],
          "classes": [
            {
              "id": 1,
              "name": "MapperProviderTest"
            },
            {
              "id": 2,
              "name": "QoreTest"
            }
          ],
          "mappers": ["mapper-test-1", "mapper-test-2"],
          "steps": ["MapperTest1:1.0", "MapperTest2:1.0"],
          "steps-info": {
            "MapperTest1:1.0": {
              "type": "step",
              "lang": "qore",
              "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass MapperTest1 inherits QorusNormalStep, MapperProviderTest {\n    primary() {\n        # skip step if there is no omquser datasource\n        try {\n            callRestApi(\"GET\", \"remote/datasources/omquser/up\");\n        } catch (hash<ExceptionInfo> ex) {\n            if (ex.err != \"REST-CLASS-ERROR\" && ex.err != \"DATASTREAM-CLIENT-RECEIVE-ERROR\") {\n                rethrow;\n            }\n            log(LL_INFO, \"no omquser datasource; skipping tests\");\n            return;\n        }\n\n        log(LL_INFO, \"MapperTest1 called\");\n        Mapper mapper = getMapper(\"mapper-test-1\");\n        deleteOutput(mapper);\n        testMapper(mapper);\n    }\n}\n",
              "name": "MapperTest1",
              "display_name": "Mapper Test1",
              "short_desc": "mapper test step",
              "desc": "mapper test step",
              "version": "1.0",
              "steptype": "NORMAL",
              "arraytype": "NONE",
              "author": ["Qore Technologies, s.r.o."],
              "class-name": "MapperTest1",
              "base-class-name": "QorusNormalStep",
              "classes": ["QoreTest"]
            },
            "MapperTest2:1.0": {
              "type": "step",
              "lang": "qore",
              "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass MapperTest2 inherits QorusNormalStep, MapperProviderTest {\n    primary() {\n        # skip step if there is no omquser datasource\n        try {\n            callRestApi(\"GET\", \"remote/datasources/omquser/up\");\n        } catch (hash<ExceptionInfo> ex) {\n            if (ex.err != \"REST-CLASS-ERROR\" && ex.err != \"DATASTREAM-CLIENT-RECEIVE-ERROR\") {\n                rethrow;\n            }\n            log(LL_INFO, \"no omquser datasource; skipping tests\");\n            return;\n        }\n\n        log(LL_INFO, \"MapperTest2 called\");\n        Mapper mapper = getMapper(\"mapper-test-2\");\n        deleteOutput(mapper);\n        testMapper(mapper);\n    }\n}\n",
              "name": "MapperTest2",
              "display_name": "Mapper Test2",
              "short_desc": "mapper test step",
              "desc": "mapper test step",
              "version": "1.0",
              "steptype": "NORMAL",
              "arraytype": "NONE",
              "author": ["Qore Technologies, s.r.o."],
              "class-name": "MapperTest2",
              "base-class-name": "QorusNormalStep",
              "classes": ["QoreTest"]
            }
          }
        },
        "supports_enable": true,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got workflow 47"
    },
    {
      "request_id": "D65WlctrYJcWjHl",
      "tab_token": "none",
      "data": {
        "iface_kind": "workflow",
        "workflow": {
          "id": 148,
          "type": "workflow",
          "name": "BB-BIND-TEST-CHILD",
          "display_name": "BB BIND TEST CHILD",
          "short_desc": "test bind BB",
          "desc": "test bind BB",
          "version": "1.0",
          "autostart": 0,
          "remote": true,
          "sla_threshold": 1800,
          "groups": ["bb-test", "test"],
          "lang": "qore",
          "author": ["Qore Technologies, s.r.o."],
          "steps": ["bb-test-child:1.0"],
          "steps-info": {
            "bb-test-child:1.0": {
              "type": "step",
              "lang": "qore",
              "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass BbTestChild inherits QorusNormalStep {\n    primary() {\n    }\n}\n",
              "name": "bb-test-child",
              "display_name": "Bb Test Child",
              "short_desc": "test bind BB",
              "desc": "test bind BB",
              "version": "1.0",
              "steptype": "NORMAL",
              "arraytype": "NONE",
              "author": ["Qore Technologies, s.r.o."],
              "class-name": "BbTestChild",
              "base-class-name": "QorusNormalStep"
            }
          }
        },
        "supports_enable": true,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got workflow 148"
    },
    {
      "request_id": "t6bjtWXFeLxZtat",
      "tab_token": "none",
      "data": {
        "iface_kind": "workflow",
        "workflow": {
          "id": 152,
          "type": "workflow",
          "name": "BB-TEST-SFTP-WORKFLOW-DUP",
          "display_name": "BB TEST SFTP WORKFLOW DUP",
          "short_desc": "SFTP create order job BB test workflow",
          "desc": "SFTP create order job BB test workflow",
          "version": "1.0",
          "autostart": 0,
          "remote": false,
          "sla_threshold": 20,
          "keylist": ["filename", "orig_name"],
          "groups": ["test", "bb-test"],
          "lang": "qore",
          "author": ["Qore Technologies, s.r.o."],
          "steps": ["BBM_TestSftpWorkflowStep:1.0"],
          "steps-info": {
            "BBM_TestSftpWorkflowStep:1.0": {
              "type": "step",
              "lang": "qore",
              "source": "%new-style\n%require-types\n%strict-args\n%enable-all-warnings\n\nclass BBM_TestSftpWorkflowStep inherits QorusNormalStep {\n    primary() {\n        # get path\n        *string path = getStaticData(\"local_path\");\n        if (path) {\n            # read in file data to dynamic data\n            string data = File::readTextFile(path);\n            # log path\n            logInfo(\"got path: %y (%d bytes)\", path, data.size());\n            # update dynamic data\n            updateDynamicData({\"data\": data});\n            # unlink file\n            unlink(path);\n        } else {\n            logInfo(\"file data: %d bytes\", getStaticData(\"data\").size());\n        }\n    }\n}\n",
              "name": "BBM_TestSftpWorkflowStep",
              "display_name": "BBM Test Sftp Workflow Step",
              "short_desc": "Qore test step class",
              "desc": "Qore test step class",
              "version": "1.0",
              "steptype": "NORMAL",
              "arraytype": "NONE",
              "author": ["Qore Technologies, s.r.o."],
              "class-name": "BBM_TestSftpWorkflowStep",
              "base-class-name": "QorusNormalStep"
            }
          }
        },
        "supports_enable": true,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got workflow 152"
    },
    {
      "request_id": "orbQLG9vEHdNR4C",
      "tab_token": "none",
      "data": {
        "iface_kind": "workflow",
        "workflow": {
          "id": 49,
          "type": "workflow",
          "name": "SYNC-CANCEL-TEST",
          "display_name": "SYNC CANCEL TEST",
          "short_desc": "Tests issue #3486: canceling or setting a synchronous order with a 'RETRY' status to error",
          "desc": "Tests issue #3486: canceling or setting a synchronous order with a `RETRY` status to error",
          "version": "1.0",
          "autostart": 0,
          "remote": false,
          "sla_threshold": 1800,
          "groups": ["regression", "test"],
          "lang": "qore",
          "author": ["Qore Technologies, s.r.o."],
          "steps": ["RetryForeverTest:1.0"],
          "steps-info": {
            "RetryForeverTest:1.0": {
              "type": "step",
              "lang": "qore",
              "source": "%new-style\n%strict-args\n%require-types\n%enable-all-warnings\n\nclass RetryForeverTest inherits QorusNormalStep {\n    primary() {\n        stepError(\"RETRY-ERROR\", \"retry with a one-year delay\", 1Y);\n    }\n}\n",
              "name": "RetryForeverTest",
              "display_name": "Retry Forever Test",
              "short_desc": "This step will go to a 'RETRY' status indefinitely",
              "desc": "This step will go to a `RETRY` status indefinitely",
              "version": "1.0",
              "steptype": "NORMAL",
              "arraytype": "NONE",
              "author": ["Qore Technologies, s.r.o."],
              "class-name": "RetryForeverTest",
              "base-class-name": "QorusNormalStep"
            }
          }
        },
        "supports_enable": true,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got workflow 49"
    },
    {
      "request_id": "ujDf0kMZvUHn2sc",
      "tab_token": "none",
      "data": {
        "iface_kind": "workflow",
        "workflow": {
          "id": 68,
          "type": "workflow",
          "name": "SIMPLETEST",
          "display_name": "SIMPLETEST",
          "short_desc": "simple test workflow with 3 linear steps",
          "desc": "simple test workflow with 3 linear steps",
          "version": "1.0",
          "autostart": 0,
          "remote": true,
          "sla_threshold": 1800,
          "keylist": [
            "key1",
            "key2",
            "key3",
            "key4",
            "key5",
            "key6",
            "key7",
            "key8",
            "key9"
          ],
          "groups": ["test"],
          "lang": "qore",
          "author": ["Qore Technologies, sro"],
          "classes": [
            {
              "id": 1,
              "name": "TestClass1"
            },
            {
              "id": 2,
              "name": "TestClass2"
            }
          ],
          "steps": [
            "test_function_1:1.0",
            "test_function_2:1.0",
            "test_function_3:1.0"
          ],
          "steps-info": {
            "test_function_1:1.0": {
              "type": "step",
              "lang": "qore",
              "name": "test_function_1",
              "display_name": "Test Function 1",
              "desc": "test function 1",
              "version": "1.0",
              "steptype": "NORMAL",
              "arraytype": "NONE",
              "author": ["Qore Technologies, sro"]
            },
            "test_function_2:1.0": {
              "type": "step",
              "lang": "qore",
              "name": "test_function_2",
              "display_name": "Test Function 2",
              "desc": "test function 2",
              "version": "1.0",
              "steptype": "NORMAL",
              "arraytype": "NONE",
              "author": ["Qore Technologies, sro"]
            },
            "test_function_3:1.0": {
              "type": "step",
              "lang": "qore",
              "name": "test_function_3",
              "display_name": "Test Function 3",
              "desc": "test function 3",
              "version": "1.0",
              "steptype": "NORMAL",
              "arraytype": "NONE",
              "author": ["Qore Technologies, sro"]
            }
          }
        },
        "supports_enable": true,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got workflow 68"
    },
    {
      "request_id": "dHqFJgFHNWvsppG",
      "tab_token": "none",
      "data": {
        "iface_kind": "workflow",
        "workflow": {
          "id": 13,
          "type": "workflow",
          "name": "TELCO-RESUME-SERVICE",
          "display_name": "TELCO RESUME SERVICE",
          "short_desc": "demo telco technical service suspension workflow",
          "desc": "demo telco technical service suspension workflow",
          "version": "1.0",
          "autostart": 1,
          "remote": false,
          "sla_threshold": 12,
          "groups": ["demo", "demo-telco-om"],
          "lang": "qore",
          "author": ["Qore Technologies, s.r.o."],
          "steps": [
            "telco_resume_service:1.0",
            "telco_update_crm_resume_service:1.0"
          ],
          "steps-info": {
            "telco_resume_service:1.0": {
              "type": "step",
              "lang": "qore",
              "name": "telco_resume_service",
              "display_name": "Telco Resume Service",
              "short_desc": "resume the technical service in the network or system",
              "desc": "resume the technical service in the network or system",
              "version": "1.0",
              "steptype": "ASYNC",
              "arraytype": "NONE",
              "author": ["Qore Technologies, s.r.o."],
              "queue": "demo-queue"
            },
            "telco_update_crm_resume_service:1.0": {
              "type": "step",
              "lang": "qore",
              "name": "telco_update_crm_resume_service",
              "display_name": "Telco Update Crm Resume Service",
              "short_desc": "update the CRM system on the status of the service suspension action",
              "desc": "update the CRM system on the status of the service suspension action",
              "version": "1.0",
              "steptype": "NORMAL",
              "arraytype": "NONE",
              "author": ["Qore Technologies, s.r.o."]
            }
          }
        },
        "supports_enable": true,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got workflow 13"
    },
    {
      "request_id": "8pZdrUcoFh6HHYn",
      "tab_token": "none",
      "data": {
        "iface_kind": "workflow",
        "workflow": {
          "id": 15,
          "type": "workflow",
          "name": "TELCO-RETIRE-CUSTOMER",
          "display_name": "TELCO RETIRE CUSTOMER",
          "short_desc": "demo telco customer suspension workflow",
          "desc": "demo telco customer suspension workflow",
          "version": "1.0",
          "autostart": 1,
          "remote": false,
          "sla_threshold": 60,
          "groups": ["demo", "demo-telco-om"],
          "lang": "qore",
          "author": ["Qore Technologies, s.r.o."],
          "steps": [
            "telco_retire_account:1.0",
            "telco_update_crm_retire_customer:1.0"
          ],
          "steps-info": {
            "telco_retire_account:1.0": {
              "type": "step",
              "lang": "qore",
              "name": "telco_retire_account",
              "display_name": "Telco Retire Account",
              "short_desc": "retire customer account",
              "desc": "retire customer account",
              "version": "1.0",
              "steptype": "SUBWORKFLOW",
              "arraytype": "SERIES",
              "author": ["Qore Technologies, s.r.o."]
            },
            "telco_update_crm_retire_customer:1.0": {
              "type": "step",
              "lang": "qore",
              "name": "telco_update_crm_retire_customer",
              "display_name": "Telco Update Crm Retire Customer",
              "short_desc": "update the CRM system on the status of the customer suspension action",
              "desc": "update the CRM system on the status of the customer suspension action",
              "version": "1.0",
              "steptype": "NORMAL",
              "arraytype": "NONE",
              "author": ["Qore Technologies, s.r.o."]
            }
          }
        },
        "supports_enable": true,
        "enabled": true
      },
      "action": "return-interface-data-complete",
      "ok": true,
      "message": "got workflow 15"
    }
  ]
}
